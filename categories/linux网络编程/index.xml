<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux网络编程 on PursUnre的博客</title>
        <link>https://Amarantos-Arrebol.github.io/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
        <description>Recent content in Linux网络编程 on PursUnre的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>PursUnre</copyright><atom:link href="https://Amarantos-Arrebol.github.io/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>【Linux网络编程】02Socket编程UDP</title>
        <link>https://Amarantos-Arrebol.github.io/p/network/</link>
        <pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate>
        
        <guid>https://Amarantos-Arrebol.github.io/p/network/</guid>
        <description>&lt;img src="https://Amarantos-Arrebol.github.io/p/network/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI%E9%A3%8E%E6%99%AF-%E5%85%89%E5%BD%B1%E9%A3%8E%E6%99%AF.png" alt="Featured image of post 【Linux网络编程】02Socket编程UDP" /&gt;</description>
        </item>
        <item>
        <title>【Linux网络编程】01网络基础</title>
        <link>https://Amarantos-Arrebol.github.io/p/network/</link>
        <pubDate>Sat, 22 Nov 2025 00:00:00 +0000</pubDate>
        
        <guid>https://Amarantos-Arrebol.github.io/p/network/</guid>
        <description>&lt;img src="https://Amarantos-Arrebol.github.io/p/network/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI%E9%A3%8E%E6%99%AF-%E5%85%89%E5%BD%B1%E9%A3%8E%E6%99%AF.png" alt="Featured image of post 【Linux网络编程】01网络基础" /&gt;&lt;h1 id=&#34;1-网络的发展&#34;&gt;1. 网络的发展
&lt;/h1&gt;&lt;p&gt;计算机是人类的工具，人之间是需要协作的，所以网络的产生是必然的&lt;/p&gt;
&lt;p&gt;网络具体是如何产生的？先局部产生，再到整体&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网络的历史：阿帕网—&amp;gt;90年代左右，公开了—美国人组建自己的互联网—&amp;gt;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;局域网LAN&lt;/strong&gt;：通过交换机和路由器将多台计算机连接&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交换机上可以连接多台计算机，实现多台计算机的互联互通&lt;/p&gt;
&lt;p&gt;路由器可以连接多个交换机，使几个交换机上连接的计算机互联互通&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122120351950.png&#34;
	width=&#34;621&#34;
	height=&#34;278&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122120351950&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;223&#34;
		data-flex-basis=&#34;536px&#34;
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;广域网WAN&lt;/strong&gt;：将远隔千里的计算机也能连接起来&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多个局域网互联就形成了广域网&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122120852295.png&#34;
	width=&#34;741&#34;
	height=&#34;312&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122120852295&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;570px&#34;
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122121130829.png&#34;
	width=&#34;964&#34;
	height=&#34;244&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122121130829&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;395&#34;
		data-flex-basis=&#34;948px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;2初识协议&#34;&gt;2.初识协议
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;协议本质上是一种约定&lt;/strong&gt;，可以减少通信成本，用于快速形成共识&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机是如何约定的呢？OSI&lt;/strong&gt;（只生产标准，不写代码实现）&lt;/p&gt;
&lt;p&gt;计算机之间的传输媒介是光信号和电信号。计算机通过“频率”和“强弱”来表示0和1这样的信息，所以要想让两台主机之间进行通信，至少需要约定好双方的数据格式，比如是通过“频率”来表示0/1还是通过“强弱”来表示0/1&lt;/p&gt;
&lt;p&gt;但是只约定好双方的数据格式是不够的，还需要更多细致的规定，并让所有人都遵守。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算机的厂商有很多，计算机操作系统有很多，计算机网络硬件设备也有很多，如何让这些不同的厂商之间生产的计算机能够互相顺畅的通信？就需要有人站出来约定一个共同的标准，让大家都来遵守，这就是&lt;strong&gt;网络协议&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能定制协议标准的组织或者公司有哪几类？&lt;/p&gt;
&lt;p&gt;1）国际标准化组织&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;IEEE（电气和电子工程师协会）&lt;/strong&gt;：一个由计算机和工程领域专家组成的庞大技术组织，在通信协议领域贡献突出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ISO（国际标准化组织）&lt;/strong&gt;：ISO是由多个国家的标准化团体组成的国际组织，它在开放系统互连（OSI）模型方面的工作尤为著名。&lt;strong&gt;OSI模型&lt;/strong&gt;定义了网络通信的七层协议结构，尽管在实际应用中，TCP/IP 协议族更为普遍，但OSI模型仍然在学术和理论研究中占有重要地位。&lt;/p&gt;
&lt;p&gt;&amp;hellip;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）区域标准化组织&lt;/p&gt;
&lt;p&gt;3）公司&lt;/p&gt;
&lt;p&gt;4）民间国际团体&lt;/p&gt;
&lt;p&gt;5）官方机构&lt;/p&gt;
&lt;h2 id=&#34;21协议分层&#34;&gt;2.1协议分层
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;协议本质也是软件，在设计上为了更好的进行&lt;strong&gt;模块化，解耦合&lt;/strong&gt;，也是被设计成为层状结构的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所有的软件都是层状的，模块化的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分层可以实现解耦合，让软件维护的成本更低&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122124502864.png&#34;
	width=&#34;420&#34;
	height=&#34;265&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122124502864&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;380px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;结论1：两种视角&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通用户视角，普通用户认为自己在和对方同层直接通信&lt;/li&gt;
&lt;li&gt;工程师视角，认为你是把消息交给下一层，下一层再把消息转给对应的层，然后再向上交付&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论2：同层之间，在“直接通信”&lt;/p&gt;
&lt;p&gt;结论3：分层之后，可以无障碍替换任意一层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;22osi七层模型&#34;&gt;2.2OSI七层模型
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OSl（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范&lt;/li&gt;
&lt;li&gt;把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机&lt;/li&gt;
&lt;li&gt;OSI七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输&lt;/li&gt;
&lt;li&gt;它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整。通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯&lt;/li&gt;
&lt;li&gt;但是，它既复杂又不实用;所以我们按照TCP/IP 四层模型来讲解.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122125257104.png&#34;
	width=&#34;729&#34;
	height=&#34;1113&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122125257104&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;65&#34;
		data-flex-basis=&#34;157px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其实在网络角度，OSI定的协议7层模型其实非常完善，但是在实际操作的过程中，会话层、表示层是不可能接入到操作系统中的，所以在工程实践中，最终落地的是5层协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;23tcpip五层模型&#34;&gt;2.3TCP/IP五层(或四层)模型
&lt;/h2&gt;&lt;p&gt;TCP/IP五层模型，是将OSI参考模型的表示层和会话层合并到应用层了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122125713506.png&#34;
	width=&#34;779&#34;
	height=&#34;497&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122125713506&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;376px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP 协议簇&lt;/p&gt;
&lt;p&gt;TCP/IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;物理层&lt;/strong&gt;：负责光/电信号的传递方式.比如现在以太网通用的网线(双绞 线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤,现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。集线器(Hub)工作在物理层.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;：负责设备之间的数据帧的传送和识别。例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作。有以太网、令牌环网，无线LAN等标准。交换机(Switch)工作在数据链路层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络层&lt;/strong&gt;：负责地址管理和路由选择。例如在IP 协议中,通过IP地址来标识一台主机，并通过路由表的方式规划出两台主机之间的数据传输的线路(路由).路由器(Router)工作在网路层.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输层&lt;/strong&gt;：负责两台主机之间的数据传输.如传输控制协议(TCP),能够确保数据可靠的从源主机发送到目标主机.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;：负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等.我们的网络编程主要就是针对应用层&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;物理层我们考虑的比较少，我们只考虑软件相关的内容。因此，很多时候我们直接称为TCP/IP 四层模型。&lt;/p&gt;
&lt;p&gt;一般而言：对于一台主机，它的操作系统内核实现了从传输层到物理层的内容；对于一台路由器，它实现了从网络层到物理层；对于一台交换机，它实现了从数据链路层到物理层；对于集线器，它只实现了物理层；&lt;/p&gt;
&lt;p&gt;但是并不绝对。很多交换机也实现了网络层的转发;很多路由器也实现了部分传输层的内容(比如端口转发）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;3再识协议&#34;&gt;3.再识协议
&lt;/h1&gt;&lt;h2 id=&#34;31为什么要有tcpip协议&#34;&gt;3.1为什么要有TCP/IP协议?
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本地通信 vs 网络通信&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本地通信，计算机内部的所有设备是通过“线”连接的，各种设备之间，其实也都是存在协议的。这些协议都在本地主机各自的硬件中，通信的成本、问题比较少。&lt;/li&gt;
&lt;li&gt;多台主机，通过网络通信，本质也是设备到设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中唯一的一个区别：**计算机通信的距离变长了！**距离变长就会引发新问题！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据丢了怎么办？&lt;/p&gt;
&lt;p&gt;怎么定位目标主机？&lt;/p&gt;
&lt;p&gt;怎么解决当下立即要去哪里的问题？&lt;/p&gt;
&lt;p&gt;目标主机怎么知道我发出去的数据该怎么处理？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有问题就会有解决方案！&lt;strong&gt;TCP/IP协议，本质就是一种网络长距离通信的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协议—不同性质，不同种类的问题—&amp;gt;&lt;strong&gt;协议分层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122132602103.png&#34;
	width=&#34;1061&#34;
	height=&#34;684&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122132602103&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;155&#34;
		data-flex-basis=&#34;372px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;32什么是tcpip协议&#34;&gt;3.2什么是TCP/IP协议?
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;TCP/IP 协议的本质是一种网络长距离通信的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP/IP 协议能分层，前提是因为问题们本身能分层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.我要发送数据给目标主机，得先发到路由器上吧？怎么办？        &amp;mdash;数据链路层&lt;/p&gt;
&lt;p&gt;2.网上这么多主机，怎么定位并找到目标主机呢？                           &amp;mdash;网络层&lt;/p&gt;
&lt;p&gt;3.如果我的数据发出去，丢失了怎么办？                                           &amp;mdash;传输层&lt;/p&gt;
&lt;p&gt;4.发数据不是目的，只是手段，用数据才是目的吧？&lt;/p&gt;
&lt;p&gt;目标主机怎么知道我发出去的数据该怎么处理，被使用呢？            &amp;mdash;应用层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;33tcpip协议与操作系统的关系&#34;&gt;3.3TCP/IP协议与操作系统的关系(宏观上，怎么实现的)
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122133309732.png&#34;
	width=&#34;2099&#34;
	height=&#34;740&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122133309732&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;283&#34;
		data-flex-basis=&#34;680px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;为什么安装了不同操作系统的不同的主机之间可以进行通信？&lt;/p&gt;
&lt;p&gt;因为OSI7层协议是标准，不同的主机上操作系统可以不同，但是所有主机上的协议栈必须按照标准进行相同的实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传输层最著名的协议就是TCP；网络层最著名的协议就是IP；&lt;/p&gt;
&lt;p&gt;传输层和网络层必须在内核实现，无论OS再怎么不同，这部分都必须遵守协议，必须是一样的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122134845255.png&#34;
	width=&#34;1882&#34;
	height=&#34;766&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122134845255&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;245&#34;
		data-flex-basis=&#34;589px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;34所以究竟什么是协议&#34;&gt;3.4所以究竟什么是协议?
&lt;/h2&gt;&lt;p&gt;协议的本质，就是约定好的结构体&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结构体是协议约定的 计算机的表达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251122135845994.png&#34;
	width=&#34;1939&#34;
	height=&#34;855&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251122135845994&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;226&#34;
		data-flex-basis=&#34;544px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：主机 B 能识别 data，并且准确提取 a=10，b=20，c=30 吗？&lt;/p&gt;
&lt;p&gt;回答：答案是肯定的！因为双方都有同样的结构体类型 struct protocol。也就是说，用同样的代码实现协议，用同样的自定义数据类型，天然就具有&amp;quot;共识“，能够识别对方发来的数据，这不就是约定吗?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于协议的朴素理解：&lt;strong&gt;所谓协议，就是通信双方都认识的结构化的数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为协议栈是分层的，所以，每层都有双方都有协议，同层之间，互相可以认识对方的协议。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例子：网络购物的快递单上，有寄方、收方、数量、备注、支付方式、运费&amp;hellip;等，使得收货方能看懂，发货方也能看懂，双方一看就能确定信息是否正确，所以，快递单子就是收发双方的协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;4-网络传输基本流程&#34;&gt;4. 网络传输基本流程
&lt;/h1&gt;&lt;h2 id=&#34;41局域网网络传输流程图&#34;&gt;4.1局域网网络传输流程图
&lt;/h2&gt;&lt;p&gt;网络的发展是从局部到整体的&lt;/p&gt;
&lt;p&gt;有各种各样的局域网通信的标准：以太网、令牌环网、无线LAN&amp;hellip;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;令牌环网：只有持有令牌的人才能在局域网中发送消息。令牌其实就是锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;411局域网通信原理&#34;&gt;4.1.1局域网通信原理
&lt;/h3&gt;&lt;p&gt;以以太网为例&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;在同一个局域网内的多台主机之间，能直接通信&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2）在同一个局域网内发送的消息&lt;strong&gt;所有主机都能看到&lt;/strong&gt;，但是&lt;strong&gt;只有目标主机会对消息进行处理&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个局域网内的主机都能直接通信，主机A给主机B发送消息时，其实主机C、主机D、主机E等都收到消息了，但是它们知道不是给自己发的消息，所以会忽略，而只有主机B会处理该消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3）每台主机在局域网上，都要有唯一的标识来&lt;strong&gt;保证主机的唯一性：mac地址&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;412mac地址&#34;&gt;4.1.2MAC地址
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;每台主机在局域网上的唯一标识是mac地址。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mac地址是在网卡中内置的，mac地址通常是唯一的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机中的mac地址不是真实的mac地址，可能会冲突，也有些网卡支持用户配置 mac 地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mac地址长度为48比特位，即6字节，一般用16 进制数字加上冒号的形式来表示(例如：`08:00:27:03:fb:19`)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mac地址用来识别数据链路层中相连的节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;查看mac地址&lt;/p&gt;
&lt;p&gt;Linux下查看mac地址：&lt;code&gt;ifconfig&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Windows下查看mac地址：&lt;code&gt;ipconfig/all&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;413数据链路层直接通信&#34;&gt;4.1.3数据链路层直接通信
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125162540452.png&#34;
	width=&#34;1576&#34;
	height=&#34;571&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125162540452&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;276&#34;
		data-flex-basis=&#34;662px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果现在主机A要给主机B发送消息，那么主机A会先把自己要发送的报文添加好（一般会添加：源mac地址、目标mac地址和消息主体），然后主机A将报文发送到局域网，此时局域网中的所有主机都能接收到，但是除B以外的所有主机接收到后发现报文的目标mac地址不是自己后，就会丢弃，而主机B检查后发现自己的mac地址和报文的目标mac地址相同，所以主机B会对报文做处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1）&lt;strong&gt;在以太网中，任何时刻，只允许一台机器向网络中发送数据&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如主机A在给主机B发送消息的同时，主机B也在给主机D发送消息，那么两个信息就可能会在物理层面上发生干扰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）如果有多台同时发送，会发生数据干扰，我们称之为&lt;strong&gt;数据碰撞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3）所有发送数据的主机要进行&lt;strong&gt;碰撞检测&lt;/strong&gt;和&lt;strong&gt;碰撞避免&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;碰撞避免算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4）没有交换机的情况下，&lt;strong&gt;一个以太网就是一个碰撞域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5）局域网通信的过程中，主机对收到的报文确认是否是发给自己的，是通过目标mac 地址判定&lt;/p&gt;
&lt;p&gt;以太网的本质就是共享的资源，任何时刻只允许一台主机向网络中发送消息。—临界资源&lt;/p&gt;
&lt;p&gt;碰撞检测、碰撞避免、碰撞避免算法等本质上就是在一定程度上维持以太网的互斥属性&lt;/p&gt;
&lt;h3 id=&#34;414主机之间通信的本质&#34;&gt;4.1.4主机之间通信的本质
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;主机之间通信，本质是两个协议栈在通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大部分情况下，通信都是由用户(人)来发起的。我们的消息必须&lt;strong&gt;自顶向下贯穿协议栈&lt;/strong&gt;，把我们的数据交给网卡，数据到达目标主机后，一定是目标主机的网卡硬件先收到报文，然后&lt;strong&gt;自底向上进行交付&lt;/strong&gt;，到达应用层，&lt;strong&gt;同层之间直接通信&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125170035351.png&#34;
	width=&#34;1376&#34;
	height=&#34;430&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125170035351&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;320&#34;
		data-flex-basis=&#34;768px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据发送的原始动力：90%的情况下都是人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络协议栈：每一层都会有自己的协议，同层之间是相互认识的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协议就是结构体，我们约定结构体里的属性、字段都一样&lt;/p&gt;
&lt;h3 id=&#34;416数据包封装和分用&#34;&gt;4.1.6数据包封装和分用
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125180208747.png&#34;
	width=&#34;1662&#34;
	height=&#34;588&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125180208747&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;282&#34;
		data-flex-basis=&#34;678px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;为什么要自顶向下封装&#34;&gt;&lt;strong&gt;为什么要自顶向下封装？&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么要自顶向下？&lt;/p&gt;
&lt;p&gt;因为想发送数据的是用户，用户在上层，但是真正发送数据的是网卡，所以必须贯穿操作系统，贯穿协议栈。操作系统是硬件(网卡)的管理者&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类比printf把消息打印到显示器上。printf底层封装了系统调用，因为操作系统是显示器的管理者，所以我们的消息可以通过操作系统系统调用然后调用驱动，再把消息写到硬件上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要封装？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同层之间，在直接通信&lt;/strong&gt;（因为我发送的，就是你收到的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对端同层，要先解包。解包的本质就是把自己同层的报头和有效载荷进行分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细节1&lt;/strong&gt;：不考虑应用层协议，任何协议&lt;/p&gt;
&lt;p&gt;a. 报头必须要能做到，和有效载荷进行分离的能力&lt;/p&gt;
&lt;p&gt;b. 报头中必须包含，如何将自己的有效载荷，交付给上层的那一个具体的协议。&lt;/p&gt;
&lt;p&gt;我们把交付有效载荷的过程叫做分用的过程。&lt;/p&gt;
&lt;p&gt;报文发送到目标主机，要自底向上做解包和分用的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细节2&lt;/strong&gt;：底层收到报文，但是该报文不是发送给我的，数据链路层直接丢弃&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细节3&lt;/strong&gt;：协议栈的理解&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125183212386.png&#34;
	width=&#34;1545&#34;
	height=&#34;698&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125183212386&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;221&#34;
		data-flex-basis=&#34;531px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们在自顶向下进行封装的过程，其实就是把我们的原始报文和报头在不断入栈；当我们把对应的报文交付给对方之后，对方要做报头和有效载荷的分离，依次把有效载荷交付给上一层，这个不断解包和分用的过程，就是出栈的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于一个报文，我们自顶向下封装，其实是从上往下做入栈，自底向上做出栈。所以我们把TCP/IP叫做协议栈&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;了解：&lt;/p&gt;
&lt;p&gt;一般默认我们的网卡和驱动程序只会把发送给我这个主机的报文向上交付，但是网卡有一种混杂模式，当我们的网卡收到对应的数据帧，不对数据的来源、数据的目标做判断，无脑地直接将数据向上交付，不管是不是发给我的。我们把这种叫做网卡的混杂模式。&lt;/p&gt;
&lt;p&gt;抓包工具的原理就是把网卡设置成混杂模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;数据包封装术语&#34;&gt;&lt;strong&gt;数据包封装术语&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;1）&lt;strong&gt;明确几个概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;报文=报头+有效载荷&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;报头部分，就是对应协议层的结构体字段，我们一般叫做报头。&lt;/p&gt;
&lt;p&gt;任何一层，只认识自己的报头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了报头，剩下的叫做有效载荷。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）&lt;strong&gt;明确不同层的完整报文的叫法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125185429881.png&#34;
	width=&#34;1573&#34;
	height=&#34;496&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125185429881&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;317&#34;
		data-flex-basis=&#34;761px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们往往&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把应用层报头叫做&lt;strong&gt;请求与应答&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把添加了传输报头的整个报文，叫做&lt;strong&gt;数据段&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把添加了网络报头的整个报文，叫做&lt;strong&gt;数据报&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把添加了链路报头的整个报文，叫做&lt;strong&gt;数据帧&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不同的协议层对数据包有不同的称谓,在传输层叫做段(segment)，在网络层叫做数据报 (datagram),在链路层叫做帧(frame)。&lt;/p&gt;
&lt;p&gt;应用层数据通过协议栈发到网络上时,每层协议都要加上一个数据首部(header)，称为&lt;strong&gt;封装&lt;/strong&gt;(Encapsulation)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首部信息&lt;/strong&gt;中包含了一些类似于首部有多长,载荷(payload)有多长，上层协议是什么等信息。&lt;/p&gt;
&lt;p&gt;数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，根据首部中的&amp;quot;上层协议字段&amp;quot;将数据交给对应的上层协议处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;1）&lt;strong&gt;每一层协议，未来都会有自己具体的协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125190948212.png&#34;
	width=&#34;549&#34;
	height=&#34;283&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125190948212&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;193&#34;
		data-flex-basis=&#34;465px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;两台计算机通过TCP/IP协议通讯的过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125191340584.png&#34;
	width=&#34;834&#34;
	height=&#34;508&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125191340584&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;394px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在网络传输的过程中，数据不是直接发送给对方主机的，而是先要自顶向下将数据交付给下层协议（封装），封装成一个完整的链路层的帧，然后再在以太网中，以碰撞检测、碰撞避免的方法，把报文交给目标主机，对方主机再自底向上进行向上交付。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3）&lt;strong&gt;数据的封装过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125192638878.png&#34;
	width=&#34;782&#34;
	height=&#34;551&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125192638878&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;数据的分用过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251125192702881.png&#34;
	width=&#34;790&#34;
	height=&#34;484&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251125192702881&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;163&#34;
		data-flex-basis=&#34;391px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;5）&lt;strong&gt;未来学习任何协议，都要先宏观上建立这样的认识:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.要学习的协议，**是如何做到解包的？**只有明确了解包，封包也就能理解&lt;/p&gt;
&lt;p&gt;2.要学习的协议，&lt;strong&gt;是如何做到将自己的有效载荷，交付给上层协议的?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;42跨网络传输流程图&#34;&gt;4.2跨网络传输流程图
&lt;/h2&gt;&lt;h3 id=&#34;421网络中的地址管理-认识ip地址&#34;&gt;4.2.1网络中的地址管理-认识IP地址
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;IP地址是用来标识全球范围内主机的唯一性（公网IP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而Mac地址本质是一种只在局域网当中有效的标识地址的方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251127190307363.png&#34;
	width=&#34;973&#34;
	height=&#34;362&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251127190307363&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;268&#34;
		data-flex-basis=&#34;645px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;源IP地址，目标IP地址&lt;/strong&gt;  &amp;mdash;目标IP地址表示最终目的地是哪里（长远目标）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标IP的核心价值是给我们提供路由的参考依据&lt;/p&gt;
&lt;p&gt;目标IP在将来整个转发的过程中，永远不变&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.&lt;strong&gt;源Mac地址，目标Mac地址&lt;/strong&gt; &amp;mdash;目标Mac地址表示下一站要去哪里（当下目标）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP协议有两个版本：IPv4和IPv6&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPv4通常是4个字节，32个比特位&lt;/li&gt;
&lt;li&gt;IPv6通常是16个字节，128个比特位&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我们通常也使用&amp;quot;点分十进制&amp;quot;的字符串表示IP地址（例如192.168.0.1），用点分割的每一个数字表示一个字节（即能表示的范围是0－255）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux系统中查看IP地址：&lt;code&gt;ifconfig&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251127184001781.png&#34;
	width=&#34;1172&#34;
	height=&#34;353&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251127184001781&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;332&#34;
		data-flex-basis=&#34;796px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Windows系统中查看IP地址：&lt;code&gt;ipconfig&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;跨网段的主机的数据传输。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;路由器主要是用来连接两个不同子网的。&lt;/p&gt;
&lt;p&gt;可以这样理解：路由器将来要配置两张网卡，左边一张网卡，右边一张网卡，分别用来连接两个不同的子网&lt;/p&gt;
&lt;p&gt;电脑，路由器 &amp;mdash; 统一叫做主机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两台主机之间进行通信，本质是两个协议栈之间进行通信&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251127191449468.png&#34;
	width=&#34;984&#34;
	height=&#34;457&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251127191449468&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;516px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;只要有网络层，就会有路由功能&lt;/p&gt;
&lt;p&gt;有了目的IP，就可以判定要将报文发送给路由器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251128075006826.png&#34;
	width=&#34;1210&#34;
	height=&#34;640&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251128075006826&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;453px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;同一个局域网内的主机可以直接通信&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251128075734224.png&#34;
	width=&#34;1524&#34;
	height=&#34;703&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251128075734224&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;216&#34;
		data-flex-basis=&#34;520px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;路由的过程中，IP地址不变，mac地址一直在变。&lt;/p&gt;
&lt;p&gt;mac地址只会在本局域网内有效&lt;/p&gt;
&lt;p&gt;以太网，无线LAN，令牌环网&amp;hellip;自定义局域网通信原理？&lt;/p&gt;
&lt;p&gt;网络层+IP的本质意义：给网络提供了一层虚拟化层，让世界上所有的网络，都叫做IP网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251128144456424.png&#34;
	width=&#34;1202&#34;
	height=&#34;462&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251128144456424&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;260&#34;
		data-flex-basis=&#34;624px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;IP 网络层存在的意义：&lt;strong&gt;提供网络虚拟层，让世界的所有网络都是IP 网络，屏蔽&lt;/strong&gt;
&lt;strong&gt;最底层网络的差异&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;5socket编程预备&#34;&gt;5.Socket编程预备
&lt;/h1&gt;&lt;h2 id=&#34;51理解源ip地址和目的ip地址&#34;&gt;5.1理解源IP地址和目的IP地址
&lt;/h2&gt;&lt;p&gt;IP地址主要用来标识网络中主机的唯一性&lt;/p&gt;
&lt;p&gt;进程是人在系统中的代表，只要把数据给进程，人就相当于拿到了数据&lt;/p&gt;
&lt;p&gt;数据传输到主机不是目的，而是手段。到达主机内部，再交给主机内的进程，才是目的&lt;/p&gt;
&lt;p&gt;上网，只有两种行为&lt;/p&gt;
&lt;p&gt;1.从远端服务器，获取数据&lt;/p&gt;
&lt;p&gt;2.本地数据，上传到远端服务器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程（内存）-&amp;gt;网卡-&amp;gt;网络&lt;/p&gt;
&lt;p&gt;​                       &amp;lt;-        &amp;lt;-&lt;/p&gt;
&lt;p&gt;IO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;网络通信的本质：其实就是两个不同主机的进程在进行数据交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络通信的本质：是进程间通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程间通信的前提是让不同的进程看到同一份资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么网络通信的前提就是让不同的进程看到同一个&lt;strong&gt;网络&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是系统中，可以同时存在非常多的进程，当数据到达目标主机后，应该如何转发给目标进程？需要在网络背景下，在系统中标识主机的唯一性&lt;/p&gt;
&lt;h2 id=&#34;52认识端口号&#34;&gt;5.2认识端口号
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;端口号(port)是传输层协议的内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端口号是一个2字节16位的整数&lt;/li&gt;
&lt;li&gt;端口号可以标识系统中唯一的一个网络进程。当端口号和进程相关联了，就是告诉操作系统，当前的这个数据要交给哪一个进程来处理&lt;/li&gt;
&lt;li&gt;IP地址+端口号能够表示网络上的某一台主机的某一个进程&lt;/li&gt;
&lt;li&gt;一个端口号只能被一个进程占用（但一个进程可以有多个端口号）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251201101318217.png&#34;
	width=&#34;1211&#34;
	height=&#34;456&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251201101318217&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;265&#34;
		data-flex-basis=&#34;637px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;端口号 vs pid&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不是所有的进程，都要进行网络通信&lt;/strong&gt;。每个进程都要有pid，但不一定所有进程都要有端口号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从技术角度，pid是可行的，但是，pid是一个系统的概念，如果pid变了，网络也要跟着变。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;网络不想和系统产生太大的耦合度&lt;/strong&gt;，所以单独设计出端口号来标识需要进行网络通信的进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一个进程可以绑定多个端口号，但是一个端口号不能被多个进程绑定&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;端口号的范围划分&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0~1023 ：知名端口号，HTTP，FTP，SSH等这些广为使用的应用层协议，他们的端口号都是固定的&lt;/p&gt;
&lt;p&gt;1024~65536：操作系统动态分配的端口号，客户端程序的端口号，就是由操作系统从这个范围分配的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解源端口号和目的端口号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传输层协议（TCP 和 UDP）的数据段中有两个端口号，分别叫源端口号和目的端口号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;源端口号：描述数据是谁发的&lt;/p&gt;
&lt;p&gt;目的端口号：描述数据要发给谁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解socket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络通信的本质不是两台主机通信，而是两台主机上的进程在通信&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP+Port = 全网内唯一的一个进程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP全网内唯一的一个主机&lt;/li&gt;
&lt;li&gt;port该主机内唯一的一个网络进程&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;{源ip，源port，目的ip，目的端口号}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;源ip+源port 可以标识全网内唯一的一个网络进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的ip+目的端口号 可以表示全网内另一个唯一的网络进程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;网络通信的本质是全网唯二的两个进程在进行进程间通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们用对方的IP和Port标识对方的唯一性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;socket = ip + port&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IP地址用来标识互联网中唯一的一台主机，port 用来标识该主机上唯一的一个网络进程。IP+Port就能表示互联网中唯一的一个进程。&lt;/p&gt;
&lt;p&gt;所以，通信的时候，本质是两个互联网进程代表人来进行通信，{srclp,srcPort，dstlp，dstPort这样的 4 元组就能标识互联网中唯二的两个进程。&lt;/p&gt;
&lt;p&gt;网络通信的本质，也是进程间通信。我们把 ip+port 叫做套接字 socket。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;53传输层的典型代表&#34;&gt;5.3传输层的典型代表
&lt;/h2&gt;&lt;p&gt;传输层和网络层是属于内核的，我们要通过网络协议栈进行通信，必定调用的是传输层提供的系统调用，来进行网络通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251201110249039.png&#34;
	width=&#34;1626&#34;
	height=&#34;722&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251201110249039&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;540px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初识TCP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP(Transmission Control Protocol）协议属于传输层协议的一种。（网络协议栈中每一层都会有一个或多个具体的协议）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;传输层协议&lt;/li&gt;
&lt;li&gt;有连接（也就是想用TCP协议，需要先建立连接）&lt;/li&gt;
&lt;li&gt;可靠传输（一系列保证可靠性的机制，比如丢了会重传、超时了会重传、传快了传慢、传慢了传快等）&lt;/li&gt;
&lt;li&gt;面向字节流（水龙头的水是连续的，要接水，水盆接还是小碗接，怎么接，什么时候接，都由自己决定）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;初识UDP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UDP(User Datagram Protocol 用户数据报协议)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;传输层协议&lt;/li&gt;
&lt;li&gt;无连接&lt;/li&gt;
&lt;li&gt;不可靠传输（丢了就不管）&lt;/li&gt;
&lt;li&gt;面向数据报（发快递/信，发10个，收10个，不可能收11个）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;TCP（可靠）vs UDP（不可靠）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP要保证可靠性，意味着它要做更多工作，也就更复杂，占有的资源也更多&lt;/li&gt;
&lt;li&gt;UDP不可靠，意味着UPD相比TCP来说更简单&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;54网络字节序&#34;&gt;5.4网络字节序
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分，网络数据流同样有大端小端之分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251201114635448.png&#34;
	width=&#34;289&#34;
	height=&#34;439&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251201114635448&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;65&#34;
		data-flex-basis=&#34;157px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;strong&gt;如何定义网络数据流的地址呢?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收主机把从网络上接到的字节依次保存在接收缓冲区中,也是按内存地址从低到高的顺序保存;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此,网络数据流的地址应这样规定：&lt;span style=&#34;color: #FF0000;&#34;&gt;先发出的数据是低地址,后发出的数据是高地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251205115759540.png&#34;
	width=&#34;597&#34;
	height=&#34;216&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251205115759540&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;276&#34;
		data-flex-basis=&#34;663px&#34;
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在网络中，如果两台主机的存储序列不同，经过网络通信，会让对方把数据解释错了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不管这台主机是大端机还是小端机,都会按照这个TCP/IP 规定的网络字节序来发送/接收数据。如果当前发送主机是小端，就需要先将数据转成大端；否则就忽略，直接发送即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/network/index.assets/image-20251201120713114.png&#34;
	width=&#34;618&#34;
	height=&#34;129&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251201120713114&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;479&#34;
		data-flex-basis=&#34;1149px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这些函数名很好记,h 表示 host,n 表示 network,I 表示 32 位长整数,s 表示 16 位短整数。例如：htonl 表示将 32 位的长整数从主机字节序转换为网络字节序，例如将 IP 地址转换后准备发送。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果主机是小端字节序,这些函数将参数做相应的大小端转换然后返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果主机是大端字节序,这些函数不做转换,将参数原封不动地返回。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;55socket编程接口&#34;&gt;5.5socket编程接口
&lt;/h2&gt;&lt;p&gt;socket 常见API
sockaddr结构
in_addr结构&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
