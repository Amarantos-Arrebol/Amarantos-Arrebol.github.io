<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="理解进程、环境变量与地址空间">
<title>【Linux系统编程】03进程的概念</title>

<link rel='canonical' href='https://Amarantos-Arrebol.github.io/p/linux-process-basic/'>

<link rel="stylesheet" href="/scss/style.min.f62fad6b64852a4093ae5ceb06b3f1a3f8409c5b5dd5c91806fbb732800ca9f9.css"><meta property='og:title' content="【Linux系统编程】03进程的概念">
<meta property='og:description' content="理解进程、环境变量与地址空间">
<meta property='og:url' content='https://Amarantos-Arrebol.github.io/p/linux-process-basic/'>
<meta property='og:site_name' content='PursUnre的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Linux进阶' /><meta property='article:tag' content='进程管理' /><meta property='article:tag' content='环境变量' /><meta property='article:tag' content='地址空间' /><meta property='article:published_time' content='2025-11-02T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-11-24T13:34:57&#43;00:00'/><meta property='og:image' content='https://Amarantos-Arrebol.github.io/p/linux-process-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3.png' />
<meta name="twitter:title" content="【Linux系统编程】03进程的概念">
<meta name="twitter:description" content="理解进程、环境变量与地址空间"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://Amarantos-Arrebol.github.io/p/linux-process-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3.png' /><link rel="stylesheet" href="/css/custom.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>


<script>
$(document).ready(function() {
    
    $.getScript("https://cdn.jsdelivr.net/gh/huangwb8/bloghelper@latest/mouse/halo-dream/fairyDustCursor.min.js");
});
</script>


<style type="text/css">
.main-content img, body {
    cursor: url(https://cdn.jsdelivr.net/gh/huangwb8/bloghelper@latest/mouse/halo-dream/cursor/breeze/Arrow.cur), auto;
}

.actions > div,
.expand-done,
.main-content figure > figcaption div,
.navbar-above .navbar-nav .item,
.navbar-searchicon,
.navbar-slideicon,
.photos .picture-details,
.widget .ad-tag .click-close,
a,
button {
    cursor: url(https://cdn.jsdelivr.net/gh/huangwb8/bloghelper@latest/mouse/halo-dream/cursor/breeze/Hand.cur), auto;
}

blockquote,
code,
h1, h2, h3, h4, h5, h6,
hr,
input[type=text],
li,
p,
td,
textarea,
th {
    cursor: url(https://cdn.jsdelivr.net/gh/huangwb8/bloghelper@latest/mouse/halo-dream/cursor/breeze/IBeam.cur), auto;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    
    const articleContent = document.querySelector('.article-content');
    if (!articleContent) return;
    
    
    function processTextNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            
            const regex = /==([^=\n`]+?)==/g;
            
            if (regex.test(text)) {
                const parent = node.parentNode;
                
                if (parent && !['CODE', 'PRE', 'KBD', 'SAMP'].includes(parent.tagName)) {
                    const fragment = document.createDocumentFragment();
                    let lastIndex = 0;
                    
                    text.replace(/==([^=\n`]+?)==/g, function(match, content, offset) {
                        
                        if (offset > lastIndex) {
                            fragment.appendChild(document.createTextNode(text.slice(lastIndex, offset)));
                        }
                        
                        
                        const mark = document.createElement('mark');
                        mark.textContent = content;
                        fragment.appendChild(mark);
                        
                        lastIndex = offset + match.length;
                        return match;
                    });
                    
                    
                    if (lastIndex < text.length) {
                        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }
                    
                    parent.replaceChild(fragment, node);
                }
            }
        } else if (node.nodeType === Node.ELEMENT_NODE && 
                   !['CODE', 'PRE', 'SCRIPT', 'STYLE', 'KBD', 'SAMP'].includes(node.tagName)) {
            
            Array.from(node.childNodes).forEach(processTextNode);
        }
    }
    
    processTextNode(articleContent);
});
</script>

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside
  class="sidebar left-sidebar sticky "
>
  <button
    class="hamburger hamburger--spin"
    type="button"
    id="toggle-menu"
    aria-label="切换菜单"
  >
    <span class="hamburger-box">
      <span class="hamburger-inner"></span>
    </span>
  </button>

  <header>
     
    <figure class="site-avatar">
      <a href="/">
           
        <img
          src="/img/avatar_hu_c3bef4dff24cf0d9.png"
          width="300"
          height="300"
          class="site-logo"
          loading="lazy"
          alt="Avatar"
        />
         
      </a>
      
      <span class="emoji">🌿</span>
      
    </figure>
     

    <div class="site-meta">
      <h1 class="site-name">
        <a href="/">PursUnre的博客</a>
      </h1>
      <h2 class="site-description">欢迎来到我的网站，此博客由【Hugo&#43;Stack】来进行搭建，主要分享个人学习笔记</h2>
    </div>
  </header><ol class="menu-social">
    
    <li>
      <a
        href="https://blog.csdn.net/green_tangerine?spm=1000.2115.3001.5343"
        target="_blank"
        
        title="CSDN"
        
        rel="me"
      >
          <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1762020245107" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4643" width="32" height="32" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M568.917333 626.005333l16.213334 2.474667c5.674667-0.64 10.965333-1.109333 15.914666-1.578667 9.941333-0.938667 18.688-1.792 27.221334-3.498666 38.4-7.68 67.968-27.434667 83.2-64.768 10.325333-25.002667 11.690667-51.242667 8.533333-77.653334-4.864-41.088-23.68-72.96-64.085333-88.106666-39.125333-14.634667-78.336-9.301333-117.077334 2.56-6.186667 1.92-9.685333 6.954667-10.24 13.653333-1.152 13.141333-2.304 26.24-3.541333 39.338667-4.821333 51.328-9.557333 102.656-14.208 153.984-0.896 9.642667 2.304 14.506667 12.202667 16.213333 15.744 2.816 31.445333 5.205333 45.866666 7.381333z m21.589334-33.450666c-2.602667 0.170667-5.12 0.341333-7.381334 0.554666l-10.624-0.725333a2204.416 2204.416 0 0 0-15.36-0.981333c-5.76-0.256-8.149333-2.816-7.509333-8.96 1.536-15.36 2.901333-30.634667 4.266667-45.994667l2.048-22.912 2.858666-30.848 4.693334-51.114667v-0.170666c0.426667-4.565333 0.768-8.533333 6.4-9.770667 20.053333-4.352 40.234667-6.698667 60.458666-1.962667 28.032 6.570667 43.093333 25.813333 49.194667 52.906667 5.546667 24.618667 5.205333 49.152-4.565333 72.746667-11.776 28.416-36.096 40.021333-64.426667 45.141333-6.826667 1.28-13.781333 1.706667-20.053333 2.133333zM308.437333 606.208c23.765333 16.341333 50.986667 20.778667 79.189334 20.992 17.152 0.170667 34.005333-1.706667 49.92-8.448 25.216-10.666667 38.101333-30.421333 41.429333-56.917333 3.328-26.496-6.144-47.744-29.098667-61.568a242.346667 242.346667 0 0 0-38.4-18.218667c-8.405333-3.242667-16.981333-5.930667-25.514666-8.618667a367.957333 367.957333 0 0 1-29.781334-10.325333c-17.28-7.253333-18.517333-19.498667-5.034666-32.725333 17.237333-16.896 49.621333-18.176 69.888-2.133334 5.845333 4.608 10.837333 10.368 15.744 16.085334l1.365333 1.578666c6.144 7.125333 12.757333 8.021333 19.925333 1.962667 11.776-9.813333 11.690667-25.6-0.426666-36.693333-22.570667-20.650667-49.408-29.696-79.573334-26.197334-27.904 3.242667-51.626667 15.189333-66.986666 39.936-13.994667 22.613333-9.088 48.554667 13.397333 62.634667 10.24 6.442667 21.973333 10.666667 33.536 14.933333 2.133333 0.725333 4.181333 1.493333 6.229333 2.261334 8.234667 3.029333 16.512 5.802667 24.874667 8.533333 10.368 3.413333 20.736 6.869333 30.890667 10.837333 12.458667 4.906667 19.498667 14.677333 19.029333 28.885334-0.597333 16.512-7.637333 28.586667-23.808 33.792-27.946667 9.130667-83.2 6.4-102.058667-30.421334-3.84-7.296-10.368-8.021333-17.792-3.925333-13.44 7.466667-17.28 23.04-7.466666 34.986667 5.930667 7.168 12.8 13.482667 20.48 18.773333zM805.674667 410.538667c3.882667-1.962667 7.850667-4.181333 11.861333-6.485334 9.130667-5.12 18.730667-10.581333 29.013333-13.653333 30.592-9.130667 61.269333-7.509333 88.490667 11.136 21.162667 14.506667 30.293333 36.096 28.458667 61.354667-2.346667 32.085333-5.205333 64.170667-8.021334 96.256-1.408 15.786667-2.816 31.530667-4.138666 47.274666-1.408 16.725333-18.56 26.453333-33.066667 18.090667-2.688-1.536-4.778667-6.826667-4.565333-10.24 1.365333-21.12 3.157333-42.197333 4.992-63.232l0.768-9.002667 2.261333-25.216c1.749333-19.2 3.498667-38.4 4.693333-57.6 0.896-13.141333-4.693333-23.893333-16.298666-31.232-30.848-19.498667-71.68-9.728-94.208 22.485334-15.616 22.442667-21.205333 47.616-23.04 74.410666-1.365333 20.352-3.328 40.661333-5.333334 60.928l-2.944 30.890667c-0.512 5.973333-3.669333 9.002667-9.386666 9.386667a89.386667 89.386667 0 0 1-12.373334 0c-10.496-0.810667-14.890667-6.656-13.994666-17.066667 2.304-26.197333 4.48-52.48 6.656-78.677333l2.773333-32.853334 2.005333-24.234666c1.493333-18.474667 2.986667-36.906667 4.693334-55.338667 1.365333-15.018667 19.328-25.856 32.64-19.072 2.986667 1.536 4.778667 5.248 6.314666 8.362667 0.597333 1.28 1.152 2.432 1.749334 3.328zM95.445333 603.008c22.698667 18.346667 49.493333 23.893333 77.952 24.064 27.946667-0.128 54.570667-5.12 78.549334-20.650667a22.357333 22.357333 0 0 0 10.965333-23.893333 22.186667 22.186667 0 0 0-13.184-17.706667c-6.698667-2.901333-11.434667 1.194667-16.341333 5.546667l-0.298667 0.213333a72.149333 72.149333 0 0 1-17.706667 11.776c-22.613333 10.112-46.336 11.008-70.186666 5.504-23.466667-5.461333-38.954667-20.138667-44.032-43.904-7.893333-36.949333-0.981333-71.253333 23.168-100.565333 17.834667-21.76 41.813333-31.018667 69.205333-21.76 9.173333 3.072 17.322667 9.386667 25.344 15.616 2.261333 1.749333 4.522667 3.498667 6.741333 5.12 7.210667 5.376 13.525333 5.546667 19.2-1.450667a23.338667 23.338667 0 0 0-1.962666-32.682666 87.381333 87.381333 0 0 0-58.410667-23.552c-48.128-1.194667-82.901333 21.888-106.24 62.677333-16.341333 28.458667-21.376 59.477333-16.938667 92.032 3.456 25.472 13.909333 47.232 34.133334 63.573333z" fill="#707070" p-id="4644"></path></svg> 
      </a>
    </li>
    
    <li>
      <a
        href="https://gitee.com/green-citrus"
        target="_blank"
        
        title="Gitee"
        
        rel="me"
      >
          <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1762076613092" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2602" width="32" height="32" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M690.194 479.706H496.998v0.004c-9.275 0-16.798 7.518-16.8 16.795l-0.016 42h-0.004c-0.002 9.277 7.518 16.799 16.796 16.803h0.004l117.618-0.004c9.277 0 16.8 7.522 16.8 16.8v8.4c0 27.832-22.564 50.398-50.399 50.398h-159.61c-9.277 0-16.797-7.522-16.797-16.8l-0.004-159.597h-0.002c0-27.834 22.562-50.398 50.397-50.4h0.002l235.164 0.002v-0.011c9.275 0 16.794-7.516 16.8-16.789l0.037-41.999h0.011c0.006-9.277-7.512-16.804-16.79-16.81h-0.01l-235.195 0.01c-69.586 0-125.998 56.412-125.998 125.997L329 689.701c0 9.277 7.522 16.8 16.8 16.8h247.796c62.628 0 113.398-50.768 113.398-113.397v-96.599c0-9.277-7.522-16.799-16.8-16.799z" p-id="2603" fill="#515151"></path></svg> 
      </a>
    </li>
    
    <li>
      <a
        href="https://github.com/Amarantos-Arrebol"
        target="_blank"
        
        title="GitHub"
        
        rel="me"
      >
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>


 
      </a>
    </li>
    
  </ol><ol class="menu" id="main-menu">
      
    <li >
      <a
        href="/"
        
      >
           <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>


 
        <span>主页</span>
      </a>
    </li>
     
    <li >
      <a
        href="/archives/"
        
      >
           <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>


 
        <span>归档</span>
      </a>
    </li>
     
    <li >
      <a
        href="/search/"
        
      >
           <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>


 
        <span>搜索</span>
      </a>
    </li>
     
    <li >
      <a
        href="/%E6%8A%80%E6%9C%AF%E9%93%BE%E6%8E%A5/"
        
      >
           <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>


 
        <span>技术链接</span>
      </a>
    </li>
    
    <li class="menu-bottom-section">
      <ol class="menu"> 
        <li id="dark-mode-toggle">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>


 <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



          <span>暗色模式</span>
        </li>
        
      </ol>
    </li>
  </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#一进程">一、进程</a>
      <ul>
        <li><a href="#11进程概念">1.1进程概念</a>
          <ul>
            <li><a href="#111冯诺依曼体系结构">1.1.1冯诺依曼体系结构</a></li>
            <li><a href="#112软件运行必须先加载到内存">1.1.2软件运行，必须先加载到内存</a></li>
            <li><a href="#113-理解数据流动">1.1.3 理解数据流动</a></li>
            <li><a href="#114-操作系统">1.1.4 操作系统</a>
              <ul>
                <li><a href="#操作系统基本介绍">操作系统基本介绍</a></li>
                <li><a href="#设计os的目的"><strong>设计OS的目的</strong></a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#12-进程">1.2 进程</a>
          <ul>
            <li><a href="#121-概念">1.2.1 概念</a></li>
            <li><a href="#622-task_"><strong>6.2.2 task_struct</strong></a></li>
            <li><a href="#623-查看进程">6.2.3 查看进程</a>
              <ul>
                <li><a href="#getpid查看进程id">getpid()查看进程id</a></li>
                <li><a href="#通过文件去查看进程">通过文件去查看进程</a></li>
                <li><a href="#getppid查看父进程">getppid()查看父进程</a></li>
                <li><a href="#fork函数创建子进程">fork函数创建子进程</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#13进程的状态"><strong>1.3</strong>进程的状态</a>
          <ul>
            <li><a href="#631进程状态基本介绍">6.3.1进程状态基本介绍</a>
              <ul>
                <li><a href="#运行阻塞挂起">运行&amp;&amp;阻塞&amp;&amp;挂起</a></li>
                <li><a href="#理解内核链表">理解内核链表</a></li>
                <li><a href="#进程状态查看的命令">进程状态查看的命令</a></li>
                <li><a href="#linux的进程状态">Linux的进程状态</a></li>
                <li><a href="#总结">总结</a></li>
              </ul>
            </li>
            <li><a href="#632僵尸进程">6.3.2僵尸进程</a></li>
            <li><a href="#633孤儿进程">6.3.3孤儿进程</a></li>
          </ul>
        </li>
        <li><a href="#14进程的优先级">1.4进程的优先级</a>
          <ul>
            <li><a href="#641基本概念">6.4.1基本概念</a></li>
            <li><a href="#642查看系统进程">6.4.2查看系统进程</a></li>
            <li><a href="#643pri和ni">6.4.3PRI和NI</a></li>
            <li><a href="#644补充-进程四个特征">6.4.4补充: 进程四个特征</a></li>
          </ul>
        </li>
        <li><a href="#15进程切换">1.5进程切换</a>
          <ul>
            <li><a href="#651死循环进程如何运行">6.5.1死循环进程如何运行</a></li>
            <li><a href="#652cpu寄存器">6.5.2CPU，寄存器</a></li>
            <li><a href="#653进程是如何切换的">6.5.3进程是如何切换的？</a></li>
          </ul>
        </li>
        <li><a href="#16linux26内核进程o调度队列">1.6Linux2.6内核进程O调度队列</a>
          <ul>
            <li><a href="#活动队列">活动队列</a></li>
            <li><a href="#过期队列">过期队列</a></li>
            <li><a href="#总结-1">总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#二环境变量">二、环境变量</a>
      <ul>
        <li><a href="#1-引出环境变量">1. 引出环境变量</a>
          <ul>
            <li><a href="#11命令行参数">1.1命令行参数</a></li>
            <li><a href="#12环境变量与命令查找">1.2环境变量与命令查找</a></li>
          </ul>
        </li>
        <li><a href="#2查看新增环境变量">2.查看、新增环境变量</a>
          <ul>
            <li><a href="#21显示系统中所有环境变量">2.1显示系统中所有环境变量</a></li>
            <li><a href="#22查看某一个环境变量的内容">2.2查看某一个环境变量的内容</a></li>
            <li><a href="#23path环境变量">2.3PATH环境变量</a></li>
            <li><a href="#24设置一个新的环境变量">2.4设置一个新的环境变量</a></li>
          </ul>
        </li>
        <li><a href="#2环境变量的理解">2.环境变量的理解</a>
          <ul>
            <li><a href="#21如何理解环境变量">2.1如何理解环境变量</a></li>
            <li><a href="#22环境变量从哪来">2.2环境变量从哪来？</a></li>
          </ul>
        </li>
        <li><a href="#3常见环境变量">3.常见环境变量</a></li>
        <li><a href="#4获取环境变量">4.获取环境变量</a>
          <ul>
            <li>
              <ul>
                <li><a href="#方法1main函数参数">方法1：main函数参数</a></li>
                <li><a href="#方法2getenv">方法2：getenv</a></li>
                <li><a href="#方法3environ">方法3：environ</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#5本地变量与环境变量">5.本地变量与环境变量</a></li>
        <li><a href="#6-进程地址空间初识">6. 进程地址空间初识</a></li>
      </ul>
    </li>
    <li><a href="#三进程地址空间">三、进程地址空间</a>
      <ul>
        <li><a href="#1引入新概念">1.引入新概念</a>
          <ul>
            <li><a href="#11-一个进程一个虚拟地址空间">1.1 一个进程，一个虚拟地址空间</a></li>
            <li><a href="#12一个进程一套页表">1.2一个进程，一套页表</a></li>
            <li><a href="#13页表是用来做虚拟地址和物理地址映射的">1.3页表是用来做虚拟地址和物理地址映射的</a></li>
          </ul>
        </li>
        <li><a href="#2虚拟地址与进程地址空间">2.虚拟地址与进程地址空间</a>
          <ul>
            <li><a href="#21虚拟地址空间是什么">2.1虚拟地址空间是什么？</a></li>
            <li><a href="#22如何描述虚拟地址空间">2.2如何描述虚拟地址空间</a></li>
            <li><a href="#23为什么要有进程地址空间">2.3为什么要有进程地址空间</a></li>
            <li><a href="#总结-2">总结</a></li>
          </ul>
        </li>
        <li><a href="#3地址空间的组织方式">3.地址空间的组织方式</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </section>

            
        
        
        
        <div id="back-to-top">
            <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
                <path d="M512 298.666667l-298.666667 310.912L283.52 682.666667 512 445.312 740.48 682.666667 810.666667 609.578667z"></path>
            </svg>
        </div>
    </aside>



<script>
(function() {
    const backToTopButton = document.getElementById('back-to-top');
    if (!backToTopButton) return;
    
    
    window.addEventListener('scroll', function() {
        if (window.pageYOffset > 300) {
            backToTopButton.classList.add('show');
        } else {
            backToTopButton.classList.remove('show');
        }
    });
    
    
    backToTopButton.addEventListener('click', function() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });
})();
</script>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/linux-process-basic/">
                <img src="/p/linux-process-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_f8a80488315bd5f9.png"
                        srcset="/p/linux-process-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_f8a80488315bd5f9.png 800w, /p/linux-process-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_a76c8c5ca0be0093.png 1600w"
                        width="800" 
                        height="450" 
                        loading="lazy"
                        alt="Featured image of post 【Linux系统编程】03进程的概念" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" style="background-color: #77ACF1; color: #fff;">
                Linux系统编程
            </a>
        
            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="background-color: #B7A3E3; color: #fff;">
                学习笔记
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/linux-process-basic/">【Linux系统编程】03进程的概念</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            理解进程、环境变量与地址空间
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div class="article-time-item">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-11-02</time>
            </div><span class="article-time-divider">|</span>
            <div class="article-time-item">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-file-pencil"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14 3v4a1 1 0 0 0 1 1h4" /><path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" /><path d="M10 18l5 -5a1.414 1.414 0 0 0 -2 -2l-5 5v2h2z" /></svg>
                <time class="article-time--updated">2025-11-24</time>
            </div><span class="article-time-divider">|</span>
            <div class="article-time-item">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-file-word"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14 3v4a1 1 0 0 0 1 1h4" /><path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2" /><path d="M9 12l1.333 5l1.667 -4l1.667 4l1.333 -5" /></svg>
                <span class="article-time--wordcount">17028 字
                </span>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="一进程">一、进程
</h1><p>创建进程时，要有对应的task_struct来描述进程</p>
<p>而每一个task_struct最终都要对应一个虚拟地址空间</p>
<h2 id="11进程概念">1.1进程概念
</h2><h3 id="111冯诺依曼体系结构">1.1.1冯诺依曼体系结构
</h3><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250910092624351.png"
	width="888"
	height="432"
	
	loading="lazy"
	
		alt="image-20250910092624351"
	
	
		class="gallery-image" 
		data-flex-grow="205"
		data-flex-basis="493px"
	
></p>
<blockquote>
<p>输入设备：键盘，鼠标，话筒，摄像头&hellip;网卡，磁盘</p>
<p>输出设备：显示器，磁盘，网卡，打印机&hellip;</p>
</blockquote>
<p><strong>在冯诺依曼体系中，统一把输入输出设备称为外设</strong></p>
<ul>
<li>
<p>输入设备：将外设的数据读到内存里</p>
</li>
<li>
<p>输出设备：把内存的数据输出到外设中</p>
</li>
<li>
<p><mark>磁盘和网卡</mark> 既是输入设备也是输出设备：</p>
<p>读取文件就是把磁盘中的数据读到内存里；</p>
<p>写文件就是把内存里的数据写到磁盘上</p>
<p>Input/Output &mdash;&gt;IO</p>
</li>
<li>
<p>站在内存的角度，外设把数据交给我（内存）&mdash;&gt;Input</p>
<p>我(内存)把数据交给输出设备&mdash;&ndash;&gt;Output</p>
</li>
</ul>
<p><strong>CPU=运算器+控制器</strong></p>
<blockquote>
<p>算术运算（+-*/等），逻辑运算（真假）</p>
<p>控制器主要是控制CPU去取指令，分析指令，执行指令</p>
<p>我们把CPU也叫做中央处理器</p>
</blockquote>
<p><strong>存储器：内存</strong></p>
<blockquote>
<p>磁盘：外存</p>
</blockquote>
<h3 id="112软件运行必须先加载到内存">1.1.2软件运行，必须先加载到内存
</h3><ol>
<li>
<p><strong>软件运行，必须先加载到内存。程序运行之前，在哪里？</strong></p>
<p>磁盘。程序就是一个文件，是编译好的在磁盘特定路径下的二进制文件</p>
</li>
<li>
<p><strong>为什么程序运行的时候要<mark>先将程序加载到内存</mark>？</strong> &mdash;&ndash;&gt; 体系结构规定</p>
<p>CPU获取，写入，只能从内存中来进行</p>
</li>
<li>
<p><strong><mark>软件运行 实际上是CPU执行我们的代码，访问我们的数据</mark></strong></p>
<p>CPU无法直接从外设读取数据，所以必须先将数据加载到内存</p>
<p>这时，我们的程序才能被CPU访问到</p>
<blockquote>
<p>执行printf的时候是先从CPU处理完后，放到内存的缓冲区里，然后需要的时候再把数据刷新到外设</p>
</blockquote>
</li>
<li>
<p><strong>数据流动的本质——数据是从一个设备”拷贝“到另一个数据</strong></p>
<p>体系结构的效率：由设备的拷贝效率决定</p>
</li>
</ol>
<p><mark><strong>结论：在数据层面，CPU只和内存打交道，外设只和内存打交道</strong></mark></p>
<p><strong>存储分级：离CPU越近，效率越高，容量越小</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732629388338.png"
	width="1824"
	height="1034"
	
	loading="lazy"
	
		alt="73262938833"
	
	
		class="gallery-image" 
		data-flex-grow="176"
		data-flex-basis="423px"
	
></p>
<p><strong>为什么不按照下面的方式设计计算机呢？</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732627764668.png"
	width="922"
	height="333"
	
	loading="lazy"
	
		alt="73262776466"
	
	
		class="gallery-image" 
		data-flex-grow="276"
		data-flex-basis="664px"
	
></p>
<p>由于CPU处理数据非常快，外设的处理数据比较慢，如果采用这种结构</p>
<p>那么整个体系结构的效率就完全由外设的效率决定了</p>
<p>所以引入内存</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732628882412.png"
	width="843"
	height="438"
	
	loading="lazy"
	
		alt="73262888241"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="461px"
	
></p>
<p>内存和CPU，外设都能比较好地适配</p>
<blockquote>
<p>操作系统能提前将输入设备里的数据搬到内存里</p>
</blockquote>
<p>有了内存，使当代计算机，是性价比的产物</p>
<p>后来，芯片技术+摩尔定律</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732769208301.png"
	width="980"
	height="206"
	
	loading="lazy"
	
		alt="73276920830"
	
	
		class="gallery-image" 
		data-flex-grow="475"
		data-flex-basis="1141px"
	
></p>
<h3 id="113-理解数据流动">1.1.3 理解数据流动
</h3><p><strong>数据流动的本质就是在冯诺依曼体系结构中进行流动</strong></p>
<p>举例：</p>
<p><strong>1.QQ聊天</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732769677391.png"
	width="1591"
	height="459"
	
	loading="lazy"
	
		alt="73276967739"
	
	
		class="gallery-image" 
		data-flex-grow="346"
		data-flex-basis="831px"
	
></p>
<p>用户从键盘输入，首先要打开QQ这个软件，需要将QQ这个软件加载到内存，把键盘</p>
<p>数据搬到内存，你的消息需要经过运算器控制（加密、封包&hellip;），然后由CPU写回内存</p>
<p>再通过QQ将数据送到自己的体系结构的输出设备（网卡）</p>
<p>网卡将数据交到网络里，一定会交到朋友的那台机器，由朋友的输入设备（网卡）</p>
<p>来接收，朋友的QQ也一定得启动起来加载到内存，把数据从外设搬到内存，在QQ</p>
<p>内部执行所有的代码（将读到的数据交给CPU，比如做解密，然后再交给内存），由</p>
<p>存储器刷新到输出设备（显示器）</p>
<p><strong>2.发送文件</strong></p>
<p>文件是在磁盘上的，当我们将文件拖拽到QQ中，本质上是将磁盘文件拷贝到QQ，即</p>
<p>搬到内存里，经过CPU的加密封装&hellip;等，然后再写回到存储器（内存），再将我们的</p>
<p>文件数据刷新到网卡，经过网卡，对方网卡接收，读到内存，经过CPU解包解密，写回</p>
<p>到内存，打开对应目标文件，然后把数据写入到输出设备（磁盘）</p>
<h3 id="114-操作系统">1.1.4 操作系统
</h3><h4 id="操作系统基本介绍">操作系统基本介绍
</h4><p>一个基本的程序集合，称为操作系统（OS）</p>
<p>操作系统是一款<strong>进行软硬件管理</strong>的<mark>软件</mark></p>
<p><strong>操作系统包括：</strong></p>
<p><strong>内核</strong>（进程管理，内存管理，文件管理，驱动管理）</p>
<p><strong>其它程序</strong>（例如函数库，shell程序）</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250910094856748.png"
	width="1150"
	height="576"
	
	loading="lazy"
	
		alt="image-20250910094856748"
	
	
		class="gallery-image" 
		data-flex-grow="199"
		data-flex-basis="479px"
	
></p>
<h4 id="设计os的目的"><strong>设计OS的目的</strong>
</h4><p>为用户程序提供一个良好的执行环境</p>
<p><strong>硬件部分</strong></p>
<p>最底层是硬件，而硬件在逻辑上是按照冯诺依曼结构组织的</p>
<p>每一种硬件都有对应的驱动程序</p>
<p><strong>驱动程序</strong></p>
<p>在硬件层面，不同的硬件都有自己个性化的读取方式，所以我们访问各种不同的硬件都要配上驱动程序</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250910095228256.png"
	width="1023"
	height="888"
	
	loading="lazy"
	
		alt="image-20250910095228256"
	
	
		class="gallery-image" 
		data-flex-grow="115"
		data-flex-basis="276px"
	
></p>
<p><strong>操作系统</strong></p>
<p>对下，与软硬件交互，管理所有软硬件资源（不是目的，是手段）</p>
<p>对上，为用户（目的）程序（应用程序）提供一个良好的执行环境</p>
<p><strong>1.软硬件体系结构层状结构 &ndash; 从硬件一直到用户</strong></p>
<blockquote>
<p>硬件是一层，驱动程序是一层，操作系统是一层</p>
<p>软件的层状结构：在软件功能上体现高内聚，低耦合</p>
<ul>
<li>高内聚：将相同功能相同逻辑的代码数据放到同一层的内部</li>
<li>低耦合：层跟层之间只使用接口来调用</li>
</ul>
<p>目的：提高代码的可维护性 &ndash;一个模块修改了，不影响另一个模块</p>
</blockquote>
<p><strong>2.访问操作系统，必须使用系统调用&ndash;其实就是函数，只不过是系统提供的</strong></p>
<blockquote>
<p>prinf的本质：把数据写到了硬件!显示器!</p>
<p>底层封装了系统调用，然后通过操作系统，对驱动进行访问，访问对应驱动，然后才能把数据交到硬件上</p>
</blockquote>
<p><strong>3.我们的程序，只要你判断出它访问了硬件，那么它必须贯穿整个软硬件体系结构</strong></p>
<p><strong>4.我们平时用的库可能在底层封装了系统调用</strong></p>
<p><strong>理解操作系统</strong></p>
<ul>
<li>
<p>核心功能</p>
<ul>
<li>在整个计算机软硬件架构中，操作系统是一款进行软硬件<span style="color: #8080FF;">管理</span>的软件</li>
</ul>
</li>
<li>
<p>如何理解管理？</p>
<ul>
<li>
<p>事情：1.决策 2.执行</p>
</li>
<li>
<p>操作系统拥有决策权，驱动程序来执行，硬件被管理</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736728845182.png"
	width="414"
	height="571"
	
	loading="lazy"
	
		alt="73672884518"
	
	
		class="gallery-image" 
		data-flex-grow="72"
		data-flex-basis="174px"
	
></p>
<p>1.要管理，管理者和被管理者，可以不需要见面</p>
<p>2.管理者和被管理者，怎么管理呢？根据数据进行管理</p>
<p>3.不需要见面，如何得到数据？由中间层获取</p>
</li>
</ul>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250910205552418.png"
	width="1199"
	height="790"
	
	loading="lazy"
	
		alt="image-20250910205552418"
	
	
		class="gallery-image" 
		data-flex-grow="151"
		data-flex-basis="364px"
	
></p>
</li>
</ul>
<p><strong>操作系统如何管理硬件？</strong></p>
<blockquote>
<p>1.描述起来，用struct结构体
2.组织起来，用链表或其他高效的数据结构</p>
</blockquote>
<p>每一个硬件都有硬件名，操作系统在内部，<mark>先描述，再组织</mark>。</p>
<p>把网卡、硬盘、显卡、键盘、显示器等统一使用struct device定义一个结构</p>
<p>类里面可以包含每一种硬件的各种属性（硬件名称、状态、相关链接信息..）</p>
<p>每一个硬件都对应一个struct device对象，把对象管理起来。</p>
<p>操作系统管理硬件 &mdash;&gt; 对硬件的增删查改</p>
<blockquote>
<p><strong>操作系统怎么对进程进行管理？</strong></p>
<p>操作系统要对每个进程定义struct结构体结构，然后将进程相关的属性放到</p>
<p>结构体里，用链接结点全部连起来，转换成对进程管理，转换成对链表的</p>
<p>增删查改</p>
</blockquote>
<p>C++中：类+STL</p>
<ul>
<li>类解决了先描述</li>
<li>STL解决了再组织</li>
</ul>
<p><strong>理解系统调用</strong></p>
<ul>
<li>操作系统要向上提供对应的服务</li>
<li>操作系统，不相信任何用户或者人</li>
</ul>
<p>我们未来访问操作系统、获取操作系统内的数据、设置自己的信息等都要通过系统调用来完成</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1740052959285.png"
	width="1177"
	height="246"
	
	loading="lazy"
	
		alt="74005295928"
	
	
		class="gallery-image" 
		data-flex-grow="478"
		data-flex-basis="1148px"
	
></p>
<p>Linux/windows/macos的操作系统都是C语言写的&ndash;&gt;C函数&ndash;&gt;输入参数和返回值</p>
<ul>
<li>输入参数：用户给操作系统</li>
<li>返回值：操作系统给用户</li>
</ul>
<p><mark>系统调用的本质：用户和操作系统之间，进行某种数据交互</mark></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736733937738.png"
	width="867"
	height="423"
	
	loading="lazy"
	
		alt="73673393773"
	
	
		class="gallery-image" 
		data-flex-grow="204"
		data-flex-basis="491px"
	
></p>
<blockquote>
<p>库函数如果访问了硬件，那么底层一定访问了系统调用</p>
</blockquote>
<p><strong>系统调用和库函数</strong></p>
<blockquote>
<p>在开发角度，操作系统对外会表现为一个整体，但是会<strong>暴露自己的部分接口，供上层开发使用</strong>，这部分<strong>由操作系统提供的接口，叫做系统调用</strong>。</p>
<p>系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以<strong>对部分系统调用进行适度封装，从而形成库</strong>，有了库，就很有利于更上层用户或者开发者进行二次开发。</p>
</blockquote>
<h2 id="12-进程">1.2 进程
</h2><h3 id="121-概念">1.2.1 概念
</h3><p>==进程 = 内核数据结构对象 + 自己的代码和数据==</p>
<p>==进程 = PCB(task_struct) + 自己的代码和数据==</p>
<p>操作系统必然要对多个被加载到内存中的程序进行管理</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736734939556.png"
	width="1141"
	height="745"
	
	loading="lazy"
	
		alt="73673493955"
	
	
		class="gallery-image" 
		data-flex-grow="153"
		data-flex-basis="367px"
	
></p>
<p><span style="color: #FF0000;">对进程的管理，就变成了对链表的增删查改 </span></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736734972066.png"
	width="193"
	height="306"
	
	loading="lazy"
	
		alt="73673497206"
	
	
		class="gallery-image" 
		data-flex-grow="63"
		data-flex-basis="151px"
	
></p>
<p>我们把这个结构体叫PCB（process control block )进程控制块</p>
<p>在Linux中，这个PCB叫task_struct，</p>
<p>进程的所有属性，都可以直接或者间接通过task_struct找到</p>
<blockquote>
<p>task_struct - PCB的一种</p>
<ul>
<li>在Linux中描述进程的结构体叫做task_struct。</li>
<li>task_struct是Linux内核的一种数据结构类型，它会被装载到RAM（内存）里并且包含着进程的信息</li>
</ul>
</blockquote>
<h3 id="622-task_"><strong>6.2.2 task_struct</strong>
</h3><blockquote>
<p>在Linux中描述进程的结构体叫做task_struct。</p>
</blockquote>
<ul>
<li>标志符：<span style="color: #8080FF;">描述本进程的唯一标志符，用来区别其它进程</span></li>
<li>状态：任务状态、退出代码、退出信号</li>
<li>优先级：相对于其它进程的优先级</li>
<li>程序计数器：程序中即将被执行的下一条指令的地址</li>
<li>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针，能真正找到代码和数据</li>
<li><strong>上下文数据</strong>：进程执行时处理器的寄存器中的数据</li>
<li>I/O状态信息：包括显示的I/0请求，分配给进程的I/0设备和被进程使用的文件列表</li>
<li>记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等</li>
<li>其他信息</li>
</ul>
<p><strong>组织进程</strong></p>
<blockquote>
<p>可以在内核源代码里找到它。所有运行在系统里的进程都以task_struct链表的形式存在内核里</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914161445126.png"
	width="1018"
	height="523"
	
	loading="lazy"
	
		alt="image-20250914161445126"
	
	
		class="gallery-image" 
		data-flex-grow="194"
		data-flex-basis="467px"
	
></p>
<h3 id="623-查看进程">6.2.3 查看进程
</h3><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736925104339.png"
	width="233"
	height="89"
	
	loading="lazy"
	
		alt="73692510433"
	
	
		class="gallery-image" 
		data-flex-grow="261"
		data-flex-basis="628px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736925083748.png"
	width="419"
	height="233"
	
	loading="lazy"
	
		alt="73692508374"
	
	
		class="gallery-image" 
		data-flex-grow="179"
		data-flex-basis="431px"
	
></p>
<p>sleep需要包含头文件unistd</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736925040146.png"
	width="586"
	height="539"
	
	loading="lazy"
	
		alt="73692504014"
	
	
		class="gallery-image" 
		data-flex-grow="108"
		data-flex-basis="260px"
	
></p>
<p>我们历史上执行的所有<mark>指令，工具，自己的程序</mark>，<strong>运行起来，全部都是进程</strong></p>
<h4 id="getpid查看进程id">getpid()查看进程id
</h4><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736925739600.png"
	width="753"
	height="238"
	
	loading="lazy"
	
		alt="73692573960"
	
	
		class="gallery-image" 
		data-flex-grow="316"
		data-flex-basis="759px"
	
></p>
<p><strong>getpid获得标志符，谁调用这个函数就获得谁的进程ID</strong></p>
<p>调getpid本质是让操作系统从PCB里把我的pid拷贝出来，让用户看到我的ID是什么</p>
<blockquote>
<ul>
<li>man 3号手册是库调用，2号手册是系统调用</li>
<li>task_stuct结构体里有个属性叫pid</li>
<li><mark>getpid是系统调用，为了获得进程自己的pid</mark>，pid在当前进程task_struct里对应的标志符里</li>
</ul>
</blockquote>
<p><strong>只要是一个进程，就有自己的ID信息</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>               
</span></span><span class="line"><span class="cl"><span class="p">{</span>                     
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>                 
</span></span><span class="line"><span class="cl">        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>      
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;我是一个进程!, 我的pid:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>                    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl">                                                               
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>                                                 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914162920848.png"
	width="930"
	height="373"
	
	loading="lazy"
	
		alt="image-20250914162920848"
	
	
		class="gallery-image" 
		data-flex-grow="249"
		data-flex-basis="598px"
	
></p>
<p><code>ps axj</code>查看以特定形式显示的所有进程（a表示所有）</p>
<ol>
<li><code>ps axj | head -l</code>先将第一行显示（属性列的名字）</li>
</ol>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736926676916.png"
	width="1124"
	height="87"
	
	loading="lazy"
	
		alt="73692667691"
	
	
		class="gallery-image" 
		data-flex-grow="1291"
		data-flex-basis="3100px"
	
></p>
<ol start="2">
<li><code>ps axj | grep myprocess</code>再查我们的进程</li>
</ol>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736926613428.png"
	width="1236"
	height="163"
	
	loading="lazy"
	
		alt="73692661342"
	
	
		class="gallery-image" 
		data-flex-grow="758"
		data-flex-basis="1819px"
	
></p>
<p>在Linux中，如果想<mark>同时执行两条命令</mark>，<mark>可以使用分号或者&amp;&amp;连接</mark></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736926804631.png"
	width="1187"
	height="190"
	
	loading="lazy"
	
		alt="73692680463"
	
	
		class="gallery-image" 
		data-flex-grow="624"
		data-flex-basis="1499px"
	
></p>
<blockquote>
<p>因为grep命令它自己跑起来也是一个进程，它过滤的关键字中也包含myprocess，所以它自己也会被查出来，如果不想把grep也查出来，可以带-v 反向匹配，也就是包含grep的不查出来</p>
<p><code>ps ajx | head -1;ps axj | grep myprocess | grep -v grep</code></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1740057449955.png"
	width="1410"
	height="122"
	
	loading="lazy"
	
		alt="74005744995"
	
	
		class="gallery-image" 
		data-flex-grow="1155"
		data-flex-basis="2773px"
	
></p>
</blockquote>
<p><strong>杀掉进程</strong>：<code>kill -9 对应PID</code></p>
<blockquote>
<p>-9表示信号</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1740057526187.png"
	width="654"
	height="39"
	
	loading="lazy"
	
		alt="74005752618"
	
	
		class="gallery-image" 
		data-flex-grow="1676"
		data-flex-basis="4024px"
	
></p>
<p>ctrl+c也可以杀掉进程</p>
<h4 id="通过文件去查看进程">通过文件去查看进程
</h4><p>可以通过文件的方式去查看进程</p>
<blockquote>
<p>proc目录（process的简写）</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736927704025.png"
	width="1120"
	height="502"
	
	loading="lazy"
	
		alt="73692770402"
	
	
		class="gallery-image" 
		data-flex-grow="223"
		data-flex-basis="535px"
	
></p>
<p>进程运行时，proc里的数据已经拷贝到内存了</p>
<p>例如：</p>
<ol>
<li>先将程序运行起来</li>
</ol>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736928299460.png"
	width="719"
	height="76"
	
	loading="lazy"
	
		alt="73692829946"
	
	
		class="gallery-image" 
		data-flex-grow="946"
		data-flex-basis="2270px"
	
></p>
<ol start="2">
<li>查proc目录里的pid文件</li>
</ol>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736928340654.png"
	width="816"
	height="82"
	
	loading="lazy"
	
		alt="73692834065"
	
	
		class="gallery-image" 
		data-flex-grow="995"
		data-flex-basis="2388px"
	
></p>
<ol start="3">
<li>当我们杀掉这个进程后再查，就发现找不到目录了</li>
</ol>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1740058006381.png"
	width="1005"
	height="82"
	
	loading="lazy"
	
		alt="74005800638"
	
	
		class="gallery-image" 
		data-flex-grow="1225"
		data-flex-basis="2941px"
	
></p>
<p><strong>看一看进程目录下都有哪些文件</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736928717526.png"
	width="1647"
	height="378"
	
	loading="lazy"
	
		alt="73692871752"
	
	
		class="gallery-image" 
		data-flex-grow="435"
		data-flex-basis="1045px"
	
></p>
<ul>
<li>
<p>exe：进程对应的可执行文件</p>
</li>
<li>
<p>cwd：current work dir 进程会记录下来自己的当前路径</p>
</li>
</ul>
<p><strong>更改一个进程的当前路径<code>chdir</code></strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736928992426.png"
	width="836"
	height="311"
	
	loading="lazy"
	
		alt="73692899242"
	
	
		class="gallery-image" 
		data-flex-grow="268"
		data-flex-basis="645px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736929101055.png"
	width="932"
	height="601"
	
	loading="lazy"
	
		alt="73692910105"
	
	
		class="gallery-image" 
		data-flex-grow="155"
		data-flex-basis="372px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736929275552.png"
	width="948"
	height="576"
	
	loading="lazy"
	
		alt="73692927555"
	
	
		class="gallery-image" 
		data-flex-grow="164"
		data-flex-basis="395px"
	
></p>
<h4 id="getppid查看父进程">getppid()查看父进程
</h4><p>getppid()</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736929537072.png"
	width="1427"
	height="645"
	
	loading="lazy"
	
		alt="73692953707"
	
	
		class="gallery-image" 
		data-flex-grow="221"
		data-flex-basis="530px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914170727248.png"
	width="995"
	height="483"
	
	loading="lazy"
	
		alt="image-20250914170727248"
	
	
		class="gallery-image" 
		data-flex-grow="206"
		data-flex-basis="494px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914171033193.png"
	width="1440"
	height="119"
	
	loading="lazy"
	
		alt="image-20250914171033193"
	
	
		class="gallery-image" 
		data-flex-grow="1210"
		data-flex-basis="2904px"
	
></p>
<p>1.命令行解释器（王婆）：本质是一个进程</p>
<p>2.王婆和实习生</p>
<p><span style="color: #8080FF;">操作系统会给每一个登录用户，分配一个bash</span><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914171704134.png"
	width="1930"
	height="268"
	
	loading="lazy"
	
		alt="image-20250914171704134"
	
	
		class="gallery-image" 
		data-flex-grow="720"
		data-flex-basis="1728px"
	
></p>
<h4 id="fork函数创建子进程">fork函数创建子进程
</h4><p>fork函数，从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914172129942.png"
	width="661"
	height="349"
	
	loading="lazy"
	
		alt="image-20250914172129942"
	
	
		class="gallery-image" 
		data-flex-grow="189"
		data-flex-basis="454px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914172713326.png"
	width="995"
	height="566"
	
	loading="lazy"
	
		alt="image-20250914172713326"
	
	
		class="gallery-image" 
		data-flex-grow="175"
		data-flex-basis="421px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914172825066.png"
	width="916"
	height="154"
	
	loading="lazy"
	
		alt="image-20250914172825066"
	
	
		class="gallery-image" 
		data-flex-grow="594"
		data-flex-basis="1427px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914173025725.png"
	width="781"
	height="267"
	
	loading="lazy"
	
		alt="image-20250914173025725"
	
	
		class="gallery-image" 
		data-flex-grow="292"
		data-flex-basis="702px"
	
></p>
<p><strong>fork的返回值</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914173839780.png"
	width="1724"
	height="197"
	
	loading="lazy"
	
		alt="image-20250914173839780"
	
	
		class="gallery-image" 
		data-flex-grow="875"
		data-flex-basis="2100px"
	
></p>
<ul>
<li>
<p>如果创建子进程成功了，那么父进程和新创建的子进程都要执行这个函数的return语句，此时</p>
<ul>
<li>如果是父进程，那么返回值就是子进程的pid</li>
<li>如果是子进程，那么返回值是0</li>
</ul>
</li>
<li>
<p>如果创建子进程失败了，那么返回值就是-1</p>
</li>
</ul>
<p><strong>现在我们想让父子未来执行不同的代码逻辑</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914174436507.png"
	width="1636"
	height="1720"
	
	loading="lazy"
	
		alt="image-20250914174436507"
	
	
		class="gallery-image" 
		data-flex-grow="95"
		data-flex-basis="228px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914174952332.png"
	width="912"
	height="299"
	
	loading="lazy"
	
		alt="image-20250914174952332"
	
	
		class="gallery-image" 
		data-flex-grow="305"
		data-flex-basis="732px"
	
></p>
<ol>
<li>
<p><strong>为什么fork给父子返回各自的不同返回值？</strong></p>
<p>父：子 = 1：n</p>
<p>任何一个父进程都可以有多个子进程，任何一个子进程都只会有一个父进程</p>
<p>所以未来创建子进程的时候，一定要把子进程的pid返回给父进程，因为<strong>父进程要通过不同的pid来区分不同的子进程</strong>，而子进程不需要获得父进程的pid，因为它自己能getpid()</p>
</li>
<li>
<p><strong>为什么一个函数会返回两次？</strong></p>
<p>当一个函数已经到return xx了，核心工作已经做完了。</p>
<p>fork函数当执行到return语句的时候，子进程已经被创建，甚至被调度了！</p>
<p>由于return 也是语句，所以父子进程各执行一次</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250914180037050.png"
	width="1704"
	height="676"
	
	loading="lazy"
	
		alt="image-20250914180037050"
	
	
		class="gallery-image" 
		data-flex-grow="252"
		data-flex-basis="604px"
	
></p>
<p>返回的本质是在写入变量</p>
<blockquote>
<p>进程调用fork，当控制转移到内核中的fork代码后，内核做：</p>
<ul>
<li>分配新的内存块和内核数据结构给子进程</li>
<li>将父进程部分数据结构内容拷贝至子进程</li>
<li>添加子进程到系统进程列表当中</li>
<li>fork返回，开始调度器调度</li>
</ul>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251029112419978.png"
	width="1006"
	height="428"
	
	loading="lazy"
	
		alt="image-20251029112419978"
	
	
		class="gallery-image" 
		data-flex-grow="235"
		data-flex-basis="564px"
	
></p>
</li>
<li>
<p><strong>为什么一个变量，既==0，又大于0？导致if else 同时成立</strong>?</p>
<p>子进程修改变量时，会重新开一块空间。父子进程访问同一个变量时，拿的都是虚拟地址，但底层映射到了不同的物理地址</p>
</li>
</ol>
<p><strong>进程具有独立性</strong></p>
<ol>
<li>
<p>数据结构独立，进程=内核数据结构对象 + 自己的代码和数据</p>
</li>
<li>
<p>代码共享，但是代码是只读的</p>
</li>
<li>
<p>数据以写时拷贝的方式，各自私有一份</p>
</li>
</ol>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1736934233629.png"
	width="1152"
	height="249"
	
	loading="lazy"
	
		alt="73693423362"
	
	
		class="gallery-image" 
		data-flex-grow="462"
		data-flex-basis="1110px"
	
></p>
<blockquote>
<p><strong>写时拷贝</strong></p>
<p>通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副本</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251029105929375.png"
	width="989"
	height="369"
	
	loading="lazy"
	
		alt="image-20251029105929375"
	
	
		class="gallery-image" 
		data-flex-grow="268"
		data-flex-basis="643px"
	
></p>
<p>因为有写时拷贝技术的存在，所以父子进程得以彻底分离离！完成了进程独立性的技术保证！
写时拷贝，是一种延时申请技术，可以提高整机内存的使用率</p>
</blockquote>
<h2 id="13进程的状态"><strong>1.3</strong>进程的状态
</h2><h3 id="631进程状态基本介绍">6.3.1进程状态基本介绍
</h3><p>一个进程可以有几个状态（在Linux内核里，进程有时候也叫做任务）</p>
<p>进程状态就是task_struct内的一个整数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">*The task state array is a strange &#34;bitmap&#34; of
</span></span></span><span class="line"><span class="cl"><span class="cm">*reasons to sleep. Thus &#34;running&#34; is zero, and
</span></span></span><span class="line"><span class="cl"><span class="cm">*you can test for combinations of others with
</span></span></span><span class="line"><span class="cl"><span class="cm">*simple bit tests.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">task_state_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;R (running)&#34;</span><span class="p">,</span> <span class="cm">/*0 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;S (sleeping)&#34;</span><span class="p">,</span> <span class="cm">/*1 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;D (disk sleep)&#34;</span><span class="p">,</span> <span class="cm">/*2 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;T (stopped)&#34;</span><span class="p">,</span> <span class="cm">/*4 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;t (tracing stop)&#34;</span><span class="p">,</span> <span class="cm">/*8 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;X (dead)&#34;</span><span class="p">,</span> <span class="cm">/*16 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;Z (zombie)&#34;</span><span class="p">,</span> <span class="cm">/*32 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>进程状态很多，这些状态间可以相互进行转换</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918103847327.png"
	width="1274"
	height="795"
	
	loading="lazy"
	
		alt="image-20250918103847327"
	
	
		class="gallery-image" 
		data-flex-grow="160"
		data-flex-basis="384px"
	
></p>
<h4 id="运行阻塞挂起">运行&amp;&amp;阻塞&amp;&amp;挂起
</h4><p>一个CPU，一个调度队列。这个队列在Linux内核里叫runqueue</p>
<p>CPU调度就是在这个队列中，按照顺序，依次选择一个task_struct来选择执行</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918104655266.png"
	width="1372"
	height="418"
	
	loading="lazy"
	
		alt="image-20250918104655266"
	
	
		class="gallery-image" 
		data-flex-grow="328"
		data-flex-basis="787px"
	
></p>
<p>**运行：**进程在调度队列中，进程的状态都是running</p>
<p>**阻塞：**等待某种设备或者资源就绪（键盘，显示器，网卡，磁盘，摄像头，话筒&hellip;.）</p>
<blockquote>
<p>操作系统要管理系统中的各种硬件资源，先描述，再组织</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918105818682.png"
	width="1349"
	height="760"
	
	loading="lazy"
	
		alt="image-20250918105818682"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="426px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918152009319.png"
	width="323"
	height="325"
	
	loading="lazy"
	
		alt="image-20250918152009319"
	
	
		class="gallery-image" 
		data-flex-grow="99"
		data-flex-basis="238px"
	
></p>
<p>例子：</p>
<p>CPU正在运行一个进程，运行的过程中操作系统发现这个进程要scanf进行读取，操作系统就去检查键盘的状态，发现键盘并没有被按下，操作系统就认为这个进程就无法继续往下运行，就把这个进程从CPU上拿下来，并把它从运行队列中移走并链入到<span style="color: #8080FF;">特定设备的等待队列</span>中，这个进程就<span style="color: #8080FF;">没有在运行队列</span>中，不会被调度，这个进程就处于<span style="color: #8080FF;">阻塞</span>状态了（<span style="color: #8080FF;">只有在运行队列里的进程才会被CPU调度</span>）</p>
<p>当键盘被按下了即硬件就绪了，由于操作系统是硬件的管理者，操作系统知道了，于是直接去查看对应就绪设备的节点，将其状态设置为活跃的，并检查等待队列，发现不为空，就将等待队列中的进程设置为运行状态，然后将该进程重新链回运行队列</p>
</blockquote>
<ul>
<li>
<p>从运行队列到变成阻塞的本质其实是把PCB链入到不同的队列结构中</p>
</li>
<li>
<p>从阻塞回到运行状态，本质上就是找到PCB，再把PCB链回到运行队列，就变成运行状态了</p>
</li>
<li>
<p>进程状态的变化，表现之一就是要在不同的队列中进行流动，本质都是数据结构的增删改查</p>
</li>
</ul>
<p>**挂起：**本质是把进程换入换出到磁盘的swap交换分区</p>
<blockquote>
<p>在<code>等待队列</code>中，可能不止一个进程，这些进程没有被执行但是都需要占用内存空间，当内存空间严重不足时，操作系统就会将这些在等待队列的进程置换到磁盘中的swap分区中（在等待队列中只存PCB，而将对应的代码和数据唤出到swap分区中，等这些进程要运行了，再把代码和数据还回去），这些进程的状态就叫阻塞挂起</p>
<p>如果内存特别紧张，操作系统可能把在<code>运行队列中末端的一些进程</code>置换到磁盘中——&gt;运行挂起状态</p>
</blockquote>
<h4 id="理解内核链表">理解内核链表
</h4><p>我们以前学的链表，next指针会指向整个Node结点：</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918155832158.png"
	width="939"
	height="182"
	
	loading="lazy"
	
		alt="image-20250918155832158"
	
	
		class="gallery-image" 
		data-flex-grow="515"
		data-flex-basis="1238px"
	
></p>
<p>Linux内核中的链表，next指针只会指向目标结构体内部的某一个成员对象：</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918161314320.png"
	width="1566"
	height="739"
	
	loading="lazy"
	
		alt="image-20250918161314320"
	
	
		class="gallery-image" 
		data-flex-grow="211"
		data-flex-basis="508px"
	
></p>
<p>==一个PCB在内核里只存在一份，一个PCB可以同时隶属于多个结构==</p>
<blockquote>
<p>我们内核中的数据结构不是单一的数据结构</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918161537954.png"
	width="1251"
	height="658"
	
	loading="lazy"
	
		alt="image-20250918161537954"
	
	
		class="gallery-image" 
		data-flex-grow="190"
		data-flex-basis="456px"
	
></p>
<h4 id="进程状态查看的命令">进程状态查看的命令
</h4><blockquote>
<p>ps aux 和 ps axj</p>
<ul>
<li>a：显示一个终端所有的进程，包括其他用户的进程。</li>
<li>x：显示没有控制终端的进程，例如后台运行的守护进程。</li>
<li>j：显示进程归属的进程组ID、会话ID、父进程ID，以及与作业控制相关的信息</li>
<li>u：以用户为中心的格式显示进程信息，提供进程的详细信息，如用户、CPU和内存使用情况等</li>
</ul>
</blockquote>
<h4 id="linux的进程状态">Linux的进程状态
</h4><p><img src="/p/linux-process-basic/index.assets/image-20251106171043386.png"
	width="1039"
	height="702"
	
	loading="lazy"
	
		alt="image-20251106171043386"
	
	
		class="gallery-image" 
		data-flex-grow="148"
		data-flex-basis="355px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">task_state_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;R (running)&#34;</span><span class="p">,</span><span class="cm">/*0 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;S (sleeping)&#34;</span><span class="err">，</span><span class="cm">/*l */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;D）(disk sleep)&#34;</span><span class="err">，</span><span class="cm">/*2 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;T(stopped)&#34;</span><span class="err">，</span><span class="cm">/*4 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;t(tracing stop)&#34;</span><span class="err">，</span><span class="cm">/*8 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;X (dead)&#34;</span><span class="err">，</span><span class="cm">/*16 */</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;Z (zombie)&#34;</span><span class="err">，</span><span class="cm">/*32 */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>**R运行状态（running  ）：**并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里</p>
<p>当我们不做IO相关的操作时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;                                        </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918163503693.png"
	width="1092"
	height="72"
	
	loading="lazy"
	
		alt="image-20250918163503693"
	
	
		class="gallery-image" 
		data-flex-grow="1516"
		data-flex-basis="3640px"
	
></p>
<blockquote>
<p>有加号的原因是因为进程是在前台启动的，把<code>&amp;</code>放到运行进程命令的后面就可以让进程在后台运行</p>
<p>例如  <code>./myprocess &amp;</code> 表示将myprocess进程放在后台去运行<img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918163817637.png"
	width="1107"
	height="79"
	
	loading="lazy"
	
		alt="image-20250918163817637"
	
	
		class="gallery-image" 
		data-flex-grow="1401"
		data-flex-basis="3363px"
	
></p>
</blockquote>
</li>
<li>
<p><strong>S睡眠状态（sleeping)</strong>：意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠
(interruptible sleep)，浅睡眠）</p>
<blockquote>
<p>可中断休眠状态：如果一个进程自己处于S状态，我们可以直接杀掉这个进程，这个进程会响应我们杀掉它的动作</p>
</blockquote>
<p>当我们键盘一直没有输入时，进程状态就是S（阻塞状态）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;  </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;  </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>                                        
</span></span><span class="line"><span class="cl"><span class="p">{</span>                                                 
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;我是一个进程，pid：%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">());</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>                                                     
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918165113210.png"
	width="1094"
	height="75"
	
	loading="lazy"
	
		alt="image-20250918165113210"
	
	
		class="gallery-image" 
		data-flex-grow="1458"
		data-flex-basis="3500px"
	
></p>
<p>当代码中有printf（有IO操作）时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;                                        </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;hello</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918162923794.png"
	width="1107"
	height="80"
	
	loading="lazy"
	
		alt="image-20250918162923794"
	
	
		class="gallery-image" 
		data-flex-grow="1383"
		data-flex-basis="3321px"
	
></p>
</li>
<li>
<p><strong>t和T 暂停状态</strong></p>
<p><strong>t状态</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918165800223.png"
	width="1272"
	height="1236"
	
	loading="lazy"
	
		alt="image-20250918165800223"
	
	
		class="gallery-image" 
		data-flex-grow="102"
		data-flex-basis="246px"
	
></p>
<p>当我们调试程序时，给这个程序打上断点再运行，那么这个程序的进程状态就是 t，即进程被暂停了</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918165644447.png"
	width="1599"
	height="111"
	
	loading="lazy"
	
		alt="image-20250918165644447"
	
	
		class="gallery-image" 
		data-flex-grow="1440"
		data-flex-basis="3457px"
	
></p>
<p><strong>T停止状态（stopped）</strong>：可以通过发送 SIGSTOP信号给进程来停止（T）进程。这个被暂停的
进程可以通过发送SIGCONT信号让进程继续运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;                                        </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;hello</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们按ctrl+Z 将当前进程暂停，是通过用户进行操作将进程暂停了，这时的状态就是 T</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918170803795.png"
	width="768"
	height="117"
	
	loading="lazy"
	
		alt="image-20250918170803795"
	
	
		class="gallery-image" 
		data-flex-grow="656"
		data-flex-basis="1575px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918170549871-17581863759721.png"
	width="1088"
	height="80"
	
	loading="lazy"
	
		alt="image-20250918170549871"
	
	
		class="gallery-image" 
		data-flex-grow="1360"
		data-flex-basis="3264px"
	
></p>
<blockquote>
<p>暂停进程的方式二：发送信号</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918173727937.png"
	width="1290"
	height="609"
	
	loading="lazy"
	
		alt="image-20250918173727937"
	
	
		class="gallery-image" 
		data-flex-grow="211"
		data-flex-basis="508px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918173900743.png"
	width="1091"
	height="75"
	
	loading="lazy"
	
		alt="image-20250918173900743"
	
	
		class="gallery-image" 
		data-flex-grow="1454"
		data-flex-basis="3491px"
	
></p>
<p>如果想要进程再次运行</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918174009739.png"
	width="992"
	height="87"
	
	loading="lazy"
	
		alt="image-20250918174009739"
	
	
		class="gallery-image" 
		data-flex-grow="1140"
		data-flex-basis="2736px"
	
></p>
</blockquote>
</li>
<li>
<p><strong>D磁盘休眠状态（Disk sleep）</strong>：深睡眠，也可以叫不可中断睡眠状态（uninterruptible sleep），通常发生在同步I/O操作或某些内核操作（如内存换页）时。在这个状态的进程通常会等待IO的结束。</p>
<p>处于D状态的进程有权不对任何杀掉的动作做出响应，也就是操作系统或者用户不管什么情况下都杀不死该进程，只能等该进程自己”醒来“</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918172134624.png"
	width="724"
	height="516"
	
	loading="lazy"
	
		alt="image-20250918172134624"
	
	
		class="gallery-image" 
		data-flex-grow="140"
		data-flex-basis="336px"
	
></p>
<blockquote>
<p>注意：</p>
<p>1.正常的用户程序（如复制文件）通常不会长时间处于D状态，因为操作系统使用了缓存。</p>
<p>2.如果系统中有进程长时间处于D状态，这很可能意味着硬件（如磁盘）出现了故障，或者系统负载过高导致I/O响应极其缓慢（比如在内存不足时大量换页），从而使得进程无法在短时间内完成l/O操作。</p>
</blockquote>
<p>模拟D状态：dd命令</p>
<p>dd if=/dev/zero of=~/test.txt bs=4096 count=100000</p>
</li>
<li>
<p><strong>x死亡状态（dead）</strong>：这个状态只是一个返回状态，你不会在任务列表里看到这个状态</p>
</li>
<li>
<p><a class="link" href="###6.3.3%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b" >Z僵尸状态（zombie）</a>：子进程退出后，父进程还在运行，但父进程没有读取子进程退出信息，此时子进程就进入Z状态</p>
</li>
</ul>
<h4 id="总结">总结
</h4><ul>
<li>
<p><strong>运行</strong></p>
<ul>
<li>R：运行状态，我们可以把 运行状态、就绪状态、创建状态 都当成运行状态</li>
</ul>
</li>
<li>
<p><strong>阻塞</strong>：</p>
<ul>
<li>S：可中断睡眠，浅睡眠。意味着进程在等待事件完成</li>
<li>D：不可中断睡眠，深度睡眠。和磁盘的读取写入相关（如果被中断，可能会导致数据丢失）</li>
</ul>
</li>
<li>
<p><strong>暂停状态 t / T</strong></p>
<ul>
<li>t：被debug，断点：进程被暂停了</li>
<li>T：通过用户进行操作将进程暂停，比如通过发送信号 kill -19</li>
</ul>
</li>
<li>
<p><strong>结束状态</strong></p>
<ul>
<li>X：死亡状态</li>
<li>Z：僵尸状态，子进程退出后，父进程还在运行，但父进程没有读取子进程退出信息</li>
</ul>
</li>
</ul>
<p>阻塞状态是进程自己等待某种设备或者资源就绪，比如进程等待 I/O 完成</p>
<p>暂停状态是外部强制让进程停下来，比如调试过程中下断点和用户发送暂停信号</p>
<p>挂起状态本质是系统内资源严重不足，操作系统为了节省内存，把一个进程的代码和数据换出到交换分区上，等需要调度/运行的时候再换入进来</p>
<h3 id="632僵尸进程">6.3.2僵尸进程
</h3><p><strong>Z僵尸状态（zombie）</strong>：为了获取退出信息</p>
<blockquote>
<p>在Linux系统里，我们目前所学的所有进程都是某个进程的子进程，我们创建子进程的目的是为了让子进程完成某种事情。所以当一个子进程退出，不能直接退出，子进程退出的结果信息得让父进程知道</p>
<p>当一个进程退出时，它的代码和数据直接就被释放掉了，但是它的PCB必须一直维持（PCB就是操作系统内部的一个数据结构，父进程可以进行系统调用，获得子进程的信息），直到父进程读取到子进程的退出信息</p>
</blockquote>
<p><strong>如何模拟Z状态？</strong></p>
<p>1.需要有父子进程</p>
<p>2.需要让子进程退出</p>
<p>3.子进程在退出的时候，父进程什么都不干，让子进程一直维持在Z状态</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918180152504.png"
	width="1437"
	height="1519"
	
	loading="lazy"
	
		alt="image-20250918180152504"
	
	
		class="gallery-image" 
		data-flex-grow="94"
		data-flex-basis="227px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918180437148.png"
	width="1272"
	height="114"
	
	loading="lazy"
	
		alt="image-20250918180437148"
	
	
		class="gallery-image" 
		data-flex-grow="1115"
		data-flex-basis="2677px"
	
></p>
<p>如果父进程一直不管，不回收，不获取子进程的退出信息，那么Z状态会一直存在</p>
<blockquote>
<p>如果父进程不管，子进程的Z状态一直存在，那么PCB就要一直维护，就要一直占用内存，就会引发内存泄漏问题</p>
<p>所以父进程未来获取子进程退出信息的时候，除了获取子进程的退出信息，还要把PCB释放掉（解决内存泄漏）</p>
</blockquote>
<p><strong>知识点1：</strong></p>
<p>进程退出了，内存泄漏问题还在不在？不在</p>
<p>什么样的进程具有内存泄漏问题，是比较麻烦的？常驻内存进程（一旦启动就不会退出）</p>
<p>操作系统一旦启动后，就是常驻内存软件</p>
<p><strong>知识点2：关于内核结构的申请</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250918182005433.png"
	width="857"
	height="511"
	
	loading="lazy"
	
		alt="image-20250918182005433"
	
	
		class="gallery-image" 
		data-flex-grow="167"
		data-flex-basis="402px"
	
></p>
<h3 id="633孤儿进程">6.3.3孤儿进程
</h3><p>父进程先退出，子进程就称为“孤儿进程”</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250921192800700.png"
	width="1431"
	height="1158"
	
	loading="lazy"
	
		alt="image-20250921192800700"
	
	
		class="gallery-image" 
		data-flex-grow="123"
		data-flex-basis="296px"
	
></p>
<p>父子进程关系中，如果父进程先退出，子进程要被init / systemd 进程领养，由init / systemd进程回收，这个被领养的进程（子进程），叫做孤儿进程</p>
<p><code>while :; do ps ajx | head -1 &amp;&amp; ps ajx | grep myprocess;sleep 1; done</code></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250921193128329.png"
	width="1102"
	height="216"
	
	loading="lazy"
	
		alt="image-20250921193128329"
	
	
		class="gallery-image" 
		data-flex-grow="510"
		data-flex-basis="1224px"
	
></p>
<p>1号 systemd/init 进程——&gt;操作系统</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250921193719843.png"
	width="1362"
	height="248"
	
	loading="lazy"
	
		alt="image-20250921193719843"
	
	
		class="gallery-image" 
		data-flex-grow="549"
		data-flex-basis="1318px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250921193945164.png"
	width="1741"
	height="303"
	
	loading="lazy"
	
		alt="image-20250921193945164"
	
	
		class="gallery-image" 
		data-flex-grow="574"
		data-flex-basis="1379px"
	
></p>
<p><strong>为什么要领养？</strong></p>
<p>如果不领养，子进程进入僵尸之后，就一定会造成内存泄漏而无法解决</p>
<p>孤儿进程会变成后台进程</p>
<blockquote>
<p>./cmd &amp; 也会变成后台进程</p>
<p>ctrl+c不能杀掉后台进程</p>
</blockquote>
<h2 id="14进程的优先级">1.4进程的优先级
</h2><h3 id="641基本概念">6.4.1基本概念
</h3><p><strong>进程的优先级是什么？</strong></p>
<p>是进程得到CPU资源的先后顺序</p>
<p><strong>为什么要有优先级？</strong></p>
<p>目标资源稀缺，导致要通过优先级确认谁先谁后的问题</p>
<p><strong>优先级vs权限</strong></p>
<p>优先级：能得到资源，先后问题</p>
<p>权限：是否能得到资源</p>
<p><strong>操作系统内优先级是如何实现的？</strong></p>
<p>优先级也是一种数字，task_struct中的一种属性</p>
<p>值越低，优先级越高，反之，优先级越低</p>
<p>当代大部分操作系统都是基于时间片的分时操作系统，要考虑公平性，优先级可能变化，但是变化幅度不能太大</p>
<h3 id="642查看系统进程">6.4.2查看系统进程
</h3><p><code>ps -l</code></p>
<p><img src="/p/linux-process-basic/index.assets/image-20251107101007169.png"
	width="1130"
	height="152"
	
	loading="lazy"
	
		alt="image-20251107101007169"
	
	
		class="gallery-image" 
		data-flex-grow="743"
		data-flex-basis="1784px"
	
></p>
<ul>
<li>UID：user id</li>
<li>PRI：代表这个进程可被执行的优先级，其值越小越早被执行</li>
</ul>
<ul>
<li>NI：代表这个进程的nice值</li>
</ul>
<p><code>ps -al | head -1 &amp;&amp; ps -al | grep myprocess</code></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926183023700.png"
	width="1319"
	height="163"
	
	loading="lazy"
	
		alt="image-20250926183023700"
	
	
		class="gallery-image" 
		data-flex-grow="809"
		data-flex-basis="1942px"
	
></p>
<p><strong>小知识</strong></p>
<p>Linux是通过用户id来识别用户的</p>
<p>文件在创建的时候就写入了UID，即这个文件是谁创建的</p>
<p>进程在启动的时候也会把UID保存起来，表明这个进程是谁启动的</p>
<blockquote>
<p>如何查看用户id？ls -ln</p>
<p>n表示显示数字</p>
<p><img src="/p/linux-process-basic/index.assets/image-20251107105743703.png"
	width="997"
	height="385"
	
	loading="lazy"
	
		alt="image-20251107105743703"
	
	
		class="gallery-image" 
		data-flex-grow="258"
		data-flex-basis="621px"
	
></p>
</blockquote>
<p>系统怎么知道我访问文件的时候，是拥有者，所属组，还是other</p>
<p>当我们 touch ，cat，vim &hellip;访问文件的时候，<span style="color: #8080FF;">本质是进程在访问文件</span></p>
<p>进程在启动的时候会保存启动它的UID</p>
<p><strong>Linux系统中，访问任何资源，都是进程访问</strong>，进程就代表用户</p>
<p>识别权限不是识别用户，是<strong>识别进程和文件之间的权限</strong>的</p>
<h3 id="643pri和ni">6.4.3PRI和NI
</h3><p><strong><span style="color: #8080FF;">PRI：进程的优先级，默认：80</span></strong></p>
<p><strong><span style="color: #8080FF;">NI：进程优先级的修正数据，nice值，默认为0</span></strong></p>
<blockquote>
<p>在Linux系统中，我们的进程优先级是可以被动态调整的，不管是进程启动前还是进程运行过程中</p>
</blockquote>
<p><strong><span style="color: #8080FF;">进程真实的优先级=PRI(默认80) + NI</span></strong></p>
<p><strong>改进程的优先级，<code>top</code>，再输入 <code>r</code></strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926184346539.png"
	width="1420"
	height="768"
	
	loading="lazy"
	
		alt="image-20250926184346539"
	
	
		class="gallery-image" 
		data-flex-grow="184"
		data-flex-basis="443px"
	
></p>
<p>修改Nice值</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926184511004.png"
	width="719"
	height="269"
	
	loading="lazy"
	
		alt="image-20250926184511004"
	
	
		class="gallery-image" 
		data-flex-grow="267"
		data-flex-basis="641px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926184656459.png"
	width="1348"
	height="174"
	
	loading="lazy"
	
		alt="image-20250926184656459"
	
	
		class="gallery-image" 
		data-flex-grow="774"
		data-flex-basis="1859px"
	
></p>
<blockquote>
<p>还有一些方法可以改进程的优先级：nice，renice命令</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926185531250.png"
	width="928"
	height="59"
	
	loading="lazy"
	
		alt="image-20250926185531250"
	
	
		class="gallery-image" 
		data-flex-grow="1572"
		data-flex-basis="3774px"
	
></p>
<p><strong>优先级的极值问题：</strong></p>
<p><code>renice -n -100 -p 3092</code></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926190322281.png"
	width="1152"
	height="104"
	
	loading="lazy"
	
		alt="image-20250926190322281"
	
	
		class="gallery-image" 
		data-flex-grow="1107"
		data-flex-basis="2658px"
	
></p>
<p><code>renice -n 100 -p 3092</code></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926190443658.png"
	width="1256"
	height="117"
	
	loading="lazy"
	
		alt="image-20250926190443658"
	
	
		class="gallery-image" 
		data-flex-grow="1073"
		data-flex-basis="2576px"
	
></p>
<p><span style="color: #8080FF;">nice值的范围是[-10, 19]</span></p>
<p><span style="color: #FFA8FF;">进程优先级PRI默认是：80</span></p>
<p><span style="color: #FF8000;">Linux进程的优先级范围 [60, 99]</span></p>
<blockquote>
<p>因为进程调度要考虑公平性</p>
</blockquote>
<p>进程优先级设立不合理，会导致优先级低的进程，长时间得不到CPU资源，进而导致：进程饥饿</p>
<h3 id="644补充-进程四个特征">6.4.4补充: 进程四个特征
</h3><ul>
<li>
<p>由于CPU资源是有限的，所以各个进程之间是具有<strong>竞争</strong>属性的</p>
</li>
<li>
<p>进程之间具有<strong>独立性</strong></p>
<p><code>进程=内核数据结构(task_struct)+代码和数据</code></p>
<p>每个进程都有自己独立的 task_struct，每个进程都有自己的代码和数据</p>
</li>
<li>
<p><strong>并行</strong>：多个进程在<span style="color: #8080FF;">多个CPU</span>下分别，同时进行运行</p>
</li>
<li>
<p><strong>并发</strong>：多个进程在<span style="color: #8080FF;">一个CPU</span>下采用<span style="color: #FF8000;">进程切换</span>的方式，在一段时间之内，让多个进程都得以推进</p>
</li>
</ul>
<blockquote>
<p>cat /proc/cpuinfo</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926192734748.png"
	width="999"
	height="664"
	
	loading="lazy"
	
		alt="image-20250926192734748"
	
	
		class="gallery-image" 
		data-flex-grow="150"
		data-flex-basis="361px"
	
></p>
<h2 id="15进程切换">1.5进程切换
</h2><h3 id="651死循环进程如何运行">6.5.1死循环进程如何运行
</h3><p>a. 一旦一个进程占有CPU，会把自己的代码跑完吗？</p>
<p>​	不会，对于每一个进程，系统都会给它分配一个叫时间片的东西</p>
<p>b. 死循环进程，不会打死系统，不会一直占有CPU</p>
<h3 id="652cpu寄存器">6.5.2CPU，寄存器
</h3><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926194032755.png"
	width="788"
	height="547"
	
	loading="lazy"
	
		alt="image-20250926194032755"
	
	
		class="gallery-image" 
		data-flex-grow="144"
		data-flex-basis="345px"
	
></p>
<p><strong>结论：</strong></p>
<ol>
<li>
<p>寄存器就是CPU内部的临时空间</p>
</li>
<li>
<p>寄存器 != 寄存器里面的数据</p>
</li>
</ol>
<p>​		寄存器是空间，寄存器里面的数据是内容！</p>
<p>​		<span style="color: #8080FF;">空间只有1份，内容是变化的，多份的</span></p>
<h3 id="653进程是如何切换的">6.5.3进程是如何切换的？
</h3><p><strong>a. 故事</strong></p>
<ol>
<li>
<p>当兵？保留学籍—&gt;当兵—&gt;恢复学籍</p>
<p>保留学籍的目的就是为了恢复学籍</p>
</li>
</ol>
<p>​	<img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926195258392.png"
	width="981"
	height="208"
	
	loading="lazy"
	
		alt="image-20250926195258392"
	
	
		class="gallery-image" 
		data-flex-grow="471"
		data-flex-basis="1131px"
	
></p>
<p><strong>b. 具体</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926195757264.png"
	width="1218"
	height="536"
	
	loading="lazy"
	
		alt="image-20250926195757264"
	
	
		class="gallery-image" 
		data-flex-grow="227"
		data-flex-basis="545px"
	
></p>
<p>进程切换，最核心的就是保存和恢复当前进程的硬件上下文的数据，即CPU内寄存器的内容！</p>
<p><strong>1.当前进程要把自己的进程硬件上下文数据，保存起来。保存到哪里了呢？</strong></p>
<p>保存到进程的task_struc里面</p>
<p>当代计算机给每个进程一个 TSS：任务状态段，能直接通过task_struct找到TSS</p>
<p>​	<img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250926201513761.png"
	width="1351"
	height="579"
	
	loading="lazy"
	
		alt="image-20250926201513761"
	
	
		class="gallery-image" 
		data-flex-grow="233"
		data-flex-basis="560px"
	
></p>
<p><strong>2.全新的进程vs已经调度过的进程</strong></p>
<p>可以理解成在task_struct里面再新增一个标记位，比如int isRunning ，进程没有运行就是0，只要一开始调度就直接置为1</p>
<blockquote>
<p>时间片：当代计算机都是分时操作系统，没有进程都有它合适的时间片（其实就是一个计数器)。时间片到达，进程就被操作系统从CPU中剥离下来。</p>
<p>struct task_struct* current 记录当前进程结构指针变量</p>
</blockquote>
<h2 id="16linux26内核进程o调度队列">1.6Linux2.6内核进程O(1)调度队列
</h2><p><span style="color: #FF8000;">调度</span>和<span style="color: #FF8000;">切换</span>共同构成了<span style="color: #8080FF;">调度器</span>，调度器的作用：1.切换 2.选择进程</p>
<blockquote>
<p>也就是先把当前进程保存下来，再在系统中选择一个进程，把这个进程放上来</p>
</blockquote>
<p><strong>Linux真实调度算法：</strong></p>
<p>一个CPU，一个运行队列（两个CPU，两个运行队列&hellip;）</p>
<p><strong>Linux的优先级有140个：</strong></p>
<ul>
<li>[0,99] 100个是实时优先级，我们不考虑</li>
</ul>
<blockquote>
<p><strong>操作系统分为两大类：</strong></p>
<ol>
<li>
<p>分时操作系统：按照时间片公平调度</p>
<p>现在很多操作系统都支持内核优先级抢占</p>
</li>
<li>
<p>实时操作系统：一旦来了一个进程，就必须实时响应，处理完才能处理下一个进程</p>
<p>实时操作系统一般应用在工业、制造&hellip;等领域，例子：车载操作系统</p>
</li>
</ol>
</blockquote>
<ul>
<li>普通优先级：[100,139]</li>
</ul>
<h3 id="活动队列">活动队列
</h3><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20250930211016217.png"
	width="1814"
	height="778"
	
	loading="lazy"
	
		alt="image-20250930211016217"
	
	
		class="gallery-image" 
		data-flex-grow="233"
		data-flex-basis="559px"
	
></p>
<p>Linux进程的优先级范围 [60, 99]，在队列中的位置：x-60+(140-40)</p>
<p>宏观上看优先级，优先级相同的，先进先出</p>
<p><strong>调度器如何快速地挑选一个进程？</strong></p>
<p>unsigned int bitmap[5] 位图 ——&gt; 32 * 5 = 160</p>
<p>比特位的位置和queue[140]的位置是一一对应的</p>
<p>比特位的内容：1或0，表示是否存在进程</p>
<p><strong>调度器挑选一个进程：1.挑队列 2.挑进程</strong></p>
<p>调度器挑队列只需要查看对应的位图</p>
<p>nr_active: 总共有多少个运行状态的进程</p>
<p>所以调度的时候先查nr_active，大于0，再查bitmap，确认下标直接索引找到目标队列，从队列头部提取内容，pop_front，把对应节点拿出来，把PCB放入到current指针里，然后执行切换算法，然后让current指向的进程放到CPU上就可以运行了</p>
<h3 id="过期队列">过期队列
</h3><p><strong>active指针和expired指针</strong></p>
<ul>
<li>active指针永远指向活动队列</li>
<li>expired指针永远指向过期队列</li>
<li>活动队列上的进程调用完之后，交换active指针和expired指针的内容</li>
</ul>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251002100314694.png"
	width="758"
	height="163"
	
	loading="lazy"
	
		alt="image-20251002100314694"
	
	
		class="gallery-image" 
		data-flex-grow="465"
		data-flex-basis="1116px"
	
></p>
<h3 id="总结-1">总结
</h3><p>在系统当中查找一个最合适调度的进程的时间复杂度是一个常数，不随着进程增多而导致时间成
本增加，我们称之为进程调度0(1)算法</p>
<h1 id="二环境变量">二、环境变量
</h1><h2 id="1-引出环境变量">1. 引出环境变量
</h2><blockquote>
<p>环境变量的概念</p>
<ul>
<li>
<p>环境变量一般是指在操作系统中用来<span style="color: #8080FF;">指定操作系统运行环境的一些参数</span></p>
<blockquote>
<p>这些参数未来被bash用，bash用了就是用户间接用了</p>
</blockquote>
</li>
<li>
<p>如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。</p>
</li>
<li>
<p>环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性</p>
</li>
</ul>
</blockquote>
<h3 id="11命令行参数">1.1命令行参数
</h3><p>main函数是有参数的，argv是一个指针数组，argc代表数组中的元素个数</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251002103755642.png"
	width="772"
	height="410"
	
	loading="lazy"
	
		alt="image-20251002103755642"
	
	
		class="gallery-image" 
		data-flex-grow="188"
		data-flex-basis="451px"
	
></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732168789744.png"
	width="750"
	height="189"
	
	loading="lazy"
	
		alt="73216878974"
	
	
		class="gallery-image" 
		data-flex-grow="396"
		data-flex-basis="952px"
	
></p>
<p>当我们在命令行输入一个./code 或以空格作为分隔符，其实输入的就是一个长字符串。而当我们在执行某一个C语言程序时，这些字符串会以空格为分隔符切分</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251002104416560.png"
	width="445"
	height="360"
	
	loading="lazy"
	
		alt="image-20251002104416560"
	
	
		class="gallery-image" 
		data-flex-grow="123"
		data-flex-basis="296px"
	
></p>
<p>我们平时用的命令本质上就是可执行程序，基本上都是用C语言写的，我们可以给命令后面带很多选项</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732168971833.png"
	width="1330"
	height="232"
	
	loading="lazy"
	
		alt="73216897183"
	
	
		class="gallery-image" 
		data-flex-grow="573"
		data-flex-basis="1375px"
	
></p>
<p><strong><mark>main函数的命令行参数，是实现程序不同子功能的方法（指令带选项）</mark></strong></p>
<blockquote>
<p>我们在命令行输入带选项的命令，本质上是字符串，被bash切分</p>
</blockquote>
<p>进程拥有一张表，argv表，用来支持实现选项功能</p>
<h3 id="12环境变量与命令查找">1.2环境变量与命令查找
</h3><ul>
<li><strong>要执行一个程序，必须先找到它，谁找？bash找，通过PATH(环境变量)找</strong></li>
<li>执行我们自己写的程序，需要带./ 表示在当前路径下，但是为什么执行系统指令不需要带<code>./</code>呢？
<ul>
<li>系统中存在环境变量<code>PATH</code>，来帮助系统找到目标二进制文件</li>
</ul>
</li>
</ul>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251002110747633.png"
	width="1156"
	height="536"
	
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="215"
		data-flex-basis="517px"
	
></p>
<blockquote>
<p>我们把自己写的二进制文件拷贝到 /usr/bin 路径下之后，也可以不带路径，直接执行<img src="/p/linux-process-basic/index.assets/image-20251110085644158.png"
	width="1059"
	height="149"
	
	loading="lazy"
	
		alt="image-20251110085644158"
	
	
		class="gallery-image" 
		data-flex-grow="710"
		data-flex-basis="1705px"
	
></p>
<p>但是不建议这样做，因为我们自己写的二进制文件可能有bug，会污染系统本来的指令池</p>
<p>移除我们拷贝到/usr/bin路径下的二进制文件：</p>
<p><img src="/p/linux-process-basic/index.assets/image-20251110090107289.png"
	width="1015"
	height="79"
	
	loading="lazy"
	
		alt="image-20251110090107289"
	
	
		class="gallery-image" 
		data-flex-grow="1284"
		data-flex-basis="3083px"
	
></p>
</blockquote>
<h2 id="2查看新增环境变量">2.查看、新增环境变量
</h2><h3 id="21显示系统中所有环境变量">2.1显示系统中所有环境变量
</h3><p><code>env</code></p>
<p><img src="/p/linux-process-basic/index.assets/image-20251110095002756.png"
	width="1095"
	height="408"
	
	loading="lazy"
	
		alt="image-20251110095002756"
	
	
		class="gallery-image" 
		data-flex-grow="268"
		data-flex-basis="644px"
	
></p>
<h3 id="22查看某一个环境变量的内容">2.2查看某一个环境变量的内容
</h3><p><code>echo $某一个环境变量的名字</code></p>
<p>例如查看环境变量PATH的内容：echo $PATH</p>
<p><img src="/p/linux-process-basic/index.assets/1732017140374.png"
	width="1489"
	height="87"
	
	loading="lazy"
	
		alt="73201714037"
	
	
		class="gallery-image" 
		data-flex-grow="1711"
		data-flex-basis="4107px"
	
></p>
<h3 id="23path环境变量">2.3PATH环境变量
</h3><p>PATH环境变量里记录了多个路径，这些路径之间以冒号作为分隔符</p>
<p>当系统在搜索某些命令/二进制文件时，默认会按顺序依次在这些路径下查找：</p>
<ol>
<li>先在第一个路径下找，如果找到就执行</li>
<li>如果没有找到，就到下一个路径找</li>
<li>如果所有路径都没找到，就报Command not found</li>
</ol>
<blockquote>
<p>比如当我们要执行 ls 命令时，系统默认会去查环境变量PATH，从环境变量PATH中的第一个路径<code>/usr/local/bin</code>下开始找，如果没有找到，就到第二个路径 <code>/usr/bin</code>路径下去找，以此类推，直到遍历完所有路径。如果没有找到，就报 Command not found；如果找到了，就执行该命令</p>
<p><img src="/p/linux-process-basic/index.assets/image-20251110101617053.png"
	width="1519"
	height="125"
	
	loading="lazy"
	
		alt="image-20251110101617053"
	
	
		class="gallery-image" 
		data-flex-grow="1215"
		data-flex-basis="2916px"
	
></p>
</blockquote>
<p>所以，如果我们想要<strong>不带路径，直接运行自己写的二进制文件</strong>，就有两种方法了</p>
<p><strong>方法1：</strong> 将我们的二进制文件拷贝到PATH环境变量里的路径下</p>
<blockquote>
<p>比如我们把自己写的二进制文件拷贝到 /usr/bin 路径下之后，可以不带路径，直接执行</p>
</blockquote>
<p><strong>方法2：</strong> 把我们自己二进制文件所在的路径添加到环境变量PATH</p>
<ul>
<li>
<p>直接覆盖添加环境变量：<code>PATH=路径</code><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732408110926.png"
	width="1131"
	height="123"
	
	loading="lazy"
	
		alt="73240811092"
	
	
		class="gallery-image" 
		data-flex-grow="919"
		data-flex-basis="2206px"
	
></p>
<p>这种方式会覆盖原有的PATH，导致系统命令无法使用，不推荐</p>
</li>
<li>
<p>不覆盖添加环境变量：<code>PATH=$PATH:要添加的路径</code></p>
<p><img src="/p/linux-process-basic/index.assets/image-20251110105122981.png"
	width="2098"
	height="346"
	
	loading="lazy"
	
		alt="image-20251110105122981"
	
	
		class="gallery-image" 
		data-flex-grow="606"
		data-flex-basis="1455px"
	
></p>
<p>这种方式会将新路径追加到原PATH末尾，不影响系统原有命令</p>
</li>
</ul>
<p>注意：以上两种方式只是临时生效，关闭终端重新登录后会失效。</p>
<h3 id="24设置一个新的环境变量">2.4设置一个新的环境变量
</h3><p>设置一个新的环境变量</p>
<ul>
<li><strong>export 环境变量名=值</strong></li>
<li><strong>export 环境变量名</strong></li>
</ul>
<p>取消一个环境变量</p>
<ul>
<li><strong>unset 环境变量名</strong></li>
</ul>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251008193603976.png"
	width="1076"
	height="156"
	
	loading="lazy"
	
		alt="image-20251008193603976"
	
	
		class="gallery-image" 
		data-flex-grow="689"
		data-flex-basis="1655px"
	
></p>
<h2 id="2环境变量的理解">2.环境变量的理解
</h2><h3 id="21如何理解环境变量">2.1如何理解环境变量
</h3><p><strong>如何理解环境变量(存储的角度)？环境变量的值是被bash保存起来的，由bash来执行这些命令</strong></p>
<p>当我们登录系统时，系统会创建一个bash进程，bash会从配置文件中读取所有环境变量信息，并在其内部构建一张环境变量表</p>
<p>环境变量表其实就是一个<strong>指针数组</strong>，数组中的每个元素都指向一个<strong>key-value形式的长字符串</strong>，我们使用 <code>env</code> 命令看到的所有环境变量，都存储在这张表中</p>
<p><img src="/p/linux-process-basic/index.assets/1732016086077.png"
	width="912"
	height="396"
	
	loading="lazy"
	
		alt="73201608607"
	
	
		class="gallery-image" 
		data-flex-grow="230"
		data-flex-basis="552px"
	
></p>
<p><strong>bash进程在运行时，内部维护着两张表：命令行参数表和环境变量表</strong></p>
<ul>
<li>环境变量表：启动时从配置文件读取构建，存储所有环境变量（如PATH、HOME等</li>
<li>命令行参数表：每次执行命令时动态构建，存储当前命令的程序名和参数</li>
</ul>
<p><strong>bash执行命令的流程</strong></p>
<blockquote>
<p>bash进程在启动时，会从配置文件中读取环境变量信息，并在内部构建环境变量表。</p>
<p>当用户输入命令（如 ls -a）时</p>
<ol>
<li>
<p>bash首先接收这个字符串，然后按空格将其拆分成程序名和参数，构建出命令行参数表。</p>
</li>
<li>
<p>接下来，bash从环境变量表中取出PATH，按照PATH中的路径顺序依次查找：</p>
<ol>
<li>将每个路径与程序名拼接（如 /usr/bin/ls），检查该位置是否存在可执行文件</li>
<li>如果找到了，bash就使用 fork() 创建子进程来执行该程序，并将命令行参数表传递给子进程</li>
<li>如果所有路径都查找完还没找到，就报错 Command not found</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="22环境变量从哪来">2.2环境变量从哪来？
</h3><p><strong>环境变量最开始从哪里来的呢？是从系统的相关配置文件中来的</strong></p>
<p>系统给每一个用户的家目录里存在两个隐藏文件，一个是.bash_profile，一个是.bashrc</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251002113547303.png"
	width="1329"
	height="1088"
	
	loading="lazy"
	
		alt="image-20251002113547303"
	
	
		class="gallery-image" 
		data-flex-grow="122"
		data-flex-basis="293px"
	
></p>
<blockquote>
<p>.bash_profile要求用户去加载.bashrc，而.bashrc 会要求用户去加载 /etc/bashrc</p>
</blockquote>
<p>当我们登录系统时，系统会创建一个bash进程，bash会从配置文件（.bashrc 和 .bash_profile）中读取所有环境变量信息，并在其内部构建一张环境变量表。</p>
<p>如果我们把自己二进制文件的路径添加到配置文件中，那么每次登录，我们的二进制文件都可以直接运行，这样就永久有效了</p>
<p><img src="/p/linux-process-basic/index.assets/image-20251110182338580.png"
	width="1253"
	height="544"
	
	loading="lazy"
	
		alt="image-20251110182338580"
	
	
		class="gallery-image" 
		data-flex-grow="230"
		data-flex-basis="552px"
	
></p>
<p>如果Linux系统中有10个用户登录，就有10个bash，这10个bash进程都要从对应的配置文件中读到bash自己的上下文里，所以每一个bash都有存在两张表，命令行参数表和环境变量表</p>
<h2 id="3常见环境变量">3.常见环境变量
</h2><p><img src="/p/linux-process-basic/index.assets/image-20251110191545964.png"
	width="1239"
	height="1219"
	
	loading="lazy"
	
		alt="image-20251110191545964"
	
	
		class="gallery-image" 
		data-flex-grow="101"
		data-flex-basis="243px"
	
></p>
<ul>
<li>
<p><strong><code>HOME</code> 环境变量表示当前用户所对应的家目录</strong></p>
<blockquote>
<p>这就是为什么我们输入 <code>cd ~</code> 就能切换到当前用户的家目录的原因</p>
</blockquote>
</li>
<li>
<p><strong><code>SHELL</code> 环境变量表示用户在登录时用的是哪一个版本的shell，它的值通常是/bin/bash</strong></p>
</li>
<li>
<p><strong><code>LOGNAME</code> 环境变量表示当前登录用户是谁</strong></p>
<blockquote>
<p>这就是为什么我们输入 <code>whoami</code> 就能知道正在登录的用户是谁的原因</p>
</blockquote>
</li>
<li>
<p><strong><code>USER</code> 环境变量表示当前用户是谁</strong></p>
<p><code>su</code> 切换用户，不会改变 LOGNAME 和 USER 的值</p>
<p><code>su 用户名</code> 切换成普通用户，会改变 LOGNAME 和 USER 的值，切换成root不会改</p>
<p><code>su -</code>  才能让LOGNAME 和 USER 的值 改成root，<code>su -</code>是让root用户重新登录</p>
</li>
<li>
<p><strong>Linux会记录最新的 <code>HISTSIZE</code> 条历史命令</strong></p>
<blockquote>
<p>这就是为什么我们<code>ctrl+r</code>可以查到历史输入的命令的原因</p>
</blockquote>
</li>
<li>
<p><strong><code>PWD</code>记录当前的工作路径</strong></p>
</li>
<li>
<p><strong><code>OLDPWD</code> 环境变量记录了上一次的路径</strong></p>
<blockquote>
<p>这就是为什么我们<code>cd -</code> 的时候可以回到上一次的路径下的原因</p>
</blockquote>
</li>
<li>
<p><strong><code>HOSTNAME</code>环境变量表示当前主机的主机名</strong></p>
</li>
<li>
<p><strong><code>SSH_CONNECTION</code>表示当前是从哪个客户端登录的</strong></p>
</li>
<li>
<p><strong><code>SSH_TTY</code>表示当前是哪一个设备</strong></p>
</li>
</ul>
<h2 id="4获取环境变量">4.获取环境变量
</h2><h4 id="方法1main函数参数">方法1：main函数参数
</h4><p><strong>main函数最多有3个参数，命令行参数表argv和环境变量表env都是父进程传递给我们的</strong></p>
<p><img src="/p/linux-process-basic/index.assets/image-20251110194012735.png"
	width="975"
	height="675"
	
	loading="lazy"
	
		alt="image-20251110194012735"
	
	
		class="gallery-image" 
		data-flex-grow="144"
		data-flex-basis="346px"
	
></p>
<blockquote>
<p>我们自己的可执行程序的入口不是main函数，Linux中的入口函数是start函数</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251008195652093.png"
	width="325"
	height="390"
	
	loading="lazy"
	
		alt="image-20251008195652093"
	
	
		class="gallery-image" 
		data-flex-grow="83"
		data-flex-basis="200px"
	
></p>
</blockquote>
<p>我们自己export设置的环境变量是可以被子进程拿到的——&gt;</p>
<ul>
<li>
<p><strong>环境变量可以被子进程继承</strong></p>
</li>
<li>
<p><strong>环境变量在系统中通常具有全局特性</strong></p>
</li>
</ul>
<h4 id="方法2getenv">方法2(推荐)：getenv
</h4><p><code>getenv</code> 会根据环境变量的名字获取环境变量的内容</p>
<p>如果获取成功了，就返回环境变量内容字符串的起始地址，否则就返回NULL</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732020219265.png"
	width="1376"
	height="669"
	
	loading="lazy"
	
		alt="73202021926"
	
	
		class="gallery-image" 
		data-flex-grow="205"
		data-flex-basis="493px"
	
></p>
<p><strong>例子1：通过getenv获取环境变量PATH里的内容</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//main最多可以有3个参数，是父进程传递给我们的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span><span class="o">*</span> <span class="n">env</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">env</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span><span class="o">*</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">getenv</span><span class="p">(</span><span class="s">&#34;PATH&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;PATH-&gt;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/index.assets/image-20251110195536569.png"
	width="1453"
	height="119"
	
	loading="lazy"
	
		alt="image-20251110195536569"
	
	
		class="gallery-image" 
		data-flex-grow="1221"
		data-flex-basis="2930px"
	
></p>
<p><strong>例子2：写一个程序，只有我自己可以用</strong></p>
<blockquote>
<p>整个系统中，只有bash知道登录用户是谁</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//main有参数吗？有
</span></span></span><span class="line"><span class="cl"><span class="c1">//最多可以有几个？3个
</span></span></span><span class="line"><span class="cl"><span class="c1">//是父进程传递给我们的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span><span class="o">*</span> <span class="n">env</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">env</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">who</span> <span class="o">=</span> <span class="nf">getenv</span><span class="p">(</span><span class="s">&#34;USER&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">who</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">who</span><span class="p">,</span> <span class="s">&#34;zhangsan&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">     	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;这是程序的正常执行逻辑</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;只有zhangsan可以执行</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="方法3environ">方法3：environ
</h4><p>全局变量 environ</p>
<p><img src="/p/linux-process-basic/index.assets/image-20251110200508365.png"
	width="1249"
	height="386"
	
	loading="lazy"
	
		alt="image-20251110200508365"
	
	
		class="gallery-image" 
		data-flex-grow="323"
		data-flex-basis="776px"
	
></p>
<p>为什么environ的类型是char**的？因为环境变量表是 char* []类型的</p>
<p><img src="/p/linux-process-basic/index.assets/image-20251008210301372.png"
	width="984"
	height="261"
	
	loading="lazy"
	
		alt="image-20251008210301372"
	
	
		class="gallery-image" 
		data-flex-grow="377"
		data-flex-basis="904px"
	
></p>
<p>例子：使用environ查看环境变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"> <span class="k">extern</span> <span class="kt">char</span><span class="o">**</span> <span class="n">environ</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">     <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="err">θ</span><span class="p">;</span> <span class="n">environ</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;env[%d]-&gt; %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="err">，</span> <span class="n">i</span><span class="p">,</span> <span class="n">environ</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="5本地变量与环境变量">5.本地变量与环境变量
</h2><p><strong>环境变量具有全局特性</strong></p>
<p><strong>本地变量</strong></p>
<p>在命令行定义本地变量</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/1732021018651.png"
	width="672"
	height="110"
	
	loading="lazy"
	
		alt="73202101865"
	
	
		class="gallery-image" 
		data-flex-grow="610"
		data-flex-basis="1466px"
	
></p>
<blockquote>
<p>取消本地变量也是 unset 变量名</p>
</blockquote>
<ul>
<li>
<p>显示本地定义的shell变量和环境变量：<code>set</code></p>
</li>
<li>
<p><strong>bash会记录两套变量：1.环境变量 2.本地变量</strong></p>
</li>
</ul>
<ul>
<li><strong>本地变量不会被子进程继承，只在bash内部被使用</strong></li>
</ul>
<p><img src="/p/linux-process-basic/index.assets/image-20251112143458089.png"
	width="1534"
	height="449"
	
	loading="lazy"
	
		alt="image-20251112143458089"
	
	
		class="gallery-image" 
		data-flex-grow="341"
		data-flex-basis="819px"
	
></p>
<blockquote>
<p>为什么要有本地变量？bash内部自己要用</p>
<p>比如bash要记录下命令行提示符的格式</p>
<p><img src="/p/linux-process-basic/index.assets/image-20251112143753496.png"
	width="317"
	height="113"
	
	loading="lazy"
	
		alt="image-20251112143753496"
	
	
		class="gallery-image" 
		data-flex-grow="280"
		data-flex-basis="673px"
	
></p>
</blockquote>
<p><strong>我们的环境变量在谁里面？bash</strong></p>
<p>像export这种命令，我们叫做 <code>内建命令</code>，内建命令在执行时不需要创建子进程，而是bash自己亲自执行</p>
<blockquote>
<p>bash自己调函数，或者系统调用完成</p>
</blockquote>
<h2 id="6-进程地址空间初识">6. 进程地址空间初识
</h2><p><strong>程序地址空间</strong></p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012162604220.png"
	width="2236"
	height="787"
	
	loading="lazy"
	
		alt="image-20251012162604220"
	
	
		class="gallery-image" 
		data-flex-grow="284"
		data-flex-basis="681px"
	
></p>
<blockquote>
<p>我们平时定义的字符串其实是被硬编码到代码的。因为代码是只读的，所以string常量也是只读的</p>
</blockquote>
<p>程序地址空间不是内存。</p>
<p>程序地址空间应该叫进程地址空间（虚拟地址空间），是一个系统概念，不是语言层的概念</p>
<p><strong>虚拟地址</strong></p>
<p>子进程和父进程都会读取全局变量，但是只有子进程修改了这个变量，子进程修改了这个变量，父进程能看到吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">gval</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">id</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;子: gaval:%d, &amp;gval: %p, pid:%d, ppid: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">gval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gval</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">(),</span> <span class="nf">getppid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">gval</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;父gaval: %d, &amp;gval: %p, pid: %d, ppid: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">gval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gval</span><span class="p">,</span> <span class="n">getpidC</span><span class="p">),</span> <span class="nf">getppid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">				<span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012164134701.png"
	width="906"
	height="422"
	
	loading="lazy"
	
		alt="image-20251012164134701"
	
	
		class="gallery-image" 
		data-flex-grow="214"
		data-flex-basis="515px"
	
></p>
<p>父子进程中全局变量gval的地址一样，但是父子进程读出的值不同！</p>
<blockquote>
<ul>
<li>父子进程输出的变量不是同一个变量</li>
<li>该地址不是物理地址</li>
<li>在Linux地址下，这种地址叫做 虚拟地址</li>
</ul>
</blockquote>
<p><strong>C/C++指针用到的地址，全部都是虚拟地址</strong></p>
<h1 id="三进程地址空间">三、进程地址空间
</h1><h2 id="1引入新概念">1.引入新概念
</h2><p>虚拟地址空间不是物理内存</p>
<h3 id="11-一个进程一个虚拟地址空间">1.1 一个进程，一个虚拟地址空间
</h3><p>创建进程时，要有对应的task_struct来描述进程，而每一个task_struct最终都要对应一个虚拟地址空间</p>
<ul>
<li>
<p>虚拟地址</p>
<ul>
<li>虚拟地址空间对应的宽度单位是1字节</li>
<li>在32位机器下，虚拟地址空间的范围是2^32^个地址 * 1字节 = 能表示的总的地址空间的容量是4GB
<ul>
<li>0<del>3GB 叫用户空间，3</del>4GB 叫内核空间</li>
</ul>
</li>
<li>在64位机器下，虚拟地址空间的范围是2^64^个地址</li>
</ul>
</li>
<li>
<p>用户空间和内核空间</p>
<ul>
<li>用户空间，用户拿到地址就可以直接访问该空间</li>
</ul>
</li>
</ul>
<h3 id="12一个进程一套页表">1.2一个进程，一套页表
</h3><p>我们定义一个变量，该变量一定存放在内存中，同时，在虚拟地址空间上也要有对应的这个变量</p>
<p>也就是任何一个变量，在内存中存在一个<span style="color: #8080FF;">物理地址</span>，在虚拟地址空间上存在一个<span style="color: #8080FF;">虚拟地址</span>，并且操作系统在每一个进程创建的时候，要为其构建一张页表</p>
<h3 id="13页表是用来做虚拟地址和物理地址映射的">1.3页表是用来做虚拟地址和物理地址映射的
</h3><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012201210602.png"
	width="1310"
	height="539"
	
	loading="lazy"
	
		alt="image-20251012201210602"
	
	
		class="gallery-image" 
		data-flex-grow="243"
		data-flex-basis="583px"
	
></p>
<p>一个进程，一套页表  =&gt; 子进程也有自己的虚拟地址空间和页表</p>
<p>子进程的task_struct是拷贝的父进程的，虚拟地址空间、页表也是拷贝的父进程的（浅拷贝）</p>
<blockquote>
<p>父子进程默认代码共享，数据共享</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012174051549.png"
	width="1116"
	height="703"
	
	loading="lazy"
	
		alt="image-20251012174051549"
	
	
		class="gallery-image" 
		data-flex-grow="158"
		data-flex-basis="380px"
	
></p>
<p><strong>子进程对变量要进行修改？写时拷贝</strong></p>
<p>进程具有独立性，当父子进程中任何一方要对变量做修改时，都会新开一块空间做修改，并将页表中虚拟地址映射到的物理地址修改成新开的那块空间的物理地址，而虚拟地址不变。</p>
<p>因此，之所以父子进程访问同一个变量时地址相同，是因为拿到的都是虚拟地址，内容不同，是因为虚拟地址底层映射到了不同的物理地址</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012182658120.png"
	width="1897"
	height="751"
	
	loading="lazy"
	
		alt="image-20251012182658120"
	
	
		class="gallery-image" 
		data-flex-grow="252"
		data-flex-basis="606px"
	
></p>
<h2 id="2虚拟地址与进程地址空间">2.虚拟地址与进程地址空间
</h2><h3 id="21虚拟地址空间是什么">2.1虚拟地址空间是什么？
</h3><p>操作系统让每一个进程都认为自己有4GB的物理内存（每一个进程都认为自己在独占物理内存），操作系统需要管理虚拟地址空间。<strong>虚拟地址空间本质是一个数据结构（结构体）</strong></p>
<p>描述Linux下进程的地址空间的所有信息的结构体是<code>mm_struct</code>(内存描述符)。<strong>每个进程只有一个mm_struct，在每个进程的task_struct结构体中，有一个指向该进程的结构</strong></p>
<blockquote>
<p>可以说 mm_struct 结构是对整个用户空间的描述。<strong>每一个进程都会有自己独立的mm_struct</strong>，这样每一个进程都会有自己独立的地址空间才能互不干扰。</p>
</blockquote>
<p><img src="/p/linux-process-basic/index.assets/image-20251114230535125.png"
	width="1113"
	height="426"
	
	loading="lazy"
	
		alt="image-20251114230535125"
	
	
		class="gallery-image" 
		data-flex-grow="261"
		data-flex-basis="627px"
	
></p>
<h3 id="22如何描述虚拟地址空间">2.2如何描述虚拟地址空间
</h3><p>区域划分——&gt;只需要确认区域的开始和结束即可</p>
<blockquote>
<p>操作系统对于进程的虚拟地址空间要做管理，<strong>虚拟地址空间是内核的一种结构体</strong>，<strong>这个结构体里的大部分属性都是各个区域的开始、结束</strong></p>
</blockquote>
<p>调整区域——&gt;只需要对整数变量进行加或减</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">mm_struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_vm</span><span class="p">,</span> <span class="n">locked_vm</span><span class="p">,</span> <span class="n">shared_vm</span><span class="p">,</span> <span class="n">exec_vm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_vm</span><span class="p">,</span> <span class="n">reserved_vm</span><span class="p">,</span> <span class="n">def_flags</span><span class="p">,</span> <span class="n">nr_ptes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">,</span> <span class="n">end_code</span><span class="p">,</span> <span class="n">start_data</span><span class="p">,</span> <span class="n">end_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_brk</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">start_stack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg_start</span><span class="p">,</span> <span class="n">arg_end</span><span class="p">,</span> <span class="n">env_start</span><span class="p">,</span> <span class="n">env_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/index.assets/image-20251012190721903.png"
	width="1586"
	height="550"
	
	loading="lazy"
	
		alt="image-20251012190721903"
	
	
		class="gallery-image" 
		data-flex-grow="288"
		data-flex-basis="692px"
	
></p>
<p>要把一个程序加载到内存需要做三件事：</p>
<ol>
<li>
<p>在虚拟地址空间中申请指定大小的空间</p>
</li>
<li>
<p>加载程序，申请物理空间</p>
</li>
<li>
<p>页表映射</p>
</li>
</ol>
<p><img src="/p/linux-process-basic/index.assets/image-20251012192401762.png"
	width="1643"
	height="760"
	
	loading="lazy"
	
		alt="image-20251012192401762"
	
	
		class="gallery-image" 
		data-flex-grow="216"
		data-flex-basis="518px"
	
></p>
<p>物理地址转化成为虚拟地址，虚拟地址提供给上层用户使用</p>
<h3 id="23为什么要有进程地址空间">2.3为什么要有进程地址空间
</h3><p><strong>1.将地址从无序变有序</strong></p>
<p>可执行程序未来可以加载到物理内存的任意位置，通过页表的映射关系把无序的物理地址变有序（虚拟地址空间）</p>
<p><strong>2.转化过程中，也可以对你的地址和操作进行合法性判定，进而保护物理内存</strong></p>
<p>页表里面除了保存了物理地址和虚拟地址的映射关系，还有这个区域的权限</p>
<p>a. 什么是野指针</p>
<p>b. char* str = &ldquo;hello world&rdquo;; str = &ldquo;H&rdquo;</p>
<p><span style="color: #8080FF;">为什么在字符常量区写入，就会崩溃？查找页表的时候，权限拦截了</span></p>
<p><strong>3.让进程管理和内存管理，进行一定程度的解耦合</strong></p>
<p>缺页中断（虚拟地址申请的空间不会一次性分配物理内存，仅在实际使用对应部分时，才动态向物理空间申请）</p>
<p>在创建一个进程时，可以只创建PCB、地址空间和页表，先把虚拟地址空间初始化，不加载数据，只需要知道可执行程序代码多大、数据多大&hellip;</p>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012200018226.png"
	width="1662"
	height="879"
	
	loading="lazy"
	
		alt="image-20251012200018226"
	
	
		class="gallery-image" 
		data-flex-grow="189"
		data-flex-basis="453px"
	
></p>
<h3 id="总结-2">总结
</h3><p><strong>1.我们可以不加载代码和数据，只有task_struct, mm_struct，页表</strong></p>
<p><strong>2.创建进程，先有task_struct, mm_struct等，还是先加载代码和数据？</strong></p>
<p>先有内核数据结构，然后再加载代码和数据</p>
<p><strong>3.如何理解进程挂起？</strong></p>
<blockquote>
<p>当内存空间严重不足时，操作系统就会将这些在等待队列的进程置换到磁盘中的swap分区中（在等待队列中只存PCB，而<span style="color: #8080FF;">将对应的代码和数据唤出到swap分区中</span>，等这些进程要运行了，再把代码和数据还回去），这些进程的状态就叫阻塞挂起</p>
</blockquote>
<p>当系统内存严重不足时，操作系统会优先选择已处于阻塞状态（暂时无需占用CPU和物理内存运行）的进程进行处理。它会先查询该进程的页表，确认其虚拟地址已分配且对应着实际的物理内存（即虚拟地址与物理地址存在有效映射）；随后，将页表中该虚拟地址对应的物理内存里的进程代码、数据，完整换出到磁盘的swap分区暂存，并清空页表中该虚拟地址的物理地址映射（释放对应的物理内存空间）。 需要注意的是，挂起操作仅迁移了进程的代码和数据，进程的核心控制信息（PCB，进程控制块）依然保留在内存中——因此，这个进程在操作系统中并未消失，只是状态从“阻塞”变为了“阻塞挂起（s状态）”</p>
<h2 id="3地址空间的组织方式">3.地址空间的组织方式
</h2><p>堆区并不是只有一个起始虚拟地址。进程的虚拟地址空间中，除了有 mm_struct 结构，还存在 vm_area_struct 结构 —— 它是在 mm_struct 中构建的链表，会将堆区拆分为多个独立部分，而每个堆区部分都对应一个 vm_area_struct。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">vm_mm</span><span class="p">;</span>	<span class="cm">/* The address space we belong to. */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_start</span><span class="p">;</span>		<span class="cm">/* Our start address within vm_mm. */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_end</span><span class="p">;</span>		<span class="cm">/* The first byte after our end address
</span></span></span><span class="line"><span class="cl"><span class="cm">					   within vm_mm. */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012201039762.png"
	width="937"
	height="631"
	
	loading="lazy"
	
		alt="image-20251012201039762"
	
	
		class="gallery-image" 
		data-flex-grow="148"
		data-flex-basis="356px"
	
></p>
<blockquote>
<p>虚拟空间的组织方式有两种：</p>
<ol>
<li>当虚拟区较少时采取单链表，由mmap指针指向这个链表；</li>
<li>当虚拟区间多时采取红黑树进⾏管理，由mm_rb指向这棵树。</li>
</ol>
<p>linux内核使用 vm_area_struct 结构来表示一个独立的虚拟内存区域(VMA)，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。上面提到的两种组织方式使用的就是vm_area_struct结构来连接各个VMA，方便进程快速访问</p>
</blockquote>
<p><img src="/p/linux-process-basic/03%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.assets/image-20251012201058852.png"
	width="1140"
	height="770"
	
	loading="lazy"
	
		alt="image-20251012201058852"
	
	
		class="gallery-image" 
		data-flex-grow="148"
		data-flex-basis="355px"
	
></p>
<p>进程具有独立性：</p>
<ol>
<li><span style="color: #8080FF;">内核数据结构</span>独立</li>
<li>加载进入内存的<span style="color: #8080FF;">代码和数据</span>独立</li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/linux%E8%BF%9B%E9%98%B6/">Linux进阶</a>
        
            <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a>
        
            <a href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/">环境变量</a>
        
            <a href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/">地址空间</a>
        
    </section>


    
</footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/linux-interprocess-communication/">
        
        
            <div class="article-image">
                <img src="/p/linux-interprocess-communication/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%A4%95%E9%98%B3-%E6%8F%92%E7%94%BB-%E6%A2%A6%E5%B9%BB%E5%B0%8F%E5%B1%8B.c9fc95b3b458f211363640c957d64c3b_hu_be2653989c4bea76.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 【Linux系统编程】08进程间通信"
                        data-key="linux-interprocess-communication" 
                        data-hash="md5-yfyVs7RY8hE2NkDJV9ZMOw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【Linux系统编程】08进程间通信</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/linux-process-control/">
        
        
            <div class="article-image">
                <img src="/p/linux-process-control/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3.425192012b5ffa0b939bfaa25c31245b_hu_d59cb710464abe1b.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 【Linux系统编程】04进程控制"
                        data-key="linux-process-control" 
                        data-hash="md5-QlGSAStf&#43;guTm/qiXDEkWw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【Linux系统编程】04进程控制</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/linux-basic-io/">
        
        
            <div class="article-image">
                <img src="/p/linux-basic-io/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3.425192012b5ffa0b939bfaa25c31245b_hu_d59cb710464abe1b.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 【Linux系统编程】05基础IO"
                        data-key="linux-basic-io" 
                        data-hash="md5-QlGSAStf&#43;guTm/qiXDEkWw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【Linux系统编程】05基础IO</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/linux-thread/">
        
        
            <div class="article-image">
                <img src="/p/linux-thread/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%A4%95%E9%98%B3-%E6%8F%92%E7%94%BB-%E6%A2%A6%E5%B9%BB%E5%B0%8F%E5%B1%8B.c9fc95b3b458f211363640c957d64c3b_hu_be2653989c4bea76.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 【Linux系统编程】10线程概念与控制"
                        data-key="linux-thread" 
                        data-hash="md5-yfyVs7RY8hE2NkDJV9ZMOw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【Linux系统编程】10线程概念与控制</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/linux-basic-instruction/">
        
        
            <div class="article-image">
                <img src="/p/linux-basic-instruction/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3.425192012b5ffa0b939bfaa25c31245b_hu_d59cb710464abe1b.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 【Linux系统编程】01初始Linux&#43;基础指令"
                        data-key="linux-basic-instruction" 
                        data-hash="md5-QlGSAStf&#43;guTm/qiXDEkWw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">【Linux系统编程】01初始Linux&#43;基础指令</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 PursUnre
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.31.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.9c1a6570230d4822a0bae7b9729a4d803a1d6e81a2ebc4dbb042dd1c2902034a.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
