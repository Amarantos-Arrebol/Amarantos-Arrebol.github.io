[{"content":"[TOC]\n一、AI绘画学习 1.简单介绍 1.1原理 原理：将原图先增加噪声然后通过深度学习去除噪声并风格化重绘\n通过深度学习，领会不同图片或者某一类风格图片的特征\nAI绘画=AI图像生成\n1.2配置 配置：需要本地部署，独立显卡\n显卡影响出图效率，显存影响绘制图片分辨率和训练模型\n1.3 基本操作流程 1.提示词：\n可以使用翻译软件或网页\u0026ndash;网易有道翻译，将提示词翻译成英文\n写完自己图片的描述后，在后面可以加上以下的提示词\n正向提示词：\n(masterpiece:1,2),best quality, masterpiece, highres, original, extremely detailed wallpaper,perfect lighting,(extremely detailed CG:1.2), drawing,paintbrush\n反向提示词：\nNSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.221), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit, bad hands, missing fingers, (((extra arms and legs)))\n2.参数\n生成一张16/9尺寸的横屏壁纸\n4.点击右上角的生成\n5.补充输入提示词\n如果对AI生成的结果不满意，可以在输入框中用英文的逗号和空格隔开，补充输入提示词。\n参考提示词：\n6.保存图片\n在绘图界面可以查看保存路径，在图库浏览器中可以查看已生成的图片和数据\n右击图片\n还可以对已经画好的图片进行局部重绘\n或者如果在本地部署的\n2.文生图入门与提示词基础 2.1 提示词入门 2.1.1概念及基本逻辑 什么是提示词？\n2.1.2 语法(输入、间隔) 英文提示词；提示词之间英文逗号分隔；可以换行，但是在行末要加上逗号\n2.1.3内容型提示词与标准化提示词 内容型提示词\n以一个女孩在森林了漫步为例：\n既要详细描述女孩👧，又要详细描述森林🎄\n标准化提示词\n上面的提示词叫内容提示词，如果我们直接生成，可能导致画面模糊不清晰，而且没有细节。\n我们可以使用以下提示词让画面更趋近于某个固定化的标准：\n2.2 权重与负面提示词 2.2.1权重 当面对一堆提示词时，AI不能知道你到底想要什么，那么就可以增强提示词的权重和优先级\n所谓权重，就是==让某些词语更加突出==\n增加权重的方式：\n方式1：加括号()，权重变为原来的1.1倍，可以套多层，每套一层就*1.1 方式2：括号加数字(提示词:1.5)数字可以指定权重 如果想要削弱权重，就可以将:后的数字改为小于1的数字，或者使用[]，将权重变为原来的0.9倍 倍率的安全范围1~1.5\n2.1.2 负面提示词 正向提示词：希望出现什么\n参考：(masterpiece:1,2),best quality, masterpiece, highres, original, extremely detailed wallpaper,perfect lighting,(extremely detailed CG:1.2), drawing,paintbrush\n​\n负向提示词：不希望出现什么\n参考：NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.221), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit, bad hands, missing fingers, (((extra arms and legs)))\n**注意：**负向提示词不一定要这么写，有时候也可以将某些负向提示词放到正向提示词，会出现不一样的风格\n1 2 3 4 (masterpiece:1,2),best quality, masterpiece, highres, original, 1girl, black hair, long hair, Robes embroidered with elaborate symbolic motifs and tassels, brightly colored national costumes, elaborate masks, masks are beautifully carved and colorful, and exude an air of mystery, white background,dynamic pose, detailed face, clear edges,epiCPhoto,best quality,masterpiece,(realistic),HDR,UHD,8K,(extremely detailed),light particles,hard light, (photography:1.3), Large aperture, blur the background 2.3 出图参数设置 2.3.1采样迭代步数 理论上采样步数越多，最终效果越清晰。\n但实际上，步数大于20步后，后面的提升不大。\n如果算力充足且想追求更高的细致度，==可以设置为 30~40==\n2.3.2 采样方法 几种算法 分辨率 ==一般提升到1000左右==，太低会比较模糊\n但是分辨率也不能太高，一般选择先低分辨率绘制，再高清修复来放大\n一般也会将面部修复勾上\n提示词相关性 提示词相关性越高，AI忠实反映你的提示词的程度也就越高\n==一般7~12之间==\n随机种子 生成批次和每批数量 由于AI每次生成的图片不稳定，所以我们可以将生成批次调高一些\n然后筛选后细化\n2.4 新手必备提示词方法 使用翻译平台转英文，先描述场景，然后想要加的提示词词组加到后面\n借助提示词工具\nhttp://www.atoolbox.net/Tool.php?Id=1101\n参考别人分享的提示词\nhttps://openart.ai/home\n2.5总结 3.图生图入门 3.1重绘幅度 重绘幅度越低，图片越相似\n漫画效果：0.6-0.8之间\n3.2提示词书写 1girl /1man /1boy\n景深\n3.3分辨率 3.4随机种子 点击骰子，可以把随机种子设为-1\n点击循环按钮，会把种子设置成你上一张图片的数\n114514\n如果当次生成不满意，希望再次生成时使用同样风格\n打开图库浏览器，就可以找到我们之前生成的图片，可以找到它当时生成的种子\n复制种子值填到提示栏中\n3.5图生图的拓展应用 总结 4.AI绘画的模型概念 4.1模型文件基础 4.1.2 模型文件格式与加载位置 如果下载了新的模型文件，只需要把它们复制到下面的路径下，就可以利用SD去加载\n这类模型称为检查点/关键点 Checkpoint模型，后缀名常为.ckpt\n还有一种模型为safetensors占用空间更小\n将模型下载好后，拷贝到路径下，就可以在SD中切换模型了\n4.1.3 VAE的概念与作用 多数模型已经把VAE整合进大模型文件里了\n4.2模型下载渠道 4.2.1模型渠道简单分析 4.2.2HugginFace(抱脸)介绍 4.2.3 Civitai（C站）介绍 4.4 模型类目与推荐 5.高清修复和放大算法 5.1高清修复 如果只是为了放大，0.3~0.5 ，不要超过0.5\n使用技巧\n放大算法\n5.2图生图 5.3SD放大 如果觉得图片过渡还是比较生硬\n6.AI绘画进阶模型 二、ComfyUI 1. 基础入门 1.1搭建文生图 1.加载模型\n2.添加提示词框/条件\n我们需要两个提示词框（正面/负面），复制\n3.节点连接\n如果想同时移动多个节点，按住control框选，再shift+按住鼠标移动\n4.采样去噪\n对应在comfyui中是\nksampler必须要四个节点都连上，如果担心弄混，可以右击结点选title给结点命名\n或者color给他们一个醒目的颜色\n5、设置图片的尺寸\n‘\n6、连线\n只要结点的颜色相同，就可以连接到一起\n7、图片\n8、VAE\n开头模型加载器那里也会分出一个VAE的输出接口\n1.2搭建图生图 只需要在文生图的基础上\n需要转接口VAE，但不是解码VAE，而是编码VAE\n但是有些模型本身的vae出图效果不好\n但如果这样直接连，生成图片的尺寸会严格和导入的原图相同\n注意\n加载lora\n三、AI生成视频/电影 1、AI生成3D动画影片 https://www.youtube.com/watch?v=InUhESC5HyE\n1、创建脚本，通过插件提取视频内容，转到chatgpt，仿照原有视频内容重新生成新故事\n2、改写成电影脚本\n3、为生成图像设计场景\u0026ndash;建议一段一段给chatgpt\n4、为每个场景生成提示词\n为生成人物的时候更方便\n5、一致性人物生成\n1.创建描述词\n2.使用chatgpt的consistent character将描述词粘贴\n6、根据故事剧情，给人物添加动作和背景细节\n根据之前生成的提示词，调整人物的表情动作和场景\n可以修改尺寸\n总结\n免费版用户输入下面这段话\n【丝滑动画转绘 Comfyui Diffutoon视频工作流教程】https://www.bilibili.com/video/BV1aW42197L1?vd_source=8bf75c9036cf0a2888df20352dbce29c\n清晰度调整：\nm3WMfy\nLoras https://bit.ly/3yKMTNC https://bit.ly/3STMGi4 save in ComfyUI\\models\\loras\nIPAdapter: https://huggingface.co/h94/IP-Adapter/tree/main/models save in ComfyUI\\models\\ipadapter\nMotion Lora: https://civitai.com/models/476267/run-motion-lora-for-animatediff save in ComfyUI\\models\\animatediff_motion_lora\nAnimateDiff: https://huggingface.co/wangfuyun/AnimateLCM/blob/main/AnimateLCM_sd15_t2v.ckpt save in ComfyUI\\models\\animatediff_models\nMain Checkpoints Dreamshaper: https://civitai.com/models/4384?modelVersionId=252914 Cyberrealistic: https://civitai.com/models/292133/cyberrealistic-lcm-versions save in ComfyUI\\models\\checkpoints\nVAE: https://civitai.com/models/276082/vae-ft-mse-840000-ema-pruned-or-840000-or-840k-sd15-vae save in ComfyUI\\models\\vae\nClipVision: https://huggingface.co/laion/CLIP-ViT-H-14-laion2B-s32B-b79K/blob/main/model.safetensors save in ComfyUI\\models\\clip_vision (rename to CLIP-ViT-H-14-laion2B-s32B-b79K.safetensors)\nControlNet QRcode: https://huggingface.co/monster-labs/control_v1p_sd15_qrcode_monster/blob/main/control_v1p_sd15_qrcode_monster.safetensors save in ComfyUI\\models\\controlnet\nControlNet LineArt: https://huggingface.co/lllyasviel/control_v11p_sd15_lineart/blob/main/diffusion_pytorch_model.safetensors save in ComfyUI\\models\\controlnet (rename file to control_v11p_sd15_lineart.safetensors)\nUpscale model: https://huggingface.co/gemasai/4x_NMKD-Siax_200k/blob/main/4x_NMKD-Siax_200k.pth save in ComfyUI\\models\\upscale_models\nAdditional files for background removal 1- open ComfyUI\\custom_nodes\\ComfyUI_LayerStyle 2- select the file path at the top of the explorer navigation bar, erase it, type cmd, hit enter 3- in the command window, run this: git clone https://huggingface.co/briaai/RMBG-1.4\nfor RemBgultra model.pth error: 1- download: https://huggingface.co/briaai/RMBG-1.4/blob/main/model.pth 2- place it under ComfyUI/custom_nodes/ComfyUI_LayerStyle/RMBG-1.4/ 3- restart comfyui\n((Masterpiece, best quality, cinematic lighting, 8k, full body shot, long hair, hour glass body)), (smile:0.85), (realistic background), 1girl, dancing,\n((Masterpiece, best quality, cinematic lighting, 8k, full body shot, long hair, hour glass body)), (smile:0.85), (realistic background),\noil painting art style,rich colors,lush textures,expressive brushstrokes,mixable levels,dynamic composition,professional level completion,multifunctional media,eternal elegance,immersive depth,vibrant tones,complex details,increasing depth and dimension,magical realism painting art style,surrealist composition,bright colors,blurring the boundary between reality and fantasy, 1girl,qipao_clothes,bare_shoulder,standing front a red wall,sunshadow in wall,lying on wall,holding hand bag, A mesmerizing and visually stunning artwork featuring a single female figure,showcasing intricate details and vibrant colors. Official art quality with a strong aesthetic appeal,High resolution rendering in 4K,huliya,1girl,bangs,Gemstones,ornaments,flash,diffusion,Textured hair,Smiling eyes,\n种子：428618568091384\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n一、list的使用 list底层是带头双向循环链表\n迭代器\n1.1 remove 可以看成find和erase的结合\nerase就是先查找(find)这个迭代器的位置再删\nremove就是这个位置有就删，没有就无事发生\nvoid remove (const value_type\u0026amp; val);\n1.2 splice entire list (1) void splice (iterator position, list\u0026amp; x); single element (2) void splice (iterator position, list\u0026amp; x, iterator i); element range (3) void splice (iterator position, list\u0026amp; x, iterator first, iterator last); 1)将list里的元素全部拼接到position的前面\n2)仅将list里的元素的 i 的迭代器对应的元素拼接到position的前面\n3)把list里的一段迭代区间里的元素拼接到position的前面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int main() { //splice可以用来调整链表中结点的顺序 list\u0026lt;int\u0026gt; lt1 = { 1, 2, 3, 4, 5 }; //LRU int x; while (cin \u0026gt;\u0026gt; x) { auto pos = find(lt1.begin(), lt1.end(), x); if (pos != lt1.end()) { lt1.splice(lt1.begin(), lt1, pos); } for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } 在vs中ctrl+z加enter结束输入，正常结束，后面的程序继续执行\nctrl+c也可以，本质是把进程kill了\n1.3 排序 list的sort，默认升序(可以认为传的是\u0026lt;)\n(1) void sort(); (2) template \u0026lt;class Compare\u0026gt; void sort (Compare comp); 1）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { list\u0026lt;int\u0026gt; lt1 = { 1, 20, 3, -4, 5 }; for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; lt1.sort(); for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 2)如果想要降序需要传仿函数\nless和greater\nless\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { list\u0026lt;int\u0026gt; lt1 = { 1, 20, 3, -4, 5 }; for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //降序 /*greater\u0026lt;int\u0026gt; gt; lt1.sort(gt); */ lt1.sort(greater\u0026lt;int\u0026gt;()); for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } vector需要调算法库中的sort\n默认是升序，参数传一个仿函数就可以降序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector\u0026lt;int\u0026gt; v1 = { 1, 20, 3, -4, 5 }; for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //sort(v1.begin(), v1.end());//升序 sort(v1.begin(), v1.end(), greater\u0026lt;int\u0026gt;());//降序 for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 为什么list要自己有一个sort呢，算法库中不是有一个sort了吗？\n1.4 迭代器的功能划分 从上到下，从父到子\n==单向迭代器：只支持++== 比如forwad_list/unordered_xxx ==双向迭代器：支持++和\u0026ndash;== 比如list (底层是归并排序) ==随机迭代器：支持++、\u0026ndash;、+和-== 比如string/vector（底层是快排） 算法库中的sort要求传随机迭代器，sort底层是快排\n1.5 emplace_back和push_back的区别 emplace_back可以根据实参推形参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Pos { int _row; int _col; public: Pos(int row, int col) :_row(row) ,_col(col) { } }; int main() { list\u0026lt;Pos\u0026gt; lt; Pos p1(1, 1); lt.push_back(p1);//有名对象 lt.push_back(Pos(2, 2));//匿名对象 lt.push_back({ 3, 3 }); // 隐式类型转换 lt.emplace_back(p1); lt.emplace_back(Pos(2, 2)); //lt.emplace_back({ 3, 3 }); // 类型不确定 //直接构造 lt.emplace_back(3, 3); return 0; } 二、list的模拟实现 list是 带头双向循环链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #pragma once #include \u0026lt;assert.h\u0026gt; //惯例：全部是公有，一般用struct template\u0026lt;class T\u0026gt; struct List_node { T _data; List_node\u0026lt;T\u0026gt;* _next; List_node\u0026lt;T\u0026gt;* _prev; }; template\u0026lt;class T\u0026gt; class List { typedef List_node\u0026lt;T\u0026gt; Node; public: void empty_init() { _head = new Node(); _head-\u0026gt;_next = _head; _head-\u0026gt;_prev = _head; } list() { empty_init(); } private: Node* _head; }; 迭代器 普通迭代器\n1 2 3 4 5 6 容器::iterator it = begin(); while(it != end()) { *it; it++; } 容器迭代器设计思路体现了封装\n屏蔽底层实现细节，屏蔽各容器结构的差异，本质封装底层细节和差异，提供统一的访问方式\n封装就是把底层的细节屏蔽，想给你看到的给你，不想给你看到的就屏蔽起来，\n并且提供统一的访问方式，简单的封装是什么样的，复杂的封装是什么样的(比如迭代器)\n比如网银支付，像支付宝/微信这类的软件就是需要和各大银行对接，然后我们可以支付宝等软件上\n轻松使用自己其它银行卡里的钱进行付款\nconst迭代器\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n实现string类的接口，并完成测试，要求利用深拷贝和深赋值实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class string { public: string(const char* str = \u0026#34;\u0026#34;)； string(const string \u0026amp;s); string\u0026amp; operator=(const string \u0026amp;s); ~string()； private: char *_str; }; 一、swap 我们发现：\nstring既自己实现了一个swap\n又在全局实现了一个swap\n算法库中还有一个swap\n为什么要搞这么多swap呢?\n1.1 算法库中的swap 我们先看一看算法库中的swap\n然后写一个代码测试一下：\n1 2 3 4 5 6 7 8 9 10 void test1() { zhangsan::string s1(\u0026#34;hello world\u0026#34;); zhangsan::string s2(\u0026#34;xxxxxxxxxxxxxxxxxxxxx\u0026#34;); //swap(s1, s2); s1.swap(s2); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; } 我们发现，使用算法库中的 swap ，交换前的地址和交换后的地址均不相同，说明开了新空间\n简单分析一下：\n如果我们用的是算法库中的swap函数来交换 s1，s2 这两个string对象，那么需要\n1）先用 s1 构造一个 c，让 c 开一个和 s1 一样大的空间\n​2）然后让 s2 赋值给 s1：让 s1 释放旧空间，并开一个和 s2 一样大的空间\n3）最后让 c 赋值给s2 ：让 s2 释放旧空间，并开一个和 c 一样大的空间\n4）最后出作用域，c 会析构，释放空间\n使用这个swap，我们申请了三次空间，释放了三次空间，这样的代价是很大的\n1.2 string的成员函数swap 实际上，交换两个string对象不需要这么复杂，我们只需要将两个string对象的字符指针交换，_size 和 _capacity交换\n我们可以自己试着实现一个string 成员函数的 swap：\n1 2 3 4 5 6 7 void swap(string\u0026amp; s) { //交换内置类型调用算法库中的swap即可 std::swap(_str, s._str); std::swap(_size, s._size); std::swap(_capacity, s._capacity); } 细节：\n如果直接写swap 默认会优先调用我们自己写的swap，即zhangsan这个命名空间的swap，所以我们需要指定命名空间std，调用算法库中的swap\n再测试一下：\n1 2 3 4 5 6 7 8 9 10 void test1() { zhangsan::string s1(\u0026#34;hello world\u0026#34;); zhangsan::string s2(\u0026#34;xxxxxxxxxxxxxxxxxxxxx\u0026#34;); //swap(s1, s2); s1.swap(s2); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; } 我们发现 swap 交换前后地址没变，说明并没有开新空间，只是交换了指针\n**总结：**使用算法库中的swap交换 string对象 代价大，使用string成员函数中的swap 代价小\n1.3 string 全局的swap 我们现在已经了解了算法库中的swap和string成员函数中的swap的差异，但是string在全局还有一个 swap，这个swap设计出来又有什么意义呢？\n1 2 3 4 5 //string全局的swap void swap(string\u0026amp; s1, string\u0026amp; s2) { s1.swap(s2); } string全局的swap其实是对成员函数的封装，是普通函数，而算法库中的swap是函数模版。\n我们之前学过，如果既写了函数模版，又写了普通函数，如果传的参数和普通函数的参数类型匹配，编译器会优先调用普通函数。\n也就是说string实现全局的swap后，无论我们是通过 对象.swap的方式调用成员函数的swap，还是直接调用swap函数，都不会调用算法库中的swap\n补充说明一下：\nC++11提供的右值引用和移动语义后，即使string不提供全局的swap，也不会调用算法库中的swap，而是调用string成员函数中深拷贝的swap\n二、拷贝构造和赋值的简洁写法 传统写法和简洁写法没有效率的提升，只是简洁一点，本质是复用\n2.1 拷贝构造 string 拷贝构造的传统写法：\n传统写法是自己开空间，自己拷贝数据\n1 2 3 4 5 6 7 8 //s2(s1) string(const string\u0026amp; s) { _str = new char[s._capacity + 1]; strcpy(_str, s._str); _size = s._size; _capacity = s._capacity; } string 拷贝构造的简洁写法：\n1 2 3 4 5 6 //s2(s1) string(const string\u0026amp; s) { string tmp(s._str); swap(tmp); } 先用 s1 的 _str 构造一个 tmp 对象，再让 s2 和 tmp 交换\n2.2 赋值 string赋值运算符重载的传统写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // s1 = s3 string\u0026amp; operator=(const string\u0026amp; s) { if (this != \u0026amp;s) // 防止出现自己给自己赋值的情况 { delete[] _str; _str = new char[s._capacity + 1]; strcpy(_str, s._str); _capacity = s._capacity; _size = s._size; } return *this; } string赋值运算符重载的简洁写法：\n1 2 3 4 5 6 7 8 9 10 11 // s1 = s3 string\u0026amp; operator=(const string\u0026amp; s) { if (this != \u0026amp;s) // 防止出现自己给自己赋值的情况 { string tmp(s._str); swap(tmp); } return *this; } 先用 s3 的 _str 构造一个 tmp，再让 s1 和 tmp 交换。传统写法中，我们需要手动释放s1的空间，但在现代写法中，由于tmp是局部变量，出作用域就调用析构函数，相当于把之前s1的空间销毁了。\n这个写法还可以进一步改进：\n1 2 3 4 5 6 //s1 = s3 string\u0026amp; operator=(string s) { swap(s); return *this; } 直接传值传参，调用拷贝构造，让 s 和 s3 有一样大的空间和一样的值，然后让 this 指向的对象和 s 进行交换\n三、写时拷贝（了解） 先看一个场景：\ns2(s1)，用 s1 拷贝构造 s2，使用的是深拷贝，但是可能过一会其中一个就要销毁，我们觉得代价太大了，但是如果使用浅拷贝，会有两个问题 1.会析构两次 2.如果修改了其中一个，另一个也会修改。我们可以利用引用计数和写时拷贝解决这个两个问题\n3.1 引用计数 写时拷贝就是在s1指向这块空间的时候，额外开辟一块空间，这个空间存储一个整型值，这个整型值叫引用计数。引用计数是来记录有多少个对象指向这块空间，析构的时候就 \u0026ndash;引用计数 ，当减到0 就释放 s1 指向的这块空间。\n通过引用计数，解决了多个对象指向同一块空间，析构多次的问题\n3.2 写时拷贝 写时拷贝是在浅拷贝的基础上增加了引用计数的方式来实现的。写时拷贝可以解决使用浅拷贝的另一个问题，即如果修改了其中一个对象，其它的对象也会修改。\n当只有一个对象指向这块空间的时候，修改这个对象就直接在这块空间修改 如果有多个对象指向这块空间，那么哪个对象要修改的时候，哪个对象就进行深拷贝，并且引用计数\u0026ndash; 举个例子：\ns2(s1) ，假如我们现在要把s1下标为0对应位置的字符改为字符 x\n写时拷贝就是谁写谁进行深拷贝\n如果想了解更多关于写时拷贝的知识，可以看下面两篇大佬写的文章\nhttps://coolshell.cn/articles/1443.html\nhttps://coolshell.cn/articles/12199.html\n四、编码 编码 一些比特位的值 \u0026lt;\u0026mdash;\u0026ndash;映射\u0026mdash;\u0026ndash;\u0026gt; 文字符号\nUTF-16、UTF-32和UTF-8\nUTF-16 ：以两个字节为一个单位 UTF-32 ：以四个字节为一个单位 UTF-8 ：以一个字节为单位，是一种变长编码，兼容ASCII ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\nString类 1.为什么要学String 2. 标准库中的String 这个网站ctrl+F可以搜索\n2.1string的基本介绍 String不属于STL容器，String产生的比STL早\nString就是串，本质就是字符数组\nString类是一个模版\n原模版叫basic_string\n模版是可以给缺省参数的\n但是我们一般是用string类，是一个模版，只不过被typedef了，是char数组\n除了有string外，C11还新增了u16string ，也是字符数组\n每个字符是16位的char，占两个字节\n还有u32string字符数组，每个字符是4个字节\n为什么要定义成basic-string？\n这与编码有关，因为计算机底层是01，要用计算机表示各种符号字母数字就需要编码，编码的底层就是字符串\n类string支持utf-8，支持变长编码\nstring类在C++标准库中，使用要包含头文件#include\u0026lt;string\u0026gt;\n2.2string类的常用接口（上） 1.常见构造函数\nconstructor函数名称 功能说明 string(); 构造空的string类对象，即空字符串 string(const string\u0026amp;s) ; 用已经存在的string对象拷贝给要初始化的string对象 string(const char* s); 用C风格的字符串来构造string类对象 string(size_t n, char c) ; string类对象中包含n个字符c string(const char* s, n); string(const string\u0026amp;s, size_t pos, size_t len = npos); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //std::string s1; string s1; string s2(\u0026#34;1111112222\u0026#34;); string s3(\u0026#34;123456\u0026#34;, 3); //123 拷贝前n个字符 string s4(\u0026#34;123456\u0026#34;, 1, 3);//234 从下标为1的字符开始拷贝（下标从0开始） //string s3(s2, 1, 3);//122 string s5(100, \u0026#39;x\u0026#39;);//拷贝100个字符x string s6(s2, 4);//从s2下标为4的字符开始拷贝到结束 //下标从0开始，包括第4个字符 string s7(s2, 4, 20);//字符不够，就拷贝到字符串结束 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s5 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s6 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s7 \u0026lt;\u0026lt; endl; string重载了流插入和流提取，可以直接用\n2.2.2 string::npos npos是string里的静态成员变量，所以可以做缺省参数\nsize_t在32位下可以理解为unsigned int ，赋值给size_t的变量 -1 也就是全1\n即整型的最大值\n2.2.3运算符重载operator[] 同时重载了普通对象和const对象 string重载了一个运算符operator[]，可以访问pos位置的字符，如果越界了会报错\nstring::operator重载了两个成员函数，一个是普通的重载，一个是const修饰的重载\n所以它是既可读又可写的接口，如果是const对象调用，那么就不可以修改 如果是普通对象，可以用它来打印字符串，也可以修改字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (size_t i = 0; i \u0026lt; s1.size(); i++) { s1[i]++; } for (size_t i = 0; i \u0026lt; s1.size(); i++) { cout \u0026lt;\u0026lt; s1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 底层相当于是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;string\u0026gt; #include\u0026lt;assert.h\u0026gt; class string { public: char\u0026amp; operator[] (size_t pos) { assert(pos \u0026lt; _size);//加了断言，如果访问时越界了就会报错 return _str[pos]; // 返回的是别名 } private: char* _str; size_t _size; size_t _capacity; }; int main() { //s2.operator[](0) = \u0026#39;x\u0026#39; s2[0] = \u0026#39;x\u0026#39;; s2[5] = \u0026#39;x\u0026#39;; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; for (size_t i = 0; i \u0026lt; s2.size(); i++) { s2[i]++; } cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } 2.2.4 迭代器（一） 迭代器是==容器==通用的一种遍历方式，是像指针一样的对象\n我们可以定义一个iterator的对象，接收begin()返回第一个字符的位置\n当该对象不等于该字符串有效数据的下一个位置时，我们就得到该字符*it1（有点像我们学过的指针解引用），然后++it1就可以到下一个位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 string s1(\u0026#34;hello world\u0026#34;); //迭代器 //iterator是定义在string这个类域里面的 string::iterator it1 = s1.begin();//begin()返回第一个字符的位置 while (it1 != s1.end())//end返回最后一个有效数据的下一个位置，即返回的是\\0 { cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it1;//到下一个位置 } cout \u0026lt;\u0026lt; endl; //迭代器 string::iterator it1 = s1.begin();//begin()返回第一个字符的位置 while (it1 != s1.end()) { (*it1)--; ++it1; } cout \u0026lt;\u0026lt; endl; 为什么要使用迭代器？\n我们一般喜欢使用下标加方括号的形式，但是==下标加方括号的这种方式只适用于string和vector==\n因为string和vector底层是连续的物理空间，才能重载[]\n迭代器是所有容器通用的方式，因为像链表这种，通过重载[]来遍历，效率低\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; #include\u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; lt; lt.push_back(1); lt.push_back(2); lt.push_back(3); lt.push_back(4); list\u0026lt;int\u0026gt;::iterator it = lt.begin(); while (it != lt.end())//注意，此处不能用小于，因为空间不是连续的 { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it; } return 0; } 注意：\n迭代器的底层是指针，但是它不等于指针，是运算符重载\n遍历的时候，循环条件最好写 s.begin() != s.end()\n因为其它容器不像string和vector物理空间是连续的\n2.3 C++11新特性：auto和范围for 2.3.1 auto自动推导类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int i = 0; int j = i; //auto会自动推导类型 auto z = i; // int auto x = 1.1; // double auto p = \u0026amp;i; // int* //auto不能推导出引用 int\u0026amp; r1 = i; auto r2 = r1; // int，r1是i的别名，r1本质上还是int类型 auto\u0026amp; r3 = r1;// int\u0026amp; //auto r4; // 报错 return 0; } 对于一些涉及到比较长的类型（比如迭代器，map），我们就可以使用auto\n1 2 3 4 5 6 7 8 9 #include\u0026lt;map\u0026gt; int main() { std::map\u0026lt;std::string, std::string\u0026gt; dict; //std::map\u0026lt;std::string, std::string\u0026gt;::iterator dit = dict.begin(); auto dit = dict.begin(); return 0; } 总结：auto作用就是简化代码，替代写起来长的类型\n==C++20开始支持auto做函数形参==\n1 void func(auto x); ==C++11开始支持auto做返回值==\n1 2 3 4 5 auto func() { int x = 0; return x; } 2.3.2 范围for 遍历容器 范围for基本介绍 自动取容器的数据赋值给左边的值（==赋值是一种拷贝==）\n自动++，自动判断结束。\n范围for是用来遍历==容器==的（也就是数据结构），底层是迭代器，==只有容器才支持迭代器==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0； } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; #include\u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; lt; lt.push_back(1); lt.push_back(2); lt.push_back(3); lt.push_back(4); for (auto e : lt) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0； } 使用范围for修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (auto ch : s1) { ch++; // 修改 cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 我们发现在范围for里修改后，在里面确实打印出来的是修改后的值，\n但是出了范围for再打印就是原来的值了。\n原因是，范围for是自动取容器里的数据==赋值==给左边的值，赋值是\n一种拷贝，所以==我们在范围for里修改后，不会影响外面的值==\n==要是想修改里面的值==，因为auto不能自动推导出引用，==所以我们需要使用auto\u0026amp;==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //范围for c++11 for (auto\u0026amp; ch : s1) { ch++; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 总结范围for有两种情况要用引用：\n要修改数据 容器里面存的是一些比较大的对象，减少拷贝 ==如果是一些比较大的对象使用引用但是不想修改，可以使用const auto\u0026amp;== 范围for只适用于容器和数组\n数组可以使用范围for\n因为==范围for底层是迭代器==，迭代器的行为跟指针类似\n容器才能支持范围for\n因为容器才支持迭代器，而范围for的底层就是迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a[] = { 1, 2, 3, 4, 5, 6 }; for (auto e : a) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 范围for不能遍历哪些呢?\n比如范围for就不能用来遍历日期类\n2.4 string常用的接口（下） 2.4.1 迭代器（二） 反向迭代器 rebigin指向\\0的前一个字符，rend指向第一个字符的前一个位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); //rbegin指向最后一个位置的前一个位置 string::reverse_iterator rit = s1.rbegin(); //rend指向第一个元素的前一个位置 while (rit != s1.rend()) { cout \u0026lt;\u0026lt; *rit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++rit; // 注意是++ } cout \u0026lt;\u0026lt; endl; return 0; } const 迭代器 const对象无法使用普通的迭代器，要使用const迭代器\nconst对象调用const修饰的begin，返回的是const_iterator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { const string s2(s1); string::const_iterator it1 = s2.begin(); // 返回的是const_iterator while (it1 != s2.end()) { cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it1; } cout \u0026lt;\u0026lt; endl; return 0; } const_iterator可以遍历，不能修改\nconst的反向迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { string s1(\u0026#34;hello world\u0026#34;); //string::const_reverse_iterator rit1 = s2.rbegin(); auto rit1 = s2.rbegin(); while (rit1 != s2.rend()) { cout \u0026lt;\u0026lt; *rit1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++rit1; } cout \u0026lt;\u0026lt; endl; return 0; } cbegin()和const迭代器效果相同\n2.4.2 size和length size和length都是获取string的长度，不包含结尾的\\0，推荐使用size，size是通用的\n（因为对于链表、树等数据结构使用length不太合理）\n1 2 3 4 5 6 7 8 9 int main() { string s1(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; // 11 cout \u0026lt;\u0026lt; s1.length() \u0026lt;\u0026lt; endl;// 11 cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; // 15 实际是16 return 0; } capacity求字符传串能存多少有效字符\n空间不够会扩容\nclear把数据清空，但是一般不清空间\nclear就是把size变为0，capacity没变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; //clear把数据清空，但是一般不清空间 s1.clear(); cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; return 0; } 2.4.3 at访问pos位置的数据 at和operator[]的区别\nat失败后会抛异常，需要捕获；而operator[]是通过断言处理的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { try { string s1(\u0026#34;hello world\u0026#34;); //s1[20]; //程序直接终止，弹窗 s1.at(20); } catch (const exception\u0026amp; e) { cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } return 0; } front和back返回的pos位置字符的引用，也就是可以修改\nfront返回第一个字符，back返回最后一个字符\n2.4.4 尾插 push_back尾插 底层：空间不够就扩容\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello\u0026#34;); s1.push_back(\u0026#39;,\u0026#39;); s1.push_back(\u0026#39;w\u0026#39;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } append追加 迭代器区间一定是左闭右开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello\u0026#34;); //尾插一个字符 s1.push_back(\u0026#39;,\u0026#39;); s1.push_back(\u0026#39;w\u0026#39;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //尾插一个字符串 s1.append(\u0026#34;orld\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1.append(10, \u0026#39;!\u0026#39;); // 尾插10个字符\u0026#39;!\u0026#39; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; string s2(\u0026#34;hello world\u0026#34;); //s1.append(s2.begin(), s2.end());//使用迭代器，左闭右开 s1.append(s2.begin() + 6, s2.end()); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } operator+= 1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s3(\u0026#34;hello\u0026#34;); s3 += \u0026#39;,\u0026#39;; s3 += \u0026#34;world\u0026#34;; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; return 0; } 2.4.5 insert pos必须是有效的位置\n1 2 3 4 5 6 7 8 int main() { string s1(\u0026#34;hello world\u0026#34;); s1.insert(5, \u0026#34;xxxx\u0026#34;);//在下标为5处插入一个字符串 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 2.4.6 string的扩容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1; size_t old = s1.capacity(); // 旧的容量 cout \u0026lt;\u0026lt; \u0026#34;capacity:\u0026#34; \u0026lt;\u0026lt; old \u0026lt;\u0026lt; endl; for (size_t i = 0; i \u0026lt; 100; i++) { s1 += \u0026#39;x\u0026#39;; if (s1.capacity() != old) // 如果当前容量和旧的容量不等 { cout \u0026lt;\u0026lt; \u0026#34;capacity:\u0026#34; \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; old = s1.capacity(); } } return 0; } capacity的值没有算\\0\nVS上string的扩容是呈1.5倍扩容\nLinux下扩容是呈2倍扩容\n2.4.7 reserve预留容量 如果我们知道要开多大的空间，那么可以使用reserve\n如果给200的话会开一个比200大的一段空间\n因为每次插入数据可能会有扩容，而扩容需要拷贝旧空间里的数据，\n开辟新空间，释放旧空间，有消耗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 提前开空间，避免扩容 s1.reserve(200); size_t old = s1.capacity(); cout \u0026lt;\u0026lt; \u0026#34;capacity:\u0026#34; \u0026lt;\u0026lt; old \u0026lt;\u0026lt; endl; return 0; } 2.4.8 reverse反向/翻转 2.4.9 resize调整大小 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;111111111111111111\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; //删除 // n \u0026lt; size s1.resize(15); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; //插入 // size \u0026lt; n \u0026lt; capacity s1.resize(25); // 如果不指定，那么补的是 \\0 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; // n \u0026gt; capacity s1.resize(40); // 补的是 \\0 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; return 0; } assign赋值 erase删除 从pos位置开始，删除len个字符\n删除后，后面的字符要往前挪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); s1.insert(5, \u0026#34;xxxx\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1.erase(5, 5); // 从第5个位置开始，删除5个字符 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //头删 s1.erase(0, 1); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //使用迭代器头删 s1.erase(s1.begin()); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } substr取子串 从pos位置开始，取len个字符\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { string s3(\u0026#34;test.cpp.zip\u0026#34;); size_t pos = s3.rfind(\u0026#39;.\u0026#39;); // rfind默认是从后往前找 if (pos != string::npos) { string sub = s3.substr(pos); // 从pos位置开始一直取到结尾 cout \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; endl; } return 0; } find查找字符或字符串 查找字符串或字符，默认从0位置开始查找\n不常用的 replace替换 replace只有平替时效率最高，其它时候需要挪动数据，效率低\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { string s1(\u0026#34;hello world hello bit\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //s1.replace(5, 1, \u0026#34;%%\u0026#34;);//第5个位置开始的1个字符替换成%% //cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //将字符串中所有空格都替换成%% //先通过find找到要替换的字符的下标，然后通过下标替换 size_t i = s1.find(\u0026#39; \u0026#39;);//查找字符串或字符，默认从0位置开始查找 while (i != string::npos) { s1.replace(i, 1, \u0026#34;%%\u0026#34;);//将i位置开始的1个字符替换成%% //替换完后再找下一个字符 i = s1.find(\u0026#39; \u0026#39;, i+2); } cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 下面这种方法同样能实现，空间换时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 string s1(\u0026#34;hello world hello bit\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; string s2; for (auto ch : s1) { if (ch != \u0026#39; \u0026#39;) s2 += ch; else s2 += \u0026#34;%%\u0026#34;; } cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; s1.swap(s2); c_str 取char*类型的str 获取string底层的字符串，主要是为了保持和C语言兼容\n1 2 3 string s1(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // 重载string的流插入 cout \u0026lt;\u0026lt; s1.c_str() \u0026lt;\u0026lt; endl; // 返回string底层的字符串，是内置类型的 使用场景：\n我们现在在写一个C++的程序，但是我们必不可少地需要调用一些C语言的库，\n（C++不是纯的面向对象，它还有面向过程）\n假设我们现在需要打开一个文件进行读，假设我们现在只学了C的库\nfopen要求第一个参数必须是const char*类型，但是我们的文件名是string类型的\n那么现在我们就可以使用 c_str()\n1 2 3 4 5 6 7 8 string s2(\u0026#34;Test.cpp\u0026#34;); FILE* fout = fopen(s1.c_str(), \u0026#34;r\u0026#34;); // fopen的第一个参数必须是const char* char ch = fgetc(fout); while (ch != EOF) { cout \u0026lt;\u0026lt; ch; ch = fgetc(fout); } 1 2 3 4 5 6 7 const char* p1 = \u0026#34;xxxxx\u0026#34;; int* p2 = nullptr; //cout是通过函数重载，自动识别类型 //但是const char*不会按照指针类型打印，而是直接解引用对应的字符串 cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (void*)p1 \u0026lt;\u0026lt; endl; // 强转成void*就可以打印 cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; endl; data rfind倒着找 使用场景：\n**需求：**取出文件名的后缀\n后缀一般是 .xxx 但是还有一种可能就是这个文件被压缩了，\n比如test.cpp.zip，此时得到的后缀.cpp.zip显然不是真实的后缀\n1 2 string s3(\u0026#34;test.cpp.zip\u0026#34;); size_t pos = s3.rfind(\u0026#39;.\u0026#39;); // 默认是从后往前找 find_first_of 找字符串中的是否有任意一个字符在str中，可以理解为find_first_any_of\n1 2 3 4 5 6 7 8 9 10 std::string str (\u0026#34;PLease, replace the vowels in this sentence by asterisks.\u0026#34;); // 看“aeiou”是不是str中的任意一个 std::string::size_type found = str.find_first_of(\u0026#34;aeiou\u0026#34;); while (found!=std::string::npos) { str[found]=\u0026#39;*\u0026#39;; found=str.find_first_of(\u0026#34;aeiou\u0026#34;,found+1); } std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; find_last_of 可以理解为rfind_last_any_of\nfind_first_not_of 不是str中任意一个的保留下来\n1 2 3 4 5 6 7 8 9 std::string str(\u0026#34;Please, replace the vowels in this sentence by asterisks.\u0026#34;); std::size_t found = str.find_first_of(\u0026#34;aeiou\u0026#34;); // 看“aeiou”是不是str中的任意一个 while (found != std::string::npos) { str[found] = \u0026#39;*\u0026#39;; found = str.find_first_not_of(\u0026#34;aeiou\u0026#34;, found + 1); } std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 只有aeiou留下来了\n总结常用的 2.5 和string相关的函数 to_string 将整型、浮点型\u0026hellip;转成字符串\n1 string s3 = to_string(11.11); // 会补齐六位 stoi 将string转成整型\n3. string类的模拟实现 3.1 构造函数+析构函数 \u0026mdash;-\u0026gt;\nstring.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #pragma once #include \u0026lt;iostream\u0026gt; using namespace std; namespace dyy { class string { public: //\tstring(); //缺省参数只能在声明的时候给 string(const char* str = \u0026#34;\u0026#34;); // C语言默认字符串结尾是\\0 ~string(); const char* c_str() const { return _str; } private: char* _str; size_t _size; size_t _capacity; }; } string.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026#34;string.h\u0026#34; namespace dyy { //string::string() //\t:_str(new char[1] {\u0026#39;\\0\u0026#39;}) // 为了和string(const char* str)析构时delete[] _str配对 //\t, _size(0) //\t, _capacity(0) //{ //} // 注意：初始化列表中是按成员声明的顺序进行初始化 string::string(const char* str) :_size(strlen(str)) { _capacity = _size; _str = new char[_size + 1]; //空间开辟后，还需要把数据拷贝过来 strcpy(_str, str); } string::~string() { delete[] _str; _str = nullptr; _size = 0; _capacity = 0; } } strlen是O(N)的函数，运行时计算，遇到\\0终止\nsizeof是操作符，在编译时计算\n3.2 遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 char\u0026amp; operator[](size_t i) { assert(i \u0026lt; _size); return _str[i]; } const char\u0026amp; operator[](size_t i) const { assert(i \u0026lt; _size); return _str[i]; } size_t size() const { return _size; } 3.3 迭代器 测试：\n3.4插入 4.扩展阅读 5. 题目 语雀\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"一、vector的使用 vector是用大小可变的数组实现的\nhttps://legacy.cplusplus.com/reference/vector/vector/\n1.vector的创建 1 2 vector\u0026lt;int\u0026gt; v1; vector\u0026lt;int\u0026gt; v2(10, 1); // 大小为10，初始化为1 使用push_back插入数据\n1 2 3 4 v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); 遍历\n重载了[] 遍历的时候可以下标+[] 1 2 3 4 5 for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 可以使用迭代器 1 2 3 4 5 6 7 vector\u0026lt;int\u0026gt;::iterator it1 = v1.begin(); while (it1 != v1.end()) { cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it1; } cout \u0026lt;\u0026lt; endl; 可以使用范围for 1 2 3 4 5 for (auto x : v1) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 注意：\n1 2 string s1; vector\u0026lt;char\u0026gt; vs; 这两者不等价\n1.string的char数组后面有\\0 2.接口的功能，string后面可以插入一个字符，也可以插入字符串，所以有push_back，append，+=等，还有c_str\n但是可以这样写 vector\u0026lt;string\u0026gt; vstr; 可以push_back string对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector\u0026lt;string\u0026gt; vstr; string s1 = \u0026#34;张三\u0026#34;; vstr.push_back(s1); vstr.push_back(\u0026#34;李四\u0026#34;); //传引用，减少拷贝 for (const auto\u0026amp; e : vstr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //vstr[0]是string字符串，可以使用+= vstr[0] += \u0026#39;x\u0026#39;; // vstr.operator[](0) 等价于 vstr[0] 即s1 vstr[0] += \u0026#34;apple\u0026#34;; vstr[0][0]++; vstr[0][1]++; // 等价于 vstr.operator[](0).operator[](1)++; for (const auto\u0026amp; e : vstr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; vector还可以使用 {} 来初始化\n1 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; 原因是有这个对象\n1 2 3 4 5 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; // 隐式类型转换 vector\u0026lt;int\u0026gt; v2({ 1, 2, 3, 4, 5 }); auto il1 = { 1, 2, 3, 4, 5, 6 }; initializer_list\u0026lt;int\u0026gt; il2 = { 1, 2, 3, 4, 5, 6 }; assign 就是覆盖的赋值，如果assign的数据比较多，会扩容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; // 隐式类型转换 for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; v1.assign({ 10, 20, 30 }); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; insert\nstring支持用下标插入，vector不支持用下标插入\nvector都是使用迭代器\nemplace 等价于 push_back尾插 也等价于 insert\n2.常用接口的使用 3.迭代器失效 4.扩容问题 一般是扩 2 倍 或 1.5 倍\nreserve只负责开辟空间，如果确定知道需要用多少空间，reserve可以缓解vector增容的代价缺陷问题。 resize在开空间的同时还会进行初始化，影响size 二、练习题 杨辉三角\nC语言中动态开辟二维数组，先开一个一维的指针数组，数组里的每个值是指针(int*)\n1 2 3 4 5 int** ptr = (int**)malloc(sizeof(int*) * N); for(int i = 0; i \u0026lt; N; i++) { ptr[i] = (int*)malloc(sizeof(int*)(i + 1)); } vector\u0026lt;int\u0026gt; 与 ==vector\u0026lt;vector\u0026lt;int\u0026raquo;== 理解：vector数组，每个vector里的值是int类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;class T\u0026gt; class vector { public: T\u0026amp; operator[](size_t i) { assert(i \u0026lt; _size); return _a[i]; } private: T* a; size_t _size; size_t _capacity; }; vector\u0026lt;vector\u0026lt;int\u0026raquo; vv;\n三、模拟实现 3.1迭代器失效(insert和erase) 迭代器失效之后就不能再进行++，解引用等操作\n==第一种失效：扩容引起的野指针的问题==\n迭代器失效就是像野指针一样\n本质因为一些原因，迭代器不可用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void insert(iterator pos, const T\u0026amp; x) { assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt;= _finish); //空间不够，扩容 if (_finish == _endofstorage) { size_t len = pos - _start; reserve(capacity() == 0 ? 4 : capacity() * 2); pos = _start + len; } iterator i = _finish - 1; while (i \u0026gt;= pos) { *(i + 1) = *i; --i; } *pos = x; ++_finish; } typeid(想知道的真实类型).name() 可以获得真实类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 iterator insert(iterator pos, const T\u0026amp; x) { assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt;= _finish); //空间不够，扩容 if (_finish == _endofstorage) { size_t len = pos - _start; reserve(capacity() == 0 ? 4 : capacity() * 2); pos = _start + len; } iterator i = _finish - 1; while (i \u0026gt;= pos) { *(i + 1) = *i; --i; } *pos = x; ++_finish; return pos; } ==第二种失效：删除数据，导致数据挪动，it已经不是指向之前位置了==\n可能会导致逻辑问题，比如我们删除vector中所有的偶数，当最后一个数是偶数\n时，_finish\u0026ndash;，it++，但是it不等于v1.end()，所以就一直往后走\nerase，迭代器也失效，要访问，必须得更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void test_vector2() { vector\u0026lt;int\u0026gt; v1; v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //要求删除所有的偶数 auto it = v1.begin(); while (it != v1.end()) { if (*it % 2 == 0) { //erase返回删除位置下一个位置 //失效的迭代器，更新以后再去访问 it = v1.erase(it); } else { ++it; } } for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 内置类型默认构造\n1 2 3 int i = int(); int j = int(1); int k(2); 3.2 resize n表示要vector多大，val表示缺省值\n如果n小于等于size，缩小有效元素的个数 如果n大于size，那么考虑扩容reserve，然后让超出原来size的部分赋上缺省值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void resize(size_t n, T val = T()) { if (n \u0026lt;= size()) { _finish = _start + n; } else { reserve(n); //插入数据 while (_finish \u0026lt; _start + n) { *_finish = val; ++_finish; } } } 3.3存string时会出现乱码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void test_vector6() { vector\u0026lt;string\u0026gt; v1; v1.push_back(\u0026#34;1111111111111111111\u0026#34;); v1.push_back(\u0026#34;222222222222222222\u0026#34;); v1.push_back(\u0026#34;333333333333333\u0026#34;); v1.push_back(\u0026#34;44444444444444\u0026#34;); v1.push_back(\u0026#34;44444444444444\u0026#34;); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } string对象里面还有 str ,size, capacity，str是指向堆里的一块空间\n扩容的时候，拷贝会有问题，是值拷贝，释放旧空间的时候，会导致新\n空间里的string的str指向空间的数据也被释放\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n1、C/C++内存分布 栈、堆、静态区(数据段)、常量区(代码段) \u0026mdash;虚拟进程地址空间\n程序 \u0026mdash;\u0026ndash; \u0026gt;编译（）\u0026mdash;-\u0026gt;可执行程序，运行起来叫进程\n代码 二进制的机器\n多线程\u0026ndash;每个线程都有一个栈\n一个进程里可能有多个线程\n2、C语言中动态内存管理方式 malloc/calloc/realloc/free\n3、C++内存管理方式 C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理。\n3.1new/delete操作内置类型 new是C++中动态申请空间的关键字，申请的空间在堆中，需要程序员自己释放。\n释放堆区的数据使用关键字delete\n1.new的基本语法new 数据类型\nnew返回的是==该数据类型的指针==\n创建整型空间new 数据类型() 1 2 3 4 5 //动态申请int类型的空间 int* ptr4 = new int; //动态申请int类型的空间并初始化为10 int* ptr5 = new int(10); 创建数组new 数据类型[]{} 1 2 3 4 5 6 //动态申请10个int类型的空间 int* ptr6 = new int[3]; //动态申请一个数组并初始化 int* ptr7 = new int[3]{1,2,3}; int* ptr8 = new int[5]{1,2,3};//可以不完全初始化 delete的基本语法 释放基本数据类型的指针变量delete 指针变量\n1 2 delete pr4; delete ptr5; 释放数组delete[] 数组名\n1 2 delete[] ptr7; delete[] ptr8; ​\n3.2new/delete操作自定义类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 只申请空间 A* p1 = (A*)malloc(sizeof(A)); // 申请空间+构造函数 A* p2 = new A;//有默认构造 //没有默认构造，可以传参 A* p3 = new A(1); //只释放空间 free(p1); //析构函数+释放空间 delete p2; delete p3; 创建多个对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 //申请空间+10次构造 A* p6 = new A[10]; delete[] p6; //使用有名对象初始化 A aa1(1); A aa2(2); A* p7 = new A[10]{ aa1, aa2 }; delete[] p6; //使用隐式类型转换初始化对象 A* p8 = new A[10]{ 1, 2, 3 }; delete[] p8; 使用new和delete创建单链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct ListNode { int _val; ListNode* _next; ListNode(int val) :_val(val) ,_next(nullptr) {} }; int main() { ListNode* n1 = new ListNode(1); ListNode* n2 = new ListNode(2); ListNode* n3 = new ListNode(3); ListNode* n4 = new ListNode(4); n1-\u0026gt;_next = n2; n2-\u0026gt;_next = n3; n3-\u0026gt;_next = n4; return 0; } 4、operator new 与 operator delete函数 operator new 与 operator delete不是运算符重载，就是库里面的一个函数\noperator new本质是==对malloc的封装==。成功就返回对应指针，失败就抛异常 malloc是失败就返回空 ==operator new和operator delete 都是库里面全局的函数== 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。 */ void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) { // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) { // report no memory // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); } return (p); } operator delete是为了跟operator进行配对\n封装了一个free_dbg的函数，该函数就是free\n因为库里面的free就是一个宏函数，free的底层就是调free_dbg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* operator delete: 该函数最终是通过free来释放空间的 */ void operator delete(void *pUserData) { _CrtMemBlockHeader * pHead; RTCCALLBACK(_RTC_Free_hook, (pUserData, 0)); if (pUserData == NULL) return; _mlock(_HEAP_LOCK); /* block other threads */ __TRY /* get a pointer to memory block header */ pHead = pHdr(pUserData); /* verify block type */ _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-\u0026gt;nBlockUse)); _free_dbg( pUserData, pHead-\u0026gt;nBlockUse ); __FINALLY _munlock(_HEAP_LOCK); /* release other threads */ __END_TRY_FINALLY return; } /* free的实现 */ #define free(p) _free_dbg(p, _NORMAL_BLOCK) 总结：\n通过上述两个全局函数的实现知道，==operator new 实际也是通过malloc来申请空间，==\n如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，\n如果用户提供该措施就继续申请，否则就抛异常。==operator delete 最终是通过free来释放空间的。==\n5、new和delete的实现原理 一切代码编译后都是对应的指令\n5.1内置类型 如果申请的是内置类型的空间，new和malloc，delete和free基本类似\n不同的地方是：\nnew/delete申请和释放的是单个元素的空间，new[] 和delete[]申请的是==连续空间==，\n而且==new在申请空间失败时会抛异常==，malloc会返回NULL\n5.2自定义类型 new的原理\n调用operator new函数==申请空间== 在申请的空间上执行==构造函数==，完成对象的构造 我们也可以直接使用operator new ，operator new 是库里面全局的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class A { public: A(int a = 0) { cout \u0026lt;\u0026lt; \u0026#34;A(int a)\u0026#34; \u0026lt;\u0026lt; endl; } A(const A\u0026amp; aa) :_a1(aa._a1) { cout \u0026lt;\u0026lt; \u0026#34;A(const A\u0026amp; aa)\u0026#34; \u0026lt;\u0026lt; endl; } A\u0026amp; operator=(const A\u0026amp; aa) { cout \u0026lt;\u0026lt; \u0026#34;A\u0026amp; operator=(const A\u0026amp; aa)\u0026#34; \u0026lt;\u0026lt; endl; if (this != \u0026amp;aa) { _a1 = aa._a1; } return *this; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\u0026#34; \u0026lt;\u0026lt; endl; } private: int _a1 = 1; }; int main() { A* p1 = (A*)operator new(sizeof(A)); // 失败会抛异常 return 0; } delete的原理\n在空间上执行==析构函数==，完成对象中资源的清理工作 调用==operator delete函数==释放对象的空间 new T[N]的原理\noprator new 是 malloc的封装，operator new[] 是operator new 的封装\n调用operator new[]函数，在operator new[]中实际==调用operator new函数==完成N个对象空间的申请 在申请的空间上执行N次构造函数 delete[]的原理\n在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理 调用operator delete[]释放空间，实际在operator delete[]中调==用operator delete==来释放空间 6、定位new表达式(placement-new) 定位new表达式是在==已分配==的原始内存空间中==调用构造函数初始化==一个对象。\n使用格式：\nnew (place_address) type或者new (地址/要初始化的那块空间) 类型(初始化的参数) place_address必须是一个指针，initializer-list是类型的初始化列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 //new是库里面的一个全局的函数，返回值是void* //失败了会抛异常，所以不用检查返回值 A* p1 = (A*)operator new(sizeof(A));//不会调构造 //构造函数不支持显示调用 //p1-\u0026gt;A(1); //会对p1指向的那块空间当成A对象调用构造函数初始化 new(p1)A(10);//如果没有参数，new(p1)A; //析构函数支持显示调用 p1-\u0026gt;~A(); operator delete(p1); ==构造函数不支持显示调用，要使用定位new==\n==析构函数支持显示调用，完成资源清理，之后还需要调用operator delete 完成空间的释放==\n定位new和显示调用析构是为了支持有的地方为了提高效率，\n申请内存的时候，如果直接使用new，new的底层是operator new 调 malloc，效率比较低。\n自己会去写一个内存池，如果我的空间是从我自己定制的内存池出来的，那就开好空间了\n**注意：**不要交叉申请释放\n比如：new和delete是一对的，operator new和operator delete是一对的，\n而不要让new和opertaor delete一对等\n1 2 3 4 5 6 //对 A* p2 = (A*)operator new(sizeof(A)); new(p2)A(10); p2-\u0026gt;~A(); operator delete(p2); 1 2 3 //operator new不会初始化，所以指针是随机值 A* p1 = (A*)operator new(sizeof(A)); delete p1;//~A()释放了一块随机地址的空间 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A { public: A(int a = 0) : _a(a) { cout \u0026lt;\u0026lt; \u0026#34;A():\u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A():\u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; delete _p; } private: int _a; int* _p = new int; }; 下面这段代码运行时，程序会崩溃，因为==operator new 只开空间==，不调用构造初始化，_p也就没有在指向堆上的一块空间，是野指针。因此，当delete调用析构函数时，清理的是野指针 1 2 3 4 5 6 7 int main() { A* p1 = (A*)operator new(sizeof(A));//没有初始化 delete p1; return 0; } 下面这段代码运行时，程序不会崩溃，因为new会开空间并调用构造完成初始化。虽然我们的A类中没有写_p指针的初始化，但是在类的声明位置给了缺省参数，所以__p指向堆中的一块空间 1 2 3 4 5 6 7 8 9 int main() { A* p1 = new A; //如果只使用free()，会内存泄露 //free(p1);//只会把p1这块空间释放，但是_P指向的那块空间没有释放 delete p1; return 0; } 总结：\n不要忘记释放 不要交错使用 7、malloc/free和new/delete的区别 从用法和功能\nmalloc/free和new/delete的\n共同点是：都是从堆上申请空间，并且需要用户手动释放。\n不同的地方是：\nmalloc和free是函数，new和delete是操作符\nmalloc申请的空间不会初始化，new可以初始化\nmalloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可，如果是多个对象，[]中指定对象个数即可\nmalloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型\nmalloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是==new需要捕获异常==\n申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理释放\n总结：\nmalloc和free是函数，new和delete是操作符\nnew申请空间后会初始化\nnew申请空间不需要手动计算字节数，如果有多个对象，[]指定对象个数\nnew申请空间失败，需要捕获异常\nnew在申请空间时会调用构造函数完成对象的初始化\ndelete在释放空间前会调用析构函数完成空间中资源的清理释放\nmalloc返回值是void*，需要强转，new不需要，new后面跟的是空间类型\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n模版初阶和STL简介 1.泛型编程 假设我们需要交换两个数，那么就需要写一个交换函数。但是我们可能这次想交换两个整型数据，下次想交换两个浮点型数据等，那么就要求函数参数的类型不同。如果是在C语言中，我们可能需要写不同函数名，不同函数参数，但是需要想很多函数名。而在C++中，我们可以使用函数重载这一特性，也就是函数名相同，函数参数不同。\n使用函数重载，我们就可以写出下面这段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void Swap(int\u0026amp; left, int\u0026amp; right) { int temp = left; left = right; right = temp; } void Swap(double\u0026amp; left, double\u0026amp; right) { double temp = left; left = right; right = temp; } void Swap(char\u0026amp; left, char\u0026amp; right) { char temp = left; left = right; right = temp; } 我们可以发现，在上面这段代码中，我们函数实现的逻辑是完全相同的，只是传给函数的形参类型不同，也就是我们写了大量重复的代码。那有没有办法能解决呢？\n答案是有的，在C++中，我们可以给编译器一个函数模版，然后让编译器随着我们函数参数类型的变化自动生成对应的函数实例。\n我们原先是根据具体的类型来编程的，而现在我们只需要写一个通用的函数模版出来就可以处理不同类型的数据。我们把这种根据广泛数据类型的编程就叫做泛型编程。\n泛型编程：编写==与类型无关==的通用代码，是代码复用的一种手段。模板是泛型编程的基础\n2. 函数模版 2.1 函数模版概念 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。\n2.2 函数模版格式 函数模版格式：\n1 2 template\u0026lt;typname T1, typename T2...,typename Tn\u0026gt; 返回类型 函数名（函数参数） 其中typename可以换成class\n函数模版中函数里面的类型一般都用T代替（T是Type的缩写）\n可以定义多个模版参数\n我们现在来写一个交换函数的模版\n1 2 3 4 5 6 7 template\u0026lt;class T1, class T2\u0026gt; //类型 void Swap(T1\u0026amp; left, T2\u0026amp; right) //对象 { T1 tmp = left; left = right; right = temp; } 我们可以测试一下\n1 2 3 4 5 6 7 8 9 10 11 int main() { int x = 0, y = 1; double m = 1.1, n = 2.2; Swap(x, y); Swap(m, n); Swap(x, n); return 0; } 在上面的代码中，我们分别传了（整型，整型），（浮点型，浮点型），（整型，浮点型）\n那么编译器就会根据我们写的函数模版和提供的函数参数类型，推断并生成对应的实例函数\n而不会把所有类型的函数生成，比如我们这个例子中就不会生成char类型的Swap函数\n注意：\n不同类型的参数，调用的不同的函数 模版本质是让编译器当牛马，实例化生成对应的函数 ==模版不是函数，编译器根据模版实例化生成的才是函数== 2.3 函数模版的原理 函数模版是一个蓝图，它本身不是一个函数，是==编译器用使用方式产生特定具体类型函数的模具==。所以其实模板就是将本来应该我们做的重复的事情交给了编译器\n==模版是在编译阶段生成对应函数的==，编译器编译成指令后，就没有模版这个概念了，只有对应生成的函数实例了\n在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。\n比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。\n2.4 函数模版实例化 用不同类型的参数使用函数模板时，称为函数模板的实例化。\n函数模版的实例化分为隐式实例化和显式实例化\n以一个加法函数模版为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class T\u0026gt; T Add(const T\u0026amp; left, const T\u0026amp; right) { return left + right; } int main() { int a1 = 10, a2 = 20; double d1 = 10.1, d2 = 20.1; Add(a1, a2); Add(d1, d2); return 0; } 隐式实例化 \u0026ndash; 自动推导类型 隐式实例化就是，编译器会根据我们传的实参自己去推模版参数的实际类型\n1 2 3 //强转 cout \u0026lt;\u0026lt; Add(a1, (int)d1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Add((double)a1, d1) \u0026lt;\u0026lt; endl; 显示实例化 \u0026ndash; 不用推导 在函数名和参数中间加上\u0026lt;\u0026gt;告诉编译器是什么类型\n1 2 cout \u0026lt;\u0026lt; Add\u0026lt;int\u0026gt;(a1, d1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Add\u0026lt;double\u0026gt;(a1, d1) \u0026lt;\u0026lt; endl; 显示实例化的应用场景\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;class T\u0026gt; T* Func(size_t n) { return new T[n]; } int main() { Func\u0026lt;int\u0026gt;(10); Func\u0026lt;double\u0026gt;(10); return 0; } 在上面的场景中，编译器无法推断类型，所以需要我们显示地写\n​\n2.5 模版参数的匹配原则 如果我们既写了函数模版，也写了普通函数，那么编译器会优先匹配谁呢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int Add(int left, int right) { return left + right; } template\u0026lt;class T\u0026gt; T Add(T left, T right) { return (left + right) * 5; } int main() { cout \u0026lt;\u0026lt; Add(1, 2) \u0026lt;\u0026lt; endl; return 0; } 如果函数模版和普通函数同时存在，编译器会优先调用普通函数\n那如果我们就是要调用函数模版呢？我们可以显示调用\n1 cout \u0026lt;\u0026lt; Add\u0026lt;int\u0026gt;(1, 2) \u0026lt;\u0026lt; endl; 如果传的参数和普通函数的参数类型不匹配，那么会调模版\n1 cout \u0026lt;\u0026lt; Add(1.1, 2.2) \u0026lt;\u0026lt; endl; 补充：交换函数我们不需要自己写，库里面有swap函数\n不需要我们自己包头文件，间接被包了\n编译器会先调用更匹配的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int Add(int left, int right) { return left + right; } template\u0026lt;class T\u0026gt; T Add(T left, T right) { return (left + right) * 5; } template\u0026lt;class T1, class T2\u0026gt; T1 Add(T1 left, T2 right) { return (left + right) * 5; } int main() { //优先匹配 template\u0026lt;class T\u0026gt; cout \u0026lt;\u0026lt; Add(1.1, 2.2) \u0026lt;\u0026lt; endl; return 0; } 3. 类模版 3.1 类模版的定义格式 如果一个类中的数据成员的数据类型不能确定，或者是某个成员函数的参数或者返回值的类型不能\n确定，就必须将此类声明为模板。\n1 2 3 4 5 template\u0026lt;class T1, class T2, ..., class Tn\u0026gt; class 类模版名 { //类内成员定义 }; 例如我们写一个栈的模版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;typename T\u0026gt; class Stack { public: Stack(size_t capacity = 4) { _array = new T[capacity]; _capacity = capacity; _size = 0; } private: T* _array; size_t _capacity; size_t _size; }; 使用类的模版后，我们就可以==创建多个存有不同数据类型==的栈了。\n而使用typedef或using就只能创建存有同一种数据类型的栈\nC++中喜欢用using替代typedef。\n例如：using STDataType = int;\n3.2 类模版的实例化 类模版一般是显示实例化，即类名\u0026lt;显示传类型\u0026gt; 对象\n==类模板名字不是真正的类，而实例化的结果才是真正的类==\n1 2 3 4 5 6 7 8 9 int main() { //实例化生成对应的类，这里是两个不同的类型 //Stack是类名，Stack\u0026lt;int\u0026gt;才是类型 Stack\u0026lt;int\u0026gt; st1; //存储int的栈 Stack\u0026lt;double\u0026gt; st2; //存储double的栈 return 0; } 注意：\n==模版一般不会声明和定义分离== 要么全写在.h要么全写在.cpp ==类模版使用时不能用类名代表类型==，必须加上模版参数才是类型（也就是必须显示调用模版） 如果在类里面声明和定义分离写，那么类域应该写为类名\u0026lt;T\u0026gt;::\n1 2 3 4 5 6 7 //再次声明 template\u0026lt;class T\u0026gt; void Stack\u0026lt;T\u0026gt;::Push(const T\u0026amp; data) { //... _arr[_size++] = data; } 类模板中的成员函数都是函数模板\n4.STL简介 4.1什么是STL STL（standard template libaray 标准模版库）：==是C++标准库的重要组成部分==。\n不仅是一个可复用的组件库，而且是一个==包罗数据结构与算法的软件框架==。\nIO流、智能指针、线程库\u0026hellip;不属于STL\n4.2 STL的版本 原始版本\nAlexander Stepanov、Meng Lee 在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使用。\nHP 版本是所有STL实现版本的始祖\nP. J. 版本\n由P. J. Plauger开发，继承自HP版本，被**Windows Visual C++**采用，不能公开或修改，\n缺陷：可读性比较低，符号命名比较怪异。\nRW版本\n由Rouge Wage公司开发，继承自HP版本，被C+ + Builder 采用，不能公开或修改，可读性一般\nSGI版本\n由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版 本。被**GCC(Linux)**采用，可移植性好，可公开、修改甚至贩卖，从命名风格和编程 风格上看，阅读性非常高。我们后面学习STL要阅读部分源代码，主要参考的就是这个版本\n4.3 STL的六大组件 容器 - 就是我们常见的数据结构 算法 - 空间配置器 - 内存池，给容器（数据结构）提供内存，提高效率 迭代器 仿函数 配接器 4.3 STL的重要性 笔试\n面试\n工作\n4.4如何学习STL 学习STL的三种境界\n熟用STL 了解泛型技术的内涵与STL的学理乃至实作 扩充STL 简单总结一下：学习STL的三个境界：能用，明理，能扩展\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"【C++基础】初识C++（上） 1.C++简介 1.1C++的发展历史 C++起初是Bjarne Stroustrup在贝尔实验室从事研究工作时感受到了C语言的不足，然后在C语言的基础上添加了面向对象的特性，在1983年正式命名为C++\nC++兼容C语言，C++中文件的后缀一般使用.cpp\nLinux下要用g++编译，不再是gcc\n1.2 C++的版本更新 C++革命性的版本更新主要为 C++98 C++11 C++20\n1.3 C++的经典书籍 语法方面：\n左边的这本是C++第一个编译器作者所写\n右边的这本是C++之父所写\n改善程序和设计：\n包含专家的经验和心得\nC++标准库相关：\n2.第一个C++程序 1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 3. 输入输出IO流 4.缺省参数 5.函数重载 6.引用 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"C++核心教程 1. 内存分区函数 1.1 程序运行前 1.2 程序运行中 1.3 new的基本语法 1、在堆区创建整型数据 语法：==new 数据类型()==\nnew返回的是 ==该数据类型的指针==\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { //new返回的是 该数据类型的指针 int* p = new int(10); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; return 0; } 如果想释放堆区的数据，利用关键字delete ==delete 指针变量==\n堆区的数据由管理员开辟，程序员管理释放\n如果想释放堆区的数据，利用关键字delete\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int* func() { int* p = new int(10); return p; } int main() { int* p = func(); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //释放堆区的数据 delete p; //内存已经被释放，再次访问就是非法访问，会报错 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; return 0; } 我们发现前三次正常读取，释放掉堆区的数据后，再次读取该数据就报错了\n2、在堆区利用new开辟数组 语法：==new 数据类型[]==\n返回的是这块连续空间的首地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { //在堆区创建含有10个整型数据的数组 int* arr = new int[10];//10代表数组有10个元素 for (int i = 0; i \u0026lt; 10; i++) { arr[i] = i + 100;//给10个元素赋值，100~109 } for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 释放数组的时候 **要加上[]**才可以 ==delete[] 数组名==\n1 delete[] arr; 2. 引用 2.1 引用的基本使用 **作用：**给变量起别名\n语法：数据类型\u0026amp; 别名 = 原名\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int a = 10; int\u0026amp; b = a; cout \u0026lt;\u0026lt; \u0026amp;b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; b = 100; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 2.2 引用的注意事项 引用必须初始化\n1 int\u0026amp; b;//错误 引用一旦初始化后，不可以改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int a = 10; int\u0026amp; b = a; //引用在初始化后，不可以改变 int c = 20; b = c;//赋值操作，而不是更改引用 cout \u0026lt;\u0026lt; \u0026#34;\u0026amp;a = \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\u0026amp;b = \u0026#34; \u0026lt;\u0026lt; \u0026amp;b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\u0026amp;c = \u0026#34; \u0026lt;\u0026lt; \u0026amp;c \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 引用必须引一块合法的内存空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int a = 10; //引用必须引一块合法的内存空间 //int\u0026amp; ref = 10;//错误 //加上const之后，编译器相当于将代码修改成 //const int temp = 10; const int\u0026amp; ref = temp; const int\u0026amp; ref = 10; //ref = 20;//加上const后，变为只读，不可修改 return 0; } ​\n2.3 引用做函数参数 **作用：**函数传参时，可以利用引用技术让==形参修饰实参==\n**优点：**可以==简化指针==修改实参\n函数传参的三种方式\n值传递：形参的改变不会影响实参 地址传递：形参的改变会影响实参 引用传递：形参的改变会影响实参 地址传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void Swap(int* x, int* y) { int temp = *x; *x = *y; *y = temp; } int main() { int a = 10, b = 20; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; Swap01(a, b); //交换后 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 引用传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void Swap02(int\u0026amp;x, int\u0026amp;y) { int temp = x; x = y; y = temp; } int main() { int a = 10, b = 20; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; Swap02(a, b); //交换后 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更简单\n2.4 引用做函数返回值 **作用：**引用可以作为函数的返回值存在\n注意：不要返回局部变量引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int\u0026amp; test01() { //局部变量，存放在栈区 int a = 10; return a; } int main() { int\u0026amp; ref = test01(); cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl;//第一次结果正确，是因为编译器做了保留 cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl;//第二次结果错误，因为a的内存已经释放 return 0; } **用法：**函数调用作为左值\n左值：等号的左边叫左值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int\u0026amp; test02() { static int a = 10;//静态变量，存放全局区，程序结束后，由系统释放 return a; } int main() { int\u0026amp; ref2 = test02(); cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; test02() = 1000;//变量a被修改 cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; return 0; } 2.5 引用的本质 本质：引用的本质是在C++内部实现是一个指针常量\n指针常量：指针的指向不可改变，指针指向的值可以改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //发现是引用，转换为int* const ref = \u0026amp;a; void func(int\u0026amp; ref) { ref = 100;//ref是引用，转换为*ref = 100; } int main() { int a = 10; //自动转换成 int* const ref = \u0026amp;a; 指针的指向不可变 //所以说，引用一旦初始化就不能更改了 int\u0026amp; ref = a; ref = 20;//内部发现ref是引用，自动帮我们转换为：*ref = 20; cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref:\u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl;//自动转换成*ref func(a); return 0; } **结论：**C++推荐引用技术，因为语法方便，引用的本质是指针常量，但是所有的指针操作编译器都帮我们做了\n2.6 常量引用 **作用：**常量引用主要用来修饰形参，防止误操作\n在函数形参列表中，可以加const修饰形参，防止形参改变实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 void showValue(const int\u0026amp; val) { //val = 1000;错误 cout \u0026lt;\u0026lt; \u0026#34;val = \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } int main() { int a = 10; showValue(a); return 0; } 3. 函数提高 3.1 函数的默认参数 在C++中，函数的形参列表中的形参是可以有默认值的。\n如果传了参数，那么就用传的参数；如果没传，那么就用函数的默认参数\n语法：返回类型 函数名 (参数 = 默认值){}\n注意：\n如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值// 1 2 3 4 5 6 7 8 9 10 11 12 //int func(int a, int b = 20, int c)//错误 int func(int a, int b = 20, int c = 30) { return a + b + c; } int main() { cout \u0026lt;\u0026lt; func(10) \u0026lt;\u0026lt; endl; return 0; } 缺省参数不能在函数声明和定义中同时出现，规定只能在函数声明给缺省值 3.2 函数的占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法：返回值类型 函数名 （数据类型）{} 1 2 3 4 5 6 7 8 9 10 11 void func(int a, int) { cout \u0026lt;\u0026lt; \u0026#34;this is func\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func(10, 10);//占位参数必须填补,除非写了默认值 return 0; } 占位参数也可以有默认值\n1 2 3 4 void func(int a, int = 10) { cout \u0026lt;\u0026lt; \u0026#34;this is func\u0026#34; \u0026lt;\u0026lt; endl; } 3.3函数重载 3.3.1 函数重载概述 **作用：**函数名可以相同，提高复用性\n函数重载满足条件：\n同一个作用域下 函数名称相同 函数参数的 类型/个数/顺序 ==至少一个不同== 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void func() { cout \u0026lt;\u0026lt; \u0026#34;func() 的调用\u0026#34; \u0026lt;\u0026lt; endl; } //参数个数不同 void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;func(int a) 的调用\u0026#34; \u0026lt;\u0026lt; endl; } //参数类型不同 void func(double a) { cout \u0026lt;\u0026lt; \u0026#34;func(double a) 的调用\u0026#34; \u0026lt;\u0026lt; endl; } //参数顺序不同 void func(int a, double b) { cout \u0026lt;\u0026lt; \u0026#34;func(int a, double b) 的调用\u0026#34; \u0026lt;\u0026lt; endl; } void func(double a, int b) { cout \u0026lt;\u0026lt; \u0026#34;func(double a, int b) 的调用\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func(); func(1); func(3.14); func(1, 3.14); func(3.14, 1); return 0; } **注意：**函数的返回值不可以作为函数重载的条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int func(int a, double b) { cout \u0026lt;\u0026lt; \u0026#34;func(int a, double b) 的调用\u0026#34; \u0026lt;\u0026lt; endl; } double func(int a, double b) { cout \u0026lt;\u0026lt; \u0026#34;func(double a, int b) 的调用\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func(1, 3.14);//有歧义，编译器不知道调哪个函数 return 0; } 3.2 函数重载注意事项 引用作为重载条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void func(int\u0026amp; a)//int\u0026amp; a = 10 不合法，引用必须引用一个合法的空间 { cout \u0026lt;\u0026lt; \u0026#34;func(int\u0026amp; a) 调用\u0026#34; \u0026lt;\u0026lt; endl; } //加上const后，编译器相当于会创建一个临时的数据，然后让a指向那块临时的空间 void func(const int\u0026amp; a)//const int\u0026amp; a = 10 { cout \u0026lt;\u0026lt; \u0026#34;func(const int\u0026amp; a) 调用\u0026#34; \u0026lt;\u0026lt; endl; } int main() { int a = 20; func(a); func(10); return 0; } ​\n函数重载碰到函数默认参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //参数不同，构成重载 void func2(int a, int b = 10) { cout \u0026lt;\u0026lt; \u0026#34;func2(int a, int b)的调用\u0026#34; \u0026lt;\u0026lt; endl; } void func2(int a) { cout \u0026lt;\u0026lt; \u0026#34;func2(int a, int b)的调用\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func2(10);//调用时会出错，存在歧义 return 0; } 4. 类和对象 C++面向对象的三大特性为：==封装、继承、多态==\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\n例如：\n​\t人可以作为对象，属性有姓名、年龄、身高、体重\u0026hellip;，行为有走、跑、跳、吃饭\n​\t车也可以作为对象，属性有轮胎、方向盘、车灯\u0026hellip;，行为有载人、放音乐、放空调\u0026hellip;\n​\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\n4.1 封装 4.1.1 封装的意义： 将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制\n​\n封装的意义1：\n将属性和行为作为一个整体，表现生活中的事物\n语法：class 类名{ 访问权限: 属性 / 行为};\n**示例1：**设计一个圆类，求圆的周长\n圆求周长的公式：2 * PI * 半径\nclass 代表设计一个类，类后面紧跟着的就是类名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const double PI = 3.14; class Circle { public: //属性：半径 int m_r; //行为：获取圆的周长 double calculateZC() { return 2 * PI * m_r; } }; int main() { //通过圆类 创建具体的圆（对象） Circle c1; //给圆对象的属性进行赋值 c1.m_r = 10; //2 * PI * 10 = 62.8; cout \u0026lt;\u0026lt; \u0026#34;圆的周长为：\u0026#34; \u0026lt;\u0026lt; c1.calculateZC() \u0026lt;\u0026lt; endl; return 0; } **示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;string\u0026gt; class Student { public: //属性 string m_Name; //姓名 int m_Id; //学号 //行为 //显示学生姓名和学号 void showStudent() { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; m_Name \u0026lt;\u0026lt; \u0026#34; 学号：\u0026#34; \u0026lt;\u0026lt; m_Id \u0026lt;\u0026lt; endl; } }; int main() { //创建一个具体学生 实例化对象 Student s1; //给s1对象进行属性赋值操作 s1.m_Name = \u0026#34;张三\u0026#34;; s1.m_Id = 1234567; //显示学生信息 s1.showStudent(); return 0; } 类中的属性和行为 我们统称为成员\n属性 \u0026mdash; 成员属性 成员变量\n行为 \u0026mdash; 成员函数 成员方法\n封装的意义2：\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n访问权限有三种：\npublic 公共权限 protected 保护权限 private私有权限 示例：\n1 2 3 //public 公共权限 成员类内可以访问，类外可以访问 //protected 保护权限 成员类内可以访问，类外不可以访问 //private 私有权限 成员类内可以访问，类外不可以访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Person { public: //公共权限 string m_Name; //姓名 protected: //保护权限 string m_Car; //汽车 private: //私有权限 int m_Password; //银行卡密码 private: void func() { //可以访问类内的私有或保护修饰的成员 m_Name = \u0026#34;张三\u0026#34;; m_Car = \u0026#34;拖拉机\u0026#34;; m_Password = 123456; } }; int main() { //实例化具体对象 Person p1; p1.m_Name = \u0026#34;李四\u0026#34;; //p1.m_Car = \u0026#34;奔驰\u0026#34;;//保护权限内容，在类外访问不到 //p1.m_Password = 123;//私有权限内容，在类外访问不到 return 0; } 4.1.2 class和struct的区别 class 定义成员没有被访问限定符修饰时默认为private struct 默认为public 4.1.3 成员属性设置为私有 4.2 对象的初始化和清理 构造函数 1.构造函数的分类 按参数分类：无参构造（默认构造函数） 和 有参构造\n按照类型分类：普通构造 和 拷贝构造\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Person { public: //构造函数 Person() { _age = 1; cout \u0026lt;\u0026lt; \u0026#34;Person的无参构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } Person(int age) { _age = age; cout \u0026lt;\u0026lt; \u0026#34;Person的有参构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 Person(const Person\u0026amp; p) { //将传入的人身上的所有属性，拷贝到我身上 _age = p._age; } //析构函数 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person的析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } private: int _age; }; 2.构造函数的调用 1）括号法\n1 2 3 Person p;//默认构造函数调用 Person p2(10);//有参构造函数 Person p3(p2);//拷贝构造函数 注意事项：\n调用默认构造函数时候，不要加 ()\n因为编译器会认为是函数声明，不会认为是在创建对象\n在一个函数体内部是可以写另一个函数的声明的\n2）显示法\n1 2 3 Person p1; Person p2 = Person(10);//有参构造 Person p3 = Person(p2);//拷贝构造 注意事项1：\n显示法等号的右侧，是匿名对象\n特点：当前行执行结束后，系统会立即回收掉匿名对象\n1 2 Person(10);//匿名对象 特点：当前执行结束后，系统会立即回收掉匿名对象 cout \u0026lt;\u0026lt; \u0026#34;aaaaa\u0026#34; \u0026lt;\u0026lt; endl; 注意事项2：\n不要利用拷贝构造函数来初始化匿名对象，编译器会认为这是一个对象的声明\n1 Person(p3);//编译器会认为Person(p3) 等价于 Person p3; 3）隐式转换法\n1 2 Person p4 = 10;//相当于写了 Person p4 = Person(10); Person p5 = p4;//拷贝构造 3.拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况\n使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 4.3 C++对象模型和this指针 4.4 友元 4.5 运算符重载 4.6 继承 4.7 多态 5. 文件操作 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n前言 C语言中字符函数和字符串函数是非常重要的，可以方便我们对字符和字符串进行处理。本文中主要介绍几种常见的字符函数和字符串函数。\n一.strlen求字符串长度 1. strlen函数 strlen函数的介绍\n1 size_t strlen ( const char * str ); 字符串的结束标志是 \\0 strlen 函数是用来求字符串的长度的，是从字符串的第一个字符开始往后统计字符个数， 遇到 \\0 就停止统计，如果没有遇到 \\0 ,就会一直往后统计，直到遇到 \\0 才会停止统计 所以strlen是用来统计字符串 \\0 之前的字符个数的函数 需要注意的是strlen函数返回的是无符号整型 strlen函数返回的无符号整型的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { if (strlen(\u0026#34;abc\u0026#34;) - strlen(\u0026#34;abcdef\u0026#34;) \u0026gt; 0) { printf(\u0026#34;hehe\\0\u0026#34;);//输出结果为hehe } else { printf(\u0026#34;haha\\n\u0026#34;); } return 0; } 分析：\nstrlen返回的是无符号整型，两个无符号整型相减的结果也应为无符号整型 所以应该将strlen(\u0026ldquo;abc\u0026rdquo;) - strlen(\u0026ldquo;abcdef\u0026rdquo;)的到的结果 -3 转为无符号整型，\n由于整型在内存中是以补码方式进行存储的，所以要先得到-3的补码，\n然后再将补码的符号位改为0。\n-3的原码为 10000000 00000000 00000000 00000011\n-3的反码为 11111111 11111111 11111111 11111100\n-3的补码为 11111111 11111111 11111111 11111101\n转成无符号数 01111111 11111111 11111111 11111101\n可以看出，-3转为无符号整型后的结果是一个非常大的数，\n因此，上面代码的输出结果为hehe\n实现strlen函数的三种方法\n方法一：计数器\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;assert.h\u0026gt; size_t my_strlen(const char* str) { int count = 0; assert(str != NULL); while (*str != \u0026#39;\\0\u0026#39;)//while(*str) { count++;//统计个数 str++; } return count; } 定义一个变量count来统计字符个数，如果该字符不是 \\0 ，则count++，最后返回count的值\n方法二：指针-指针\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;assert.h\u0026gt; size_t my_strlen(const char* str) { assert(str != NULL);//检测指针的有效性 char* start = str;//记录起始地址 while (*str != \u0026#39;\\0\u0026#39;) { str++; } return str - start; } 指针-指针的绝对值是指针和指针之间元素的个数\n要统计字符串中的字符个数，首先要得到该字符串的起始地址和结束地址（\\0前的地址），然后将两地址相减，得到的就是字符串之间的字符个数\n方法三：递归方式\n1 2 3 4 5 6 7 8 9 10 11 size_t my_strlen(const char* str) { if (*str != \u0026#39;\\0\u0026#39;) { return 1 + my_strlen(str + 1); } else { return 0; } } 因为统计字符串的长度是先从首字符开始的，所以如果首字符是 \\0 ,那么该字符串长度就为0，如果首字符不是 \\0 的，那么该字符串中至少有1个不为 \\0 的有效字符，字符串的长度就是1+后面字符的个数，依次类推\n假设求的是字符串 “abcd” 的长度，那么用递归求解的具体步骤如下：\n首字符是 a ，不是 \\0 ，字符串 “abcd\\0” 的长度为 1 + “bcd\\0”的长度 “bcd\\0”首字符是 b ,不是 \\0 ,字符串 \u0026ldquo;bcd\\0\u0026rdquo; 的长度为 1 + “cd\\0”的长度 “cd\\0”的首字符是 c ，不是 \\0 ，字符串“cd\\0”的长度为 1 + “d\\0”的长度 “d\\0”的首字符是 d ，不是 \\0 ，字符串“d\\0”的长度为 1 + “\\0” 的长度 “\\0”的首字符是 \\0 ，由于字符串统计的是\\0之前的字符个数，因此“\\0”长度为0 最后得出字符串“abcdef”的长度为0+1+1+1+1 = 4 二.长度不受限制的字符串函数 1. strcpy字符串拷贝函数 strcpy 函数的介绍\n1 char * strcpy ( char * destination, const char * source ); strcpy 是字符串拷贝函数\n有两个形参，第一个形参是目标字符串，第二个形参是源字符串，该函数是将源字符串里的内容拷贝到目标字符串，当拷贝完源字符串里的 \\0 后就停止拷贝，并返回目标空间的起始地址\n需要注意的是：\n目标字符串的空间一定要大于源字符串所占的空间大小 目标字符串必须可修改 要拷贝源字符串中的 \\0 模拟实现strcpy\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;assert.h\u0026gt; char* my_strcpy(char* dest, const char* src) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); //拷贝src中的字符串到dest指向的空间，包含\\0 while (*dest++ = *src++)//当\\0拷贝过去后，结果为假，停止循环 { ; } return ret;//返回目标空间的起始地址 } 思路如下：\n1.找到目标字符串的起始地址和源字符串的起始地址\n2.将目标字符串的起始地址存一份\n3.从源字符串起始字符开始，依次拷贝到目标字符串，当拷贝完源字符串中的\\0后就停止拷贝\n4.返回目标字符串的起始地址\n2. strcat字符串追加函数 strcat 函数的介绍\n1 char * strcat ( char * destination, const char * source ); strcat是字符串追加函数，作用是将源字符串拷贝到目标字符串的结束位置处，\n返回的是目标空间的起始地址。\n需要注意的是：\n源字符串的首字符要覆盖目标字符串的 \\0 要拷贝源字符串的\\0 目标字符串要保证可以被修改，并且空间能容纳追加后的字符串 不保障自己给自己追加（ \\0 被覆盖 ） 模拟实现strcat\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;assert.h\u0026gt; char* my_strcat(char* dest, const char* src) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); while (*dest != \u0026#39;\\0\u0026#39;)//找\\0 { dest++; } while (*dest++ = *src++) { ; } return ret; } 1.找到目标字符串中 \\0 的地址并存一份\n2.找到源字符串的起始地址和结束地址（包含\\0）\n3.源字符串的起始字符拷贝时，要覆盖目标字符串中的\\0\n源字符串起始字符之后的字符依次拷贝到目标字符串的结尾处\n当拷贝完\\0后就停止拷贝\n4.返回目标空间的起始地址\n3. strcmp字符串比较函数 strcmp函数的介绍\n1 int strcmp ( const char * str1, const char * str2 ); strcmp是字符串比较函数，用来比较两字符串对应位置上字符的大小\n如果第一个字符串对应位置上的字符大于第二个字符串对应位置上的字符，那么返回的是大于0的数字 如果第一个字符串对应位置上的字符小于第二个字符串对应位置上的字符，那么返回的是小于0的数字 如果第一个字符串对应位置上的字符等于第二个字符串对应位置上的字符，那么返回0 注意：两字符串不能被修改\n模拟实现strcmp，更符合VS的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;assert.h\u0026gt; int my_strcmp(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2); while (*str1 == *str2)//对应字符相等的情况 { if (*str1 == \u0026#39;\\0\u0026#39;)//两字符串相等 { return 0; } str1++; str2++; } //对应字符不相等的情况 if (*str1 \u0026gt; *str2)//大于 { return 1; } else//小于 { return -1; } } 模拟实现strcmp，更符合C语言标准的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;assert.h\u0026gt; int my_strcmp(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2); while (*str1 == *str2)//对应字符相等的情况 { if (*str1 == \u0026#39;\\0\u0026#39;)//两字符串相等 { return 0; } str1++; str2++; } //对应字符不相等的情况 return (*str1 - *str2); } 思路如下：\n1.找到两个字符串的起始地址\n2.从两字符串的起始字符开始比较，比较的结果有三种情况：相等，大于和小于\n（1）如果对应字符相等，那么就继续看这两个字符是否为\\0，如果是，那么两字符串相等，\n​ 如果不是，那么就继续往后比较\n（2）如果对应字符不相等，那么就看两字符相减的结果是否大于0，\n​ 如果结果大于0，那么就说明第一个字符串大于第二个字符串，\n​ 如果结果小于0，那么就说明第一个字符串小于第二个字符串\n三.长度受限制的字符串函数 长度受限制的字符串函数可以指定要操作的字符个数，比如strncpy函数可以指定拷贝源字符串中多少个字符到目标字符串中，而不是一定要找到 \\0 才停止拷贝\n1. strncpy strncpy函数的介绍\n1 char * strncpy ( char * destination, const char * source, size_t num ); strncpy函数可以指定拷贝源字符串中多少个字符到目标字符串中\n不追加 \\0 但是如果指定拷贝源字符串的字符个数如果大于源字符串的长度，那么超出的部分就在目标字符串后面补 \\0 使用该函数要保证目标空间能容纳拷贝后的字符串和目标字符串可修改 strncpy的使用\n1 2 3 4 char arr1[10] = \u0026#34;abcdefgh\u0026#34;; char arr2[] = \u0026#34;hello\u0026#34;; strncpy(arr1, arr2, 5); printf(\u0026#34;%s\\n\u0026#34;, arr1);//输出hellofgh 模拟实现strncpy\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;assert.h\u0026gt; char* my_strncpy(char* dest, const char* src, size_t num) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); //拷贝src中的字符串到dest指向的空间 while (num \u0026amp;\u0026amp; (*dest++ = *src++)) { num--; } //提前遇到源字符串中的\\0 if (num) { while (--num) { *dest++ = \u0026#39;\\0\u0026#39;;//超出的长度用\\0来补 } } return ret;//返回目标空间的起始地址 } 2. strncat strncat函数的介绍\n1 char * strncat ( char * destination, const char * source, size_t num ); strncat函数可以指定追加源字符串的多少个字符到目标字符串的结束位置\n追加完指定个数的字符后，会自动在目标字符串后面再追加一个\\0 可以实现自己给自己追加 使用该函数要保证目标空间能容纳拷贝后的字符串和目标字符串可修改 strncat的使用\n1 2 3 4 char arr1[20] = \u0026#34;hello \u0026#34;; char arr2[] = \u0026#34;world\u0026#34;; strncat(arr1, arr2, 3); printf(\u0026#34;%s\\n\u0026#34;, arr1);//输出hello wor 模拟实现strncat\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;assert.h\u0026gt; char* my_strncat(char* dest, const char* src, size_t num) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); while (*dest != \u0026#39;\\0\u0026#39;)//找目标字符串的\\0 { dest++; } while (num --) { if ((*dest++ = *src++) == 0) { return ret; } } *dest = \u0026#39;\\0\u0026#39;; return ret; } 3. strncmp strncmp函数的介绍\n1 int strncmp ( const char * str1, const char * str2, size_t num ); strncmp函数，可以指定要比较的字符个数\n如果指定的字符个数大于源字符串的长度，那么就用 \\0 和目标字符串的对应字符相比较\n如果两字符都比较完了，但还没到指定的比较次数\nstrncmp的使用\n1 2 3 4 const char* p1 = \u0026#34;abcdef\u0026#34;; char* p2 = \u0026#34;abckjy\u0026#34;; int ret = strncmp(p1, p2, 4);//比较前4个字符 printf(\u0026#34;%d\\n\u0026#34;, ret);//输出小于0的数 模拟实现strncmp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;assert.h\u0026gt; int my_strncmp(const char* str1, const char* str2, size_t num) { assert(str1 \u0026amp;\u0026amp; str2); while (num--) { if (*str1++ != *str2++) { return (*str1 - *str2);//两字符串字符不相等 } //比较的字符个数大于两字符串的长度 else if (*(str1 - 1) == \u0026#39;\\0\u0026#39;) { return 0;//两字符串相等 } } return 0;//两字符串相等 } 四.字符串查找 1.strstr strstr的介绍\n1 const char * strstr ( const char * str1, const char * str2 ); strstr是用来查找目标字符串中是否存在子串的函数，\n若查找到，则返回目标字符串中第一次出现子串的起始地址，若未查找到，则返回空指针\nstrstr函数的使用\n1 2 3 4 5 6 7 8 9 10 11 char* p1 = \u0026#34;hello world hello world\u0026#34;; char* p2 = \u0026#34;world\u0026#34;; char* ret = strstr(p1, p2); if (ret == NULL) { printf(\u0026#34;子串不存在\\n\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, ret);//输出world hello world } 模拟实现strstr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;assert.h\u0026gt; char* my_strstr(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2);//保证不为野指针 if (*str2 == NULL)//要查找的为空字符串 { return str1;//规定返回str1 } //查找的逻辑 char* s1 = str1; char* s2 = str2; char* cur = str1;//记录有可能匹配成功的地址 while (*cur) { s1 = cur; s2 = str2; while ((*s1 == *s2) \u0026amp;\u0026amp; (*s1 != \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (*s2 != \u0026#39;\\0\u0026#39;)) { s1++; s2++; } if (*s2 == \u0026#39;\\0\u0026#39;) { return cur;//找到子串 } cur++;//未匹配成功，尝试从下一个位置匹配 } return NULL;//找不到子串 } str函数查找部分的思路\n(str1 指向目标字符串的起始地址，str2指向子字符串的起始地址)\n\\1. 创建两个新的字符指针s1和s2分别存放str1 和str2\n\\2. 再创建一个字符指针cur，用于记录有可能匹配成功的地址\n\\3. 将cur 赋给s1，让s1向后查找，看当两字符串的对应字符是否相等\n如果相等，就让两字符串依次向后比较字符（str1++，str2++） 如果在比较的过程中发现两字符串有一个字符不相等那么退出本次查找，下一次则从记录位置的下一个位置开始查找（cur++）\n如果比较过程中发现 *s2 等于 \\0（找到子串），或 *s1 等于\\0（没找到 / 找到），则停止查找，再判断 *s2 是否等于 \\0，如果是 ，则返回 cur 存的第一次出现子串的起始地址\n如果不相等，那么说明本次未匹配成功，需要尝试从下一个位置匹配（cur++） \\4. 当发现 *cur 等于 \\0 时，说明未查找到子串，就停止查找，并返回NULL\n五.错误信息报告 1. strerror strerror 函数的介绍\n1 char * strerror ( int errnum ); 当我们在使用C语言标准库中的函数的时候，如果这些函数出错了，那么就会返回错误码，strerror函数可以将错误码对应的错误信息（字符串）的起始地址返回\nerrno 是记录当前错误码的全局变量 这些错误码一般是放在errno.h这个头文件中说明的 只适用于库函数出错时 编辑\nstrerror函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;errno.h\u0026gt; int main() { //fopen 打开文件 FILE* pf = fopen(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;);//\u0026#34;r\u0026#34;-以读文件形式，打开文件 if (pf == NULL)//如果这个文件不存在，就打开失败，返回空指针 { //只适用于库函数 printf(\u0026#34;打开文件失败，原因是：%s\u0026#34;, strerror(errno)); return 1; } else { printf(\u0026#34;打开文件成功\u0026#34;); //... fclose(pf);//关闭文件 pf = NULL; } return 0; } 2.perror 1 void perror ( const char * str ); perror函数是将 errno 中错误码对应的错误信息打印\n先打印str指向的字符串，打印冒号，再打印一个空格，再打印错误码对应的错误信息\n例如：\n编辑\nstrerror 和perror 的区别： strerror 只是拿到错误码对应错误信息的字符串的地址，而perror是直接将错误码对应的错误信息打印\n六.字符函数 1.字符分类函数 字符分类函数是C标准库中的一组函数，用于对字符进行分类和判断。这些函数返回值为真或假，通常以整数0或 非0表示。\n编辑\n空白字符： 空格\u0026rsquo; \u0026lsquo;，换页 \u0026lsquo;\\f\u0026rsquo; , 换行 \u0026lsquo;\\n\u0026rsquo; , 回车 \u0026lsquo;\\r\u0026rsquo; , 垂直制表符 \u0026lsquo;\\v\u0026rsquo; 等\n数字字符：\u0026lsquo;0\u0026rsquo; ~ \u0026lsquo;9\u0026rsquo; 的字符\n控制字符：控制文本显示或者通信流程的特殊字符，比如：回车 \u0026lsquo;\\r\u0026rsquo;, 制表符\u0026rsquo;\\t\u0026rsquo; , 换页 \u0026lsquo;\\f\u0026rsquo; 等\n十六进制的字符：包括所有十进制的数字字符，字母 af , AF\n1.1 islower函数 ：判断是否为小写字母\n1 int islower ( int c ); 函数的使用\n1 2 3 4 5 int ret = islower(\u0026#39;A\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, ret);//0 int retu = islower(\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, retu);//非0 函数的应用：写一个代码，将一个字符串中的小写字母转大写，其它字符不变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;ctype.h\u0026gt; int main() { char arr[] = \u0026#34;I am a Student.\u0026#34;; int i = 0; while (arr[i] != \u0026#39;\\0\u0026#39;) { if (islower(arr[i])) { arr[i] -= 32; } i++; } printf(\u0026#34;%s\\n\u0026#34;, arr);//输出 I AM A STUDENT. return 0; } **1.2 isdigit函数：**判断是否为数字字符\n1 int isdigit ( int c ); 函数的使用\n1 2 int ret = isdigit(\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, ret);//0 2.字符转换函数 2.1 toupper 小写转大写函数 1 int toupper ( int c ); 函数的使用\n1 2 char ch = toupper(\u0026#39;a\u0026#39;); printf(\u0026#34;%c\\n\u0026#34;, ch);//A 2.2tolower 大写转小写函数 1 int tolower ( int c ); 函数的使用\n1 2 char ch = tolower(\u0026#39;A\u0026#39;); printf(\u0026#34;%c\\n\u0026#34;, ch);//a ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n引言 我们之前学过strcpy, strcmp, strcat ，strncpy 等和字符串相关的函数，这些函数的操作对象是字符串和\\0，我们无法直接用这些函数完成对浮点型，整型，结构体等类型的数据进行这类操作，这时我们就需要使用到内存相关的函数\n基本介绍 内存相关的函数主要是针对内存块的，可以处理任意类型的数据 操作数据时是以字节为单位进行操作的 内存相关的函数可以接收任意类型的指针（void*），然后其强制转换成字符型指针，再通过一个字节一个字节地操作，最后完成对整个数据的操作\n使用要包含头文件 string.h 一. memcpy 内存拷贝函数 1. 基本介绍 1 void * memcpy ( void * destination, const void * source, size_t num ); memcpy函数作用：只要是放在内存里的数据，就都可以进行拷贝 返回的值：返回的是目标空间的起始地址 形参列表分别对应：目标空间的地址，源空间的地址，要拷贝的字节个数 函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;string.h\u0026gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; int arr2[10] = { 0 }; //将arr1中的3,4,5,6,7拷贝放到arr2中 memcpy(arr2, arr1 + 2, 20);//拷贝5个整型--20字节 for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d \u0026#34;, *(arr2 + i)); } //输出结果3 4 5 6 7 0 0 0 0 0 return 0; } 2. 使用细节 形参列表中的第三个参数指的是要拷贝的字节个数 memcpy函数不负责重叠内存的拷贝 比如 int arr1[ ] = {1,2,3,4,5,6,7}，\n不能使用memcpy函数将arr1里面的1, 2, 3，4拷贝到 arr1 里的3, 4, 5, 6位置上\n原因：当把 1 拷贝到 3 的位置上后，数字3就被覆盖了；当把 2拷贝到 4 的位置上后，数字4就被覆盖了，此后就一直循环拷贝 1, 2\n3. 模拟实现 思路：\n记录目标空间的起始地址(用于最后返回) 强转为字符型指针，原因：void*类型的指针不能进行解引用操作，也不能进行加减运算 循环赋值/拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;assert.h\u0026gt; void* my_memcpy(void* dest, const void* src, size_t num) { void* ret = dest;//记录目标空间的起始地址 assert(dest \u0026amp;\u0026amp; src); while (num--)//循环赋值/拷贝 { *((char*)dest) = *((char*)src);//强转为字符型指针 dest = (char*)dest + 1; src = (char*)src + 1; } return ret;//返回目标空间的起始地址 } 二. memmove 内存移动函数 1. 基本介绍 1 void * memmove ( void * destination, const void * source, size_t num ); memmove函数作用：负责重叠内存的拷贝 返回的值：返回的是目标空间的起始地址 形参列表分别对应：目标空间的地址，源空间的地址，要拷贝的字节个数 函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;string.h\u0026gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; memmove(arr1 + 2, arr1, 20);//将1,2,3,4,5拷贝到3,4,5,6,7处 for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d \u0026#34;, *(arr1 + i)); } //输出结果：1,2,1,2,3,4,5,6,7,8，9,10 return 0; } 2. 使用细节 形参列表中的第三个参数指的是要拷贝的字节个数 C语言标准规定，memcpy只要能实现不重叠的拷贝就行，重叠的拷贝由memmove实现 ​ 在VS上memcpy可以实现重叠内存的拷贝，但在其它编译器上不保证能实现\n3. 模拟实现 思路：\n1.记录目标空间的起始地址 2.强转为char*类型 3.分情况拷贝 情况1:当源的起始地址小于目的地的起始地址时，从后往前拷贝 情况2：当源的起始地址大于目的地的起始地址时，从前往后拷贝 原因：数组随着下标的增长，地址是由低到高变化的 4.返回目标空间的起始地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;assert.h\u0026gt; void* my_memmove(char* dest, char* src, size_t num) { void* ret = dest; assert(dest \u0026amp;\u0026amp; src); if (src \u0026lt; dest)//从后往前拷贝 { while (num--) { *((char*)dest + num ) = *((char*)src + num); } } else//从前往后拷贝 { while (num--) { *((char*)dest) = *((char*)src); dest = ((char*)dest) + 1; src = ((char*)src) + 1; } } return ret;//返回目标空间的起始地址 } 编辑\n三. memset 内存设置函数 1. 基本介绍 1 void * memset ( void * ptr, int value, size_t num ); memset函数是用来设置内存的，可以更改内存块中任意类型的数据 返回类型：返回的是目标空间的起始地址 形参列表分别对应：从哪开始设置内存块，设置成什么内容，总共要设置几个字节 函数的使用1\n1 2 3 4 5 6 7 8 9 #include\u0026lt;string.h\u0026gt; int main() { char arr[] = \u0026#34;hello world\u0026#34;; memset(arr + 6, \u0026#39;*\u0026#39;, 5); printf(\u0026#34;%s\\n\u0026#34;, arr); //输出结果 hello ***** return 0; } 函数的使用2\n1 2 3 4 5 6 7 8 9 #include\u0026lt;string.h\u0026gt; int main() { int arr[10] = { 0 }; memset(arr, 1, 10);//改前10个字节为1 //arr中前10个字节 01 01 01 01 01 01 01 01 01 01 //arr中的数值为 16843009 16843009 257 0 0 0 0 0 0 0 return 0; } 2. 使用细节 memset函数设置内存时是一个字节一个字节进行设置的\n四. memcmp 内存比较函数 1. 基本介绍 1 int memcmp ( const void * ptr1, const void * ptr2, size_t num ); memcmp函数作用：用于比较两个内存块的大小 返回的值：在前 num 个字节中，若ptr1指向的内存大于num2指向的内存，则返回大于0的数字；若ptr2指向的内存小于num2指向的内存，则返回小于0的数字；若ptr2指向的内存等于num2指向的内存，则返回0 形参列表对应：内存块1，内存块2，要比较的字节个数 函数的使用\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;string.h\u0026gt; int main() { int arr1[] = { 1,2,3,4,5 }; int arr2[] = { 1,2,3 ,6,5}; int ret1 = memcmp(arr1, arr2, 12);//返回0 int ret2 = memcmp(arr1, arr2, 13);//返回小于0的数字 return 0; } arr1在内存中的存储对应 0x 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00\narr2在内存中的存储对应 0x 01 00 00 00 02 00 00 00 03 00 00 00 06 00 00 00 05 00 00 00\n2. 使用细节 函数的第三个参数表示：要比较的字节个数 注意超过一个字节的数据在内存中存储的顺序是怎样的 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n【C语言基础】动态内存管理# 1、为什么要有动态内存管理 向内存申请一块空间存放数据的方法\n1）创建一个变量\n2）创建一个数组，数组编译时开辟空间\n**缺陷：**1.空间开辟的大小是固定的\n​ 2.数组在声明的时候，必须指定数组的长度，数组空间一旦确定了大小不能调整\n但对于空间的需求，有时候我们需要的空间大小在==程序运行==的时候才能知道\n所以我们引入动态内存开辟，让程序员自己可以申请和释放空间\n动态内存管理的头文件stdlib.h\n2、malloc和free 2.1 基本介绍 memory:内存\nalloc:空间开辟\n向内存申请一块连续可用的空间（大小是字节），并返回指向这块空间的指针\n返回值void*：将这块空间起始地址返回，malloc函数并不知道开辟空间的类型\n​ 具体使用的时候，应该将其强转为我们期望的类型的指针\n注意：\n1、参数的单位是字节\n2、对malloc返回的指针做判断\n​ 申请空间成功的话，返回起始地址；申请失败，返回NULL\n3、如果参数size为0，malloc的行为是标准是未定义的，取决于编译器\n2.3 malloc申请空间和数组的空间有什么区别呢？ 1、动态内存的大小是可以调整的\n2、开辟空间的位置不一样\n2.4 内存中数据的存储划分 1）栈区：局部变量，局部的数组，函数的形式参数\n2）堆区：动态内存malloc，free，calloc，realloc\n3）静态区：全局变量，static修饰的静态变量\n2.5 free malloc申请的这块空间，使用完后，不想要了，需要释放\nfree是将申请的那块空间的使用权限还给操作系统了\n是通过代码的方式释放内存，如果不释放，程序结束的时候也会被操作系统自动回收\n但是指向这块空间的指针p，指向的空间不属于当前程序，但还是找得到\n这块空间（p是野指针，所以要将p置为空）\n注意\n1、如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的\n2、如果参数ptr是NULL指针，则函数什么事都不做\n3、free释放的空间一定是动态申请的\nmalloc和free最好成对使用\n3、calloc和realloc 3.1calloc 开辟num个大小为size的空间，并用0初始化数组，返回地址\nmalloc不会把申请的空间初始化，calloc会初始化，因此calloc函数效率要低一些\n3.2 realloc ==realloc 不仅能调整空间，还可以申请空间==\n把已经通过malloc或realloc开辟的空间进行调整，\nptr：要调整的内存空间的起始地址\nsize：需要调整多大的空间\n返回值为调整后内存的起始地址\n3.3 realloc是如何扩容空间的 realloc函数在调整空间时，有两种情况\n可以扩容的情况\n情况1：原有空间后，尚未分配的空间足够\n情况2：原有空间后，尚未分配的空间不够\n1）realloc直接在内存的堆区找到一块新的满足大小的空间\n2）将旧的数据，拷贝到新的空间\n3）释放旧空间\n4）返回新的地址\n所以realloc函数可能返回新的地址，也可能返回旧地址，还可能返回NULL指针\n因为可能开辟失败，为了避免返回NULL指针，使原有的数据也丢失，所以\n需要新创建一个指针变量接收，如果该指针变量不为NULL，再将它的值赋给原有的\n指针变量\n4、常见的动态内存的错误 对NULL指针的解引用操作 对动态申请的空间返回的的指针先要判断是否为NULL\n对动态开辟空间的越界访问\n对非动态开辟内存使用free释放\n使用free释放一块动态开辟内存的一部分\np[i] = i相当于 *（p+i），此时free(p)正确\n*p = i; p++; 此时free(p)会报错\n对同一块内存空间的多次释放 动态内存开辟忘记释放，可能导致内存泄漏的问题\n服务器的程序，7*24一直在运行\n内存管理是一把双刃剑\n1、提供灵活的内存管理方式\n2、带来风险\n5、经典笔试题分析 6、柔性数组 6.1 基本介绍 C99中，结构中最后一个元素允许是未知大小的数组，这就叫【柔性数组】成员\n1、结构体中\n2、最后一个成员\n3、未知大小的数组\n6.2 柔性数组的特点 1、结构中的柔性数组成员前面必须至少一个其它成员\n2、sizeof返回的这种结构大小不包括柔性数组的内容\n3、包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该\n​ 大于结构的大小，以适应柔性数组的预期大小\n​ 内存大小=结构大小+柔性数组大小\n因为n和arr都是malloc来的，所以后面可以通过realloc来调整这块空间\n一旦使用realloc来调整这块空间，那么后面的数组的空间大小就可以可大可小\n6.3与变长数组的区别 变长数组：指用整型变量或表达式声明或定义的数组\n数组的大小可以由变量来进行指定，并不是数组的大小可变\n变长数组大小一旦开辟好空间，就不能变\n6.4 使用柔性数组的优势 1）方便内存释放，一次free就搞定\n如果我们的代码是在一个给别人的函数中，你做了二次内存分配，并返回结构体的地址给\n用户。用户调用free可以释放结构体，但用户不知道这个结构体里的成员也需要free.\n所以，我们尽量把结构体的内存以及成员要的内存一次性分配好\n2）有利于访问速度（连续的内存有益于提高访问速度，也有益于减少内存碎片）\n注意最后要释放动态开辟的空间\n7、总结C/C++中程序内存区域划分 内核空间：用户代码不能读写\n栈（向下增长）：运行函数而分配的局部变量，函数的形式参数，返回数据，返回地址等\n内存映射段：文件映射、动态库、匿名映射\n堆（向上增长）：动态申请的内存，都在堆区\n静态区（数据段）：全局数据、静态数据\n代码段：可执行代码/只读常量，不能修改\nC/C++程序内存分配的几个区域：\n栈区，执行函数时，函数局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元\n自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限\n堆区一般由程序员分配释放，若程序员不释放，程序结束可能由OS（操作系统）回收\n分配方式类似于链表\n数据段（静态区）：(static)存放全局变量、静态数据。程序结束后由系统释放\n代码段：存放函数体（类成员函数和全局函数）的二进制代码\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n前言 C语言中字符函数和字符串函数是非常重要的，可以方便我们对字符和字符串进行处理。本文中主要介绍几种常见的字符函数和字符串函数。\n一.strlen求字符串长度 1. strlen函数 strlen函数的介绍\n1 size_t strlen ( const char * str ); 字符串的结束标志是 \\0 strlen 函数是用来求字符串的长度的，是从字符串的第一个字符开始往后统计字符个数， 遇到 \\0 就停止统计，如果没有遇到 \\0 ,就会一直往后统计，直到遇到 \\0 才会停止统计 所以strlen是用来统计字符串 \\0 之前的字符个数的函数 需要注意的是strlen函数返回的是无符号整型 strlen函数返回的无符号整型的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { if (strlen(\u0026#34;abc\u0026#34;) - strlen(\u0026#34;abcdef\u0026#34;) \u0026gt; 0) { printf(\u0026#34;hehe\\0\u0026#34;);//输出结果为hehe } else { printf(\u0026#34;haha\\n\u0026#34;); } return 0; } 分析：\nstrlen返回的是无符号整型，两个无符号整型相减的结果也应为无符号整型 所以应该将strlen(\u0026ldquo;abc\u0026rdquo;) - strlen(\u0026ldquo;abcdef\u0026rdquo;)的到的结果 -3 转为无符号整型，\n由于整型在内存中是以补码方式进行存储的，所以要先得到-3的补码，\n然后再将补码的符号位改为0。\n-3的原码为 10000000 00000000 00000000 00000011\n-3的反码为 11111111 11111111 11111111 11111100\n-3的补码为 11111111 11111111 11111111 11111101\n转成无符号数 01111111 11111111 11111111 11111101\n可以看出，-3转为无符号整型后的结果是一个非常大的数，\n因此，上面代码的输出结果为hehe\n实现strlen函数的三种方法\n方法一：计数器\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;assert.h\u0026gt; size_t my_strlen(const char* str) { int count = 0; assert(str != NULL); while (*str != \u0026#39;\\0\u0026#39;)//while(*str) { count++;//统计个数 str++; } return count; } 定义一个变量count来统计字符个数，如果该字符不是 \\0 ，则count++，最后返回count的值\n方法二：指针-指针\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;assert.h\u0026gt; size_t my_strlen(const char* str) { assert(str != NULL);//检测指针的有效性 char* start = str;//记录起始地址 while (*str != \u0026#39;\\0\u0026#39;) { str++; } return str - start; } 指针-指针的绝对值是指针和指针之间元素的个数\n要统计字符串中的字符个数，首先要得到该字符串的起始地址和结束地址（\\0前的地址），然后将两地址相减，得到的就是字符串之间的字符个数\n方法三：递归方式\n1 2 3 4 5 6 7 8 9 10 11 size_t my_strlen(const char* str) { if (*str != \u0026#39;\\0\u0026#39;) { return 1 + my_strlen(str + 1); } else { return 0; } } 因为统计字符串的长度是先从首字符开始的，所以如果首字符是 \\0 ,那么该字符串长度就为0，如果首字符不是 \\0 的，那么该字符串中至少有1个不为 \\0 的有效字符，字符串的长度就是1+后面字符的个数，依次类推\n假设求的是字符串 “abcd” 的长度，那么用递归求解的具体步骤如下：\n首字符是 a ，不是 \\0 ，字符串 “abcd\\0” 的长度为 1 + “bcd\\0”的长度 “bcd\\0”首字符是 b ,不是 \\0 ,字符串 \u0026ldquo;bcd\\0\u0026rdquo; 的长度为 1 + “cd\\0”的长度 “cd\\0”的首字符是 c ，不是 \\0 ，字符串“cd\\0”的长度为 1 + “d\\0”的长度 “d\\0”的首字符是 d ，不是 \\0 ，字符串“d\\0”的长度为 1 + “\\0” 的长度 “\\0”的首字符是 \\0 ，由于字符串统计的是\\0之前的字符个数，因此“\\0”长度为0 最后得出字符串“abcdef”的长度为0+1+1+1+1 = 4 二.长度不受限制的字符串函数 1. strcpy字符串拷贝函数 strcpy 函数的介绍\n1 char * strcpy ( char * destination, const char * source ); strcpy 是字符串拷贝函数\n有两个形参，第一个形参是目标字符串，第二个形参是源字符串，该函数是将源字符串里的内容拷贝到目标字符串，当拷贝完源字符串里的 \\0 后就停止拷贝，并返回目标空间的起始地址\n需要注意的是：\n目标字符串的空间一定要大于源字符串所占的空间大小 目标字符串必须可修改 要拷贝源字符串中的 \\0 模拟实现strcpy\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;assert.h\u0026gt; char* my_strcpy(char* dest, const char* src) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); //拷贝src中的字符串到dest指向的空间，包含\\0 while (*dest++ = *src++)//当\\0拷贝过去后，结果为假，停止循环 { ; } return ret;//返回目标空间的起始地址 } 思路如下：\n1.找到目标字符串的起始地址和源字符串的起始地址\n2.将目标字符串的起始地址存一份\n3.从源字符串起始字符开始，依次拷贝到目标字符串，当拷贝完源字符串中的\\0后就停止拷贝\n4.返回目标字符串的起始地址\n2. strcat字符串追加函数 strcat 函数的介绍\n1 char * strcat ( char * destination, const char * source ); strcat是字符串追加函数，作用是将源字符串拷贝到目标字符串的结束位置处，\n返回的是目标空间的起始地址。\n需要注意的是：\n源字符串的首字符要覆盖目标字符串的 \\0 要拷贝源字符串的\\0 目标字符串要保证可以被修改，并且空间能容纳追加后的字符串 不保障自己给自己追加（ \\0 被覆盖 ） 模拟实现strcat\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;assert.h\u0026gt; char* my_strcat(char* dest, const char* src) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); while (*dest != \u0026#39;\\0\u0026#39;)//找\\0 { dest++; } while (*dest++ = *src++) { ; } return ret; } 1.找到目标字符串中 \\0 的地址并存一份\n2.找到源字符串的起始地址和结束地址（包含\\0）\n3.源字符串的起始字符拷贝时，要覆盖目标字符串中的\\0\n源字符串起始字符之后的字符依次拷贝到目标字符串的结尾处\n当拷贝完\\0后就停止拷贝\n4.返回目标空间的起始地址\n3. strcmp字符串比较函数 strcmp函数的介绍\n1 int strcmp ( const char * str1, const char * str2 ); strcmp是字符串比较函数，用来比较两字符串对应位置上字符的大小\n如果第一个字符串对应位置上的字符大于第二个字符串对应位置上的字符，那么返回的是大于0的数字 如果第一个字符串对应位置上的字符大于第二个字符串对应位置上的字符，那么返回的是小于0的数字 如果第一个字符串对应位置上的字符大于第二个字符串对应位置上的字符，那么返回0 注意：两字符串不能被修改\n模拟实现strcmp，更符合VS的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;assert.h\u0026gt; int my_strcmp(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2); while (*str1 == *str2)//对应字符相等的情况 { if (*str1 == \u0026#39;\\0\u0026#39;)//两字符串相等 { return 0; } str1++; str2++; } //对应字符不相等的情况 if (*str1 \u0026gt; *str2)//大于 { return 1; } else//小于 { return -1; } } 模拟实现strcmp，更符合C语言标准的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;assert.h\u0026gt; int my_strcmp(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2); while (*str1 == *str2)//对应字符相等的情况 { if (*str1 == \u0026#39;\\0\u0026#39;)//两字符串相等 { return 0; } str1++; str2++; } //对应字符不相等的情况 return (*str1 - *str2); } 思路如下：\n1.找到两个字符串的起始地址\n2.从两字符串的起始字符开始比较，比较的结果有三种情况：相等，大于和小于\n（1）如果对应字符相等，那么就继续看这两个字符是否为\\0，如果是，那么两字符串相等，\n​ 如果不是，那么就继续往后比较\n（2）如果对应字符不相等，那么就看两字符相减的结果是否大于0，\n​ 如果结果大于0，那么就说明第一个字符串大于第二个字符串，\n​ 如果结果小于0，那么就说明第一个字符串小于第二个字符串\n三.长度受限制的字符串函数 长度受限制的字符串函数可以指定要操作的字符个数，比如strncpy函数可以指定拷贝源字符串中多少个字符到目标字符串中，而不是一定要找到 \\0 才停止拷贝\n1. strncpy strncpy函数的介绍\n1 char * strncpy ( char * destination, const char * source, size_t num ); strncpy函数可以指定拷贝源字符串中多少个字符到目标字符串中\n不追加 \\0 但是如果指定拷贝源字符串的字符个数如果大于源字符串的长度，那么超出的部分就在目标字符串后面补 \\0 使用该函数要保证目标空间能容纳拷贝后的字符串和目标字符串可修改 strncpy的使用\n1 2 3 4 char arr1[10] = \u0026#34;abcdefgh\u0026#34;; char arr2[] = \u0026#34;hello\u0026#34;; strncpy(arr1, arr2, 5); printf(\u0026#34;%s\\n\u0026#34;, arr1);//输出hellofgh 模拟实现strncpy\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;assert.h\u0026gt; char* my_strncpy(char* dest, const char* src, size_t num) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); //拷贝src中的字符串到dest指向的空间 while (num \u0026amp;\u0026amp; (*dest++ = *src++)) { num--; } //提前遇到源字符串中的\\0 if (num) { while (--num) { *dest++ = \u0026#39;\\0\u0026#39;;//超出的长度用\\0来补 } } return ret;//返回目标空间的起始地址 } 2. strncat strncat函数的介绍\n1 char * strncat ( char * destination, const char * source, size_t num ); strncat函数可以指定追加源字符串的多少个字符到目标字符串的结束位置\n追加完指定个数的字符后，会自动在目标字符串后面再追加一个\\0 可以实现自己给自己追加 使用该函数要保证目标空间能容纳拷贝后的字符串和目标字符串可修改 strncat的使用\n1 2 3 4 char arr1[20] = \u0026#34;hello \u0026#34;; char arr2[] = \u0026#34;world\u0026#34;; strncat(arr1, arr2, 3); printf(\u0026#34;%s\\n\u0026#34;, arr1);//输出hello wor 模拟实现strncat\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;assert.h\u0026gt; char* my_strncat(char* dest, const char* src, size_t num) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); while (*dest != \u0026#39;\\0\u0026#39;)//找目标字符串的\\0 { dest++; } while (num --) { if ((*dest++ = *src++) == 0) { return ret; } } *dest = \u0026#39;\\0\u0026#39;; return ret; } 3. strncmp strncmp函数的介绍\n1 int strncmp ( const char * str1, const char * str2, size_t num ); strncmp函数，可以指定要比较的字符个数\n如果指定的字符个数大于源字符串的长度，那么就用 \\0 和目标字符串的对应字符相比较\n如果两字符都比较完了，但还没到指定的比较次数\nstrncmp的使用\n1 2 3 4 const char* p1 = \u0026#34;abcdef\u0026#34;; char* p2 = \u0026#34;abckjy\u0026#34;; int ret = strncmp(p1, p2, 4);//比较前4个字符 printf(\u0026#34;%d\\n\u0026#34;, ret);//输出小于0的数 模拟实现strncmp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;assert.h\u0026gt; int my_strncmp(const char* str1, const char* str2, size_t num) { assert(str1 \u0026amp;\u0026amp; str2); while (num--) { if (*str1++ != *str2++) { return (*str1 - *str2);//两字符串字符不相等 } //比较的字符个数大于两字符串的长度 else if (*(str1 - 1) == \u0026#39;\\0\u0026#39;) { return 0;//两字符串相等 } } return 0;//两字符串相等 } 四.字符串查找 1.strstr strstr的介绍\n1 const char * strstr ( const char * str1, const char * str2 ); strstr是用来查找目标字符串中是否存在子串的函数，\n若查找到，则返回目标字符串中第一次出现子串的起始地址，若未查找到，则返回空指针\nstrstr函数的使用\n1 2 3 4 5 6 7 8 9 10 11 char* p1 = \u0026#34;hello world hello world\u0026#34;; char* p2 = \u0026#34;world\u0026#34;; char* ret = strstr(p1, p2); if (ret == NULL) { printf(\u0026#34;子串不存在\\n\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, ret);//输出world hello world } 模拟实现strstr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;assert.h\u0026gt; char* my_strstr(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2);//保证不为野指针 if (*str2 == NULL)//要查找的为空字符串 { return str1;//规定返回str1 } //查找的逻辑 char* s1 = str1; char* s2 = str2; char* cur = str1;//记录有可能匹配成功的地址 while (*cur) { s1 = cur; s2 = str2; while ((*s1 == *s2) \u0026amp;\u0026amp; (*s1 != \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (*s2 != \u0026#39;\\0\u0026#39;)) { s1++; s2++; } if (*s2 == \u0026#39;\\0\u0026#39;) { return cur;//找到子串 } cur++;//未匹配成功，尝试从下一个位置匹配 } return NULL;//找不到子串 } str函数查找部分的思路\n(str1 指向目标字符串的起始地址，str2指向子字符串的起始地址)\n\\1. 创建两个新的字符指针s1和s2分别存放str1 和str2\n\\2. 再创建一个字符指针cur，用于记录有可能匹配成功的地址\n\\3. 将cur 赋给s1，让s1向后查找，看当两字符串的对应字符是否相等\n如果相等，就让两字符串依次向后比较字符（str1++，str2++） 如果在比较的过程中发现两字符串有一个字符不相等那么退出本次查找，下一次则从记录位置的下一个位置开始查找（cur++）\n如果比较过程中发现 *s2 等于 \\0（找到子串），或 *s1 等于\\0（没找到 / 找到），则停止查找，再判断 *s2 是否等于 \\0，如果是 ，则返回 cur 存的第一次出现子串的起始地址\n如果不相等，那么说明本次未匹配成功，需要尝试从下一个位置匹配（cur++） \\4. 当发现 *cur 等于 \\0 时，说明未查找到子串，就停止查找，并返回NULL\n五.错误信息报告 1. strerror strerror 函数的介绍\n1 char * strerror ( int errnum ); 当我们在使用C语言标准库中的函数的时候，如果这些函数出错了，那么就会返回错误码，strerror函数可以将错误码对应的错误信息（字符串）的起始地址返回\nerrno 是记录当前错误码的全局变量 这些错误码一般是放在errno.h这个头文件中说明的 只适用于库函数出错时 编辑\nstrerror函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;errno.h\u0026gt; int main() { //fopen 打开文件 FILE* pf = fopen(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;);//\u0026#34;r\u0026#34;-以读文件形式，打开文件 if (pf == NULL)//如果这个文件不存在，就打开失败，返回空指针 { //只适用于库函数 printf(\u0026#34;打开文件失败，原因是：%s\u0026#34;, strerror(errno)); return 1; } else { printf(\u0026#34;打开文件成功\u0026#34;); //... fclose(pf);//关闭文件 pf = NULL; } return 0; } 2.perror 1 void perror ( const char * str ); perror函数是将 errno 中错误码对应的错误信息打印\n先打印str指向的字符串，打印冒号，再打印一个空格，再打印错误码对应的错误信息\n例如：\n编辑\nstrerror 和perror 的区别： strerror 只是拿到错误码对应错误信息的字符串的地址，而perror是直接将错误码对应的错误信息打印\n六.字符函数 1.字符分类函数 字符分类函数是C标准库中的一组函数，用于对字符进行分类和判断。这些函数返回值为真或假，通常以整数0或 非0表示。\n编辑\n空白字符： 空格\u0026rsquo; \u0026lsquo;，换页 \u0026lsquo;\\f\u0026rsquo; , 换行 \u0026lsquo;\\n\u0026rsquo; , 回车 \u0026lsquo;\\r\u0026rsquo; , 垂直制表符 \u0026lsquo;\\v\u0026rsquo; 等\n数字字符：\u0026lsquo;0\u0026rsquo; ~ \u0026lsquo;9\u0026rsquo; 的字符\n控制字符：控制文本显示或者通信流程的特殊字符，比如：回车 \u0026lsquo;\\r\u0026rsquo;, 制表符\u0026rsquo;\\t\u0026rsquo; , 换页 \u0026lsquo;\\f\u0026rsquo; 等\n十六进制的字符：包括所有十进制的数字字符，字母 af , AF\n1.1 islower函数 ：判断是否为小写字母\n1 int islower ( int c ); 函数的使用\n1 2 3 4 5 int ret = islower(\u0026#39;A\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, ret);//0 int retu = islower(\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, retu);//非0 函数的应用：写一个代码，将一个字符串中的小写字母转大写，其它字符不变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;ctype.h\u0026gt; int main() { char arr[] = \u0026#34;I am a Student.\u0026#34;; int i = 0; while (arr[i] != \u0026#39;\\0\u0026#39;) { if (islower(arr[i])) { arr[i] -= 32; } i++; } printf(\u0026#34;%s\\n\u0026#34;, arr);//输出 I AM A STUDENT. return 0; } **1.2 isdigit函数：**判断是否为数字字符\n1 int isdigit ( int c ); 函数的使用\n1 2 int ret = isdigit(\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, ret);//0 2.字符转换函数 2.1 toupper 小写转大写函数 1 int toupper ( int c ); 函数的使用\n1 2 char ch = toupper(\u0026#39;a\u0026#39;); printf(\u0026#34;%c\\n\u0026#34;, ch);//A 2.2tolower 大写转小写函数 1 int tolower ( int c ); 函数的使用\n1 2 char ch = tolower(\u0026#39;A\u0026#39;); printf(\u0026#34;%c\\n\u0026#34;, ch);//a ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n一、指针入门 1.基本概念 1.1 指针 指针就是地址\n在内存里只要分配了数据空间就对应一个地址\n变量在创建的时候，会向内存中申请一块空间，这块空间在创建的同时会被分配一个地址\n可以把计算机中的内存看成宿舍楼，楼里的每个宿舍都有自己的门牌号，而这个门牌号也就是地址/指针，我们根据门牌号就可以找到对应的宿舍\n也就是 指针 = 地址 = 门牌号\n代码示例：\n1 2 short age = 20;//向内存申请2个字节的空间来存放20 float weight = 95.5F;//向内存申请4个字节的空间来存放95.5 示意图如下：\n另外，内存划分为多个内存单元，每个内存单元大小为1个字节（也就是8比特位，可以看成每个宿舍可以住8个人）， 每个内存单元都有自己的地址\n编译器是通过地址找到对应的内存单元\n示意图如下：\n1.2 指针变量 指针变量是用来存放地址的变量\n1.3取地址操作符 \u0026amp; 是取地址操作符，用于拿到地址。拿到的是第一个字节的地址（可以推出剩下的地址**）**\n%p 是用于打印地址的占位符\n看一段代码：\n1 2 int a = 20; int* pa = \u0026amp;a; 解读：\n\u0026amp;a ： 拿到变量a的地址\npa ：pa是一个用来存放a的地址的变量，叫指针变量\nint* 指针类型的理解\n（1）*表示pa是指针变量，int表示pa指向的对象a的类型是int类型的\n（2）int*是pa的类型，即整型指针类型\n整体代码解读：pa是一个整型指针类型的变量，里面存放的是a的第一个字节的地址(指针)\n示意图如下：\n1.4 解引用操作符 是解引用操作符 (间接访问操作符)，用于对指针变量所指向的对象进行操作 当我们拿到地址后，就可以通过地址找到对应的内存空间，\n但如果我们要访问或修改该内存空间里的值，就要通过使用解引用操作符 * 来完成\n例如：\n1 2 3 4 5 int a = 20; int* pa = \u0026amp;a; *pa = 200;//通过pa里面存放的a的地址，找到a对应的内存空间，将里面的值改为200 //等价于 a = 200 printf(\u0026#34;%d\\n\u0026#34;, a);//200 关于指针pa：\n\\1. pa ，里面存放着一个地址\n\\2. *pa ，pa指向的那个对象\n3.\u0026amp;pa，表示pa变量的地址\n2.指针变量的大小 指针变量是用来存放地址的变量\n一个地址的存放需要多大空间，指针变量的大小就是多大\n指针变量的大小只与环境有关**，在相同环境下指针变量的大小相同**\n32位环境下，地址的大小为32个比特位，指针变量大小为4****个字节\n64****位环境下，地址的大小为64个比特位，指针变量大小为8****个字节\n指针变量的大小与类型无关，取地址取的是第一个字节的地址，类型该占几个字节就占几个字节\n示例：\n1 2 3 4 char ch = \u0026#39;w\u0026#39;; char* pc = \u0026amp;ch; //sizeof：计算使⽤类型创建的变量所占内存空间的⼤⼩,单位是字节 printf(\u0026#34;%zd\\n\u0026#34;, sizeof(pc)); 上面代码输出的结果与环境有关，在x64环境下，结果为8 ；在 x86环境下，结果为4\n3.指针类型的意义 (1)指针类型决定了解引用时，一次能向后操作几个字节\n(2)指针类型决定了指针+-整数时，向前或向后走了多大的距离\n3.1指针类型决定了解引用时能向后操作几个字节 先看一段代码：\n1 2 3 int a = 0x11223344; int* pa = \u0026amp;a;//将拿到的a的地址存到整型指针类型的变量pa中 *pa = 0;//修改pa指向的变量a 的值 在上面这段代码中，当执行到 int a = 0x11223344; 这段代码时\n变量a在内存中4个字节的数据是这样的：\n编辑\n当执行到 *pa = 0; 这段代码时\n变量a在内存中4个字节的数据是这样的：\n编辑\n可以看出，当pa的类型是int*时，对pa进行解引用操作，一次能向后修改4个字节的值\n如果将pa的类型改为char*\n1 2 3 int a = 0x11223344; char* pa = \u0026amp;a;//将拿到的a的地址存到字符指针类型的变量pa中 *pa = 0;//修改pa指向的变量a 的值 当执行到*pa = 0时\n变量a在内存中4个字节的数据是这样的：\n编辑\n也就是当pa的类型是 char* 时，对pa进行解引用操作，一次能向后修改1个字节的值\n结论：\nchar*指针类型在解引用操作时只能向后访问1个字节\nint*指针类型在解引用操作时只能向后访问4个字节\n也就是：\nint* p; p能**操作4*个字节**\nchar* p; *p能操作1个字节\ndouble* p; *p能操作8个字节\nshort* p; *p能操作2个字节\n……\n3.2 指针变量 +- 整数 指针类型决定了指针向前或向后走了多大的距离\n（不改变或不操作 数值）\nint*指针类型+1，向后走了4个字节\nint* pa：pa+1 \u0026lt;==\u0026gt; +1*(sizeof(int))\nchar*指针类型+1，只向后跳=走了1个字节\nchar* pa： pa+1 \u0026lt;==\u0026gt; +1*(sizeof(char))\n示例：\n1 2 3 4 5 6 7 8 int a = 0x11223344; int* pa = \u0026amp;a; char* pc = \u0026amp;a; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a); printf(\u0026#34;%p\\n\u0026#34;, pa); printf(\u0026#34;%p\\n\u0026#34;, pc); //上面三个打印出的结果相同 输出结果如下：\n也就是 \u0026amp;a，pa，pc 拿到的起始地址的值相同\n如果分别对它们 +1 ，代码如下：\n1 2 3 4 5 6 7 int a = 0x11223344; int* pa = \u0026amp;a; char* pc = \u0026amp;a; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a + 1);//向后跳过4个字节 printf(\u0026#34;%p\\n\u0026#34;, pa + 1);//向后跳过4个字节 printf(\u0026#34;%p\\n\u0026#34;, pc + 1);//向后跳过1个字节 输出结果为：\n由于在十六进制中 C 表示12,所以从 DC 到 E0 是跳过了4个字节\n示意图如下：\nint* pa：\npa+n 本质上为向后跳过 n*(sizeof(int))个字节\nchar* pa：\npa+n 本质上为 向后跳过 n*(sizeof(char))个字节\n减法同理，只是是向前偏移\n4.指针运算 可以把指针类比成日期，整数类比成天数\n1.指针+-整数 日期+-天数 = 日期\n2.指针-指针 日期-日期 = 天数\n3.指针+指针 日期+日期 没意义\n4.指针的关系运算 指针大小的比较\n4.1指针 +- 整数 指针类型决定了指针 +- 整数时的步长，还决定了指针解引用时一次能访问几个字节\n应用场景：如 打印数组里的每一个元素\n由于数组在内存中连续存放，所以只要拿到第一个元素的地址，就可以通过解引用访问一个元素，+1跳过一个元素，来完成数组中每一个元素的打印\n代码如下：\n1 2 3 4 5 6 7 8 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };//int类型的数组，里面每个元素都是int类型 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组有几个元素 int* p = \u0026amp;arr[0];//取出数组首元素的地址存到 p 里面 for (int i = 0; i \u0026lt; sz; i++) { printf(\u0026#34;%d \u0026#34;, *p);//解引用向后访问4个字节，也就是访问了数组里的一个元素 p++;//p+1--向后跳过4个字节，即跳过数组里的一个元素 } 示意图如下：\n编辑\n4.2指针-指针 前提：两个指针指向的是同一块空间\n指针 - 指针的绝对值是指针和指针之间元素的个数\n示例：\n1 2 3 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; printf(\u0026#34;%d\\n\u0026#34;, \u0026amp;arr[9] - \u0026amp;arr[0]);//9 printf(\u0026#34;%d\\n\u0026#34;, \u0026amp;arr[9] - \u0026amp;arr[0]);//-9 示意图如下：\n编辑\n4.3指针的关系运算 指针的关系运算就是让指针进行大小的比较\n每一个字节都有自己的地址，地址就有大和小之分\n应用场景：如打印数组里的每一个元素\n原因：在内存中，数组的地址是由低到高变化的\n示例：\n1 2 3 4 5 6 7 8 9 10 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int sz = sizeof(arr) / sizeof(arr[0]);//计算数组有几个元素 int* p = \u0026amp;arr[0];//取出数组首元素的地址存到 p 里面 //打印数组里的每个元素 while (p \u0026lt; \u0026amp;arr[sz])//两个地址相比较 { printf(\u0026#34;%d \u0026#34;, *p); p++; } 上面代码中，当p里面存放的地址小于下标为10的元素的地址时，就找到p所指向的内容并打印\n示意图如下：\n5.二级指针 ==二级指针：用来存放一级指针变量的地址==\n代码示例：\n1 2 3 int a = 10; int* pa = \u0026amp;a;//pa是一级指针变量 int** ppa = \u0026amp;pa;//ppa是二级指针变量，存放是pa的地址 int 的含义：*\n（1）* 说明是指针变量\n（2）int 表示指针指向的对象是 int 整型的\nint** 的含义：\n（1）* 说明是指针变量\n（2）int* 表示指针指向的对象是 int* 整型指针类型的\n示意图：\n**ppa = *pa = a\n二、指针基础 1.基本类型指针 1.1指针与字符 字符指针\n1.字符指针变量 存放的是字符串中首字符的地址\n1 2 3 char* p = \u0026#34;abcdef\u0026#34;;//a b c d e f \\0 //把字符串首字符的地址赋给p printf(\u0026#34;%c\\n\u0026#34;, *p);//a 2.字符指针变量 存放的是==常量字符串==,**不能被修改，**使用const修饰\n1 const char* p = \u0026#34;abcdef\u0026#34;;//const放在 * 的左边，限制的是*p 3.使用%s打印字符串的时候，只需提供首字符的地址\n1 2 3 char* p = \u0026#34;abcdef\u0026#34;;//把字符串首字符的地址赋给p //%s打印字符串时，只需要提供首字符的地址 printf(\u0026#34;%s\\n\u0026#34;, p);//abcdef 4.内容相同的常量字符串只用存一份（只读数据区，可以用，但不能改）\n1 2 3 4 const char* str1 = \u0026#34;haha\u0026#34;; const char* str2 = \u0026#34;haha\u0026#34;; //str1 与 str2 存放的地址相同 //内容相同的常量字符串，只用存一份 对比字符数组存放数据：\n1 2 3 4 char str3[] = \u0026#34;hehe\u0026#34;; char str4[] = \u0026#34;hehe\u0026#34;; //\u0026amp;str3[0] 与 \u0026amp;str4[0]不相同 //数组str3与数组str4虽然存放的内容相同，但是二者是两块不同的空间 1.2 指针与数组 \\1. 数组指针 本质上是指针；指针数组 本质上是数组\n\\2. [ ] 的优先级高于 *\n例如：int* arr[6] 是指针数组 ，int(*) arr[6] 是数组指针， （）提高优先级\n数组指针\n1. 数组名的理解\n（1）数组名是数组首元素的地址\n​ 例如：arr ， \u0026amp; arr[0] 都表示==数组首元素的地址==，==类型 int*==，指针类型\n（2）\u0026amp;数组名：其中数组名表示==整个数组==；数组的地址与数组首元素的地址值相同\n1 2 3 4 5 int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0]);//数组首元素的地址 printf(\u0026#34;%p\\n\u0026#34;, arr);//数组首元素的地址 printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr);//数组的地址 //打印结果相同 （3）数组名+1，跳过数组里的一个元素 ； \u0026amp;数组名+1，跳过的是整个数组\n​ ==指针类型决定了指针+-整数跳过几个字节==\narr \u0026mdash; int* \u0026amp;arr[0] \u0026mdash; int* \u0026amp;arr \u0026mdash; int ( * )[ ] 数组指针类型\n（4）arr[ i ] 等价于 *(arr + i) arr[ i ] 等价于 i[ arr ]，[ ] 只是操作符\n（5）sizeof (数组名) ：计算整个数组的大小（字节）\n1 2 int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; printf(\u0026#34;%zd\\n\u0026#34;, sizeof(arr));//40 计算的是整个数组的大小 2. 数组指针变量\n数组指针变量：用于存放 数组的地址\n示例：\n1 2 3 int arr[10] = { 1,2,3,4,5 }; int(*p)[10] = \u0026amp;arr;//p是数组指针，p里面存放的是数组的地址 //p的类型是 int(*)[] int(*p)[10] 的含义：\n（1）( *p )：p先与 * 结合，说明 p是指针变量\n（2） [10]：p指向的数组的元素是10\n（3）int：p指向的数组的元素类型是整型的\n*p等价于arr\n3. 数组传参\n数组传参的本质上传递的是数组首元素的地址\n数组传参，形参可以写成指针，也可以写成数组，但本质上还是指针\n一维数组传参\n示例，使用指针计算数组里有多少个元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void test(int* arr)//形参还可以写成 int arr[] { int sz2 = sizeof(arr) / sizeof(arr[0]);//指针变量的大小只与环境有关 //32环境下：4 / 4 64位环境下：8 / 4 printf(\u0026#34;%d\\n\u0026#34;, sz2);//输出 1 或 2 } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int sz1 = sizeof(arr) / sizeof(arr[0]);//40 / 10 printf(\u0026#34;%d\\n\u0026#34;, sz1);//输出 10 test(arr);//传的是数组首元素的地址 return 0; } 二维数组传参\n因为数组名是数组首元素的地址，而二维数组的每个元素是一个一维数组\n所以 二维数组的数组名表示的是二维数组里的第一个一维数组的地址\n示例，使用指针打印二维数组：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void print(int(*arr)[5], int row, int col)//用数组指针接收一维数组的地址 { for (int i = 0; i \u0026lt; row; i++)//拿到每个一维数组 { for (int j = 0; j \u0026lt; col; j++)//拿到一维数组里的每一个元素 { printf(\u0026#34;%d \u0026#34;,*( *(arr + i) + j));//等价于arr[i][j] } printf(\u0026#34;\\n\u0026#34;); } } int main() { int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} }; print(arr, 3, 5);//将arr数组的内容打印 return 0; } *(arr +i) ：拿到每个一维数组，等价于 arr[ i ] == \u0026amp;arr[ i ][ 0 ]\n*( (*arr+i) + j) ：拿到一维数组里的每一个元素，等价于arr[ i ][ j ]\n示意图：\n指针数组\n指针数组：用来存放指针 的数组，数组的每个元素是指针类型\n例如：\n1 2 3 4 5 int a = 10; int b = 20; int c = 30; //[ ]的优先级高于* int* arr[3] = { \u0026amp;a, \u0026amp;b, \u0026amp;c };//整型指针数组 注意：指针数组要指定数组的大小\n1.3指针与函数 函数的传参机制 函数定义里的参数是形参，函数调用里传的参数是实参\n形参是实参的一份拷贝，对形参的修改不会影响到实参\n形参和实参是两块独立的空间\n（1）传值调用（把变量本身传过去）：\n把实参拷贝给形参，形成两块独立的空间（例如求两个数的和）\n（2）传址调用（把变量的地址传过去）：\n传实参的地址给形参，形参操作的内存空间是实参的内存空间，\n在函数内部可以修改主调函数 （例如通过函数将两个数的值交换）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void swap(int* pa, int* pb)//通过pa能找到a { //解引用pa得到a,解引用pb得到b int z =*pa; *pa = *pb;//a = b *pb = z;//b = z //pa是地址，*pa是pa地址指向的内容 } int main8() { int a = 0; int b = 0; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); swap(\u0026amp;a, \u0026amp;b);//交换a,b的值 return 0; } 函数指针 数组指针，是指向数组的指针\n函数指针，是指向函数的指针，存放函数地址的指针\n\u0026amp;函数名和函数名 都能拿到函数的地址\n1 2 3 4 5 6 7 8 9 10 11 12 int Add(int x, int y){ return x + y; } int main() { //\u0026amp;数组名和数组名都表示函数的地址 int (*pf)(int, int) = Add;//pf是函数指针变量 //int(*)(int, int) 函数指针类型 return 0; } int (*pf) (int, int) 的含义：\n（1）( *pf ) ： pf是变量名 ，* 说明 pf 是指针变量\n（2）(int, int)：pf 指向的是函数，该函数有两个int类型的参数，\n​ 只需要交代函数参数的个数和类型，参数名可以不写\n（3）int：说明该函数的返回类型是 int 类型\n通过函数指针调用函数\n对于函数指针，调用的时候可以先解引用一下再调用，也可以不解引用直接调用\n1 2 3 4 5 int (*pf)(int, int) = \u0026amp;Add;//pf是函数指针变量 //通过函数指针调用函数 (*pf)(4, 5);//写法1 pf(4, 5);//写法2 两段有趣的代码\n1 2 //代码1 (*(void(*)())0)(); void(*)()是一个函数指针类型\n( 函数指针类型 )0 是强制类型转换，也就是==把0强制类型转换成函数指针类型==，0就是一个函数地址\n(*(函数指针类型)0)( ) 表示将0强转后再==解引用==找到这个函数，再==调用这个函数==\n注意：（类型）是强制类型转换\n1 2 //代码2 void (*signal(int, void(*)(int)))(int); signal是一个函数声明\nsignal函数有两个参数，分别是整型的和函数指针类型的，该函数指针指向的函数参数是int，返回类型是void\nsignal函数的返回类型是void(*)(int)，也就是函数指针类型：该函数指针指向的函数参数是int，返回类型是void\n==函数声明是告诉我们函数名，函数参数，函数返回类型==，所以这是一个函数声明\ntypedef给类型重命名 我们发现上面的代码中，函数的返回类型是函数指针类型，这样不仅繁琐，而且可读性差\n所以我们可以使用typedef来给该类型重命名\n1 typedef void(*pfunc_t)(int); 上面这段代码意思为将类型 void(*)(int) 重命名为 pfunc_t\n这时，代码2就可以简化成下面这种写法了\n1 pfunc_t signal(int, void(*)(int)); **注意：**重命名的类型要放在*后面，这和我们重命名其它类型有所不同\n对于其它类型，我们是直接将重命名的类型放在原类型的后面\n1 typedef unsigned int uint; 意思为给unsigned int这个类型重命名为uint\n函数指针数组 指针数组，是一个数组，里面存放的是相同类型的指针\n函数指针数组，是一个数组，可以用来存放多个同类型的函数指针\n例如：\n1 2 3 4 5 6 int (*pf1)(int, int) = Add;//Add加法函数 int (*pf2)(int, int) = Sub;//Sub减法函数 int (*pf3)(int, int) = Mul;//Mul减法函数 //函数指针数组 int(* pf[3])(int, int) = {pf1, pf2, pf3}; int(* pf[3])(int, int) = {Add, Sub, Mul};//也可以这样写 pf 先与[ 3 ] 结合：表示pf是数组\nint (*) (int, int) ：表示pf这个数组里的每个元素的类型是函数指针类型\n通过函数指针数组来调用函数：\n1 2 3 pf[0](6, 4);//调用加法函数 pf[1](6, 4);//调用加法函数 pf[2](6, 4);//调用加法函数 函数指针数组的用途-转移表 例子（计算器）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 void menu() { printf(\u0026#34;*************************************\\n\u0026#34;); printf(\u0026#34;********** 1. add 2. sub ********\\n\u0026#34;); printf(\u0026#34;********** 3. mul 4. div ********\\n\u0026#34;); printf(\u0026#34;********** 0.exit ********\\n\u0026#34;); printf(\u0026#34;*************************************\\n\u0026#34;); } int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } int main() { int input = 0; int x = 0, y = 0; //pfArr是一个函数指针数组 int (*pfArr[])(int, int) = {0, Add, Sub, Mul, Div}; do { menu(); printf(\u0026#34;请选择:\u0026gt;\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if (input \u0026gt;= 1 \u0026amp;\u0026amp; input \u0026lt;= 4) { printf(\u0026#34;请输入操作数:\u0026gt;\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); int ret = pfArr[input](x, y); printf(\u0026#34;ret=%d\\n\u0026#34;, ret); } else if (input == 0) { printf(\u0026#34;退出\\n\u0026#34;); } else { printf(\u0026#34;选择错误，请重新选择\u0026#34;); } } while (input); return 0; } 指向函数指针数组的指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { //函数指针 int (*pf)(int, int); //函数指针数组 int (*pfArr[4])(int, int);//pfArr是一个数组，每个元素是函数指针 //指向函数指针数组的指针 int (*(*ppfArr)[4])(int, int) = \u0026amp; pfArr; //ppfArr是一个数组指针，指针指向的数组有4个元素， //每个元素的类型是函数指针 int(*)(int, int) return 0; } 回调函数 回调函数就是通过函数指针调用函数。\n把函数指针(地址)作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，\n我们就说这是回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 void menu() { printf(\u0026#34;*************************************\\n\u0026#34;); printf(\u0026#34;********** 1. add 2. sub ********\\n\u0026#34;); printf(\u0026#34;********** 3. mul 4. div ********\\n\u0026#34;); printf(\u0026#34;********** 0.exit ********\\n\u0026#34;); printf(\u0026#34;*************************************\\n\u0026#34;); } int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } void Calc(int (*pf)(int, int)) { int x = 0, y = 0; printf(\u0026#34;请输入两个操作数:\u0026gt;\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); printf(\u0026#34;%d\\n\u0026#34;, pf(x, y)); } int main() { int input = 0; do { menu(); printf(\u0026#34;请选择:\u0026gt;\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); switch (input) { case 1: Calc(Add); break; case 2: Calc(Sub); break; case 3: Calc(Mul); break; case 4: Calc(Div); break; case 0: printf(\u0026#34;退出\\n\u0026#34;); break; default: printf(\u0026#34;选择错误，请重新选择\u0026#34;); break; } } while (input); return 0; } 2.特殊类型指针 2.1 Void 无具体类型的指针 void* 类型的指针可以接收任意类型的地址\n示例：\n1 2 3 4 5 int a = 10; char ch = \u0026#39;a\u0026#39;; void* pv1 = \u0026amp;a;//\u0026amp;a类型为int* void* pv2 = \u0026amp;ch;//\u0026amp;ch类型为char* 上面的代码中，void* 类型的指针既可以接收 int* 类型的地址，也可以接收 char* 类型的地址\n（1）注意 void*类型的指针不能直接进行解引用操作，也不能进行+-运算\n（2）应用场景：当不清楚别人会传什么类型的地址给程序时，可用void*类型的指针接收\n（3）如果需要对void*类型的指针进行解引用操作或进行+-运算，那么需要先将接收到的void*类\n​ 型的指针强制类型转换成所需要的类型，再进行操作\n2.2 野指针 概念\n指针指向的空间是随机的，不正确的\n这块空间不属于当前程序所占有的，当前程序没有权限去访问这块空间\n造成野指针的原因\n产生原因：1.指针未初始化 （如：int* p;）\n​ 2.指针越界访问\n​ 3.指针指向的空间已被销毁\n1.指针未初始化\n一个局部变量如果不初始化，它的值是随机的\n1 2 int* p;//指针未初始化，随机值 *p = 20;//p就是野指针 上面这段代码中，p 是局部变量，但是没有初始化，它的值是随机的，如果将p中存放的值当成地址，就会形成非法访问\n2.指针越界访问\n当解引用到非法空间时，就是野指针\n1 2 3 4 5 6 7 int arr[10] = { 0 }; int* p = \u0026amp;arr[0];//取出数组arr的第一个元素的地址 for (int i = 0; i \u0026lt;= 10; i++) { *p = i;//当 i = 10 ，p 越界访问arr[10]这块空间的时候，p就是野指针 p++; } 示意图：\n编辑\n3.非法访问\n主函数调用函数，该函数返回一个局部变量的地址（局部变量进函数创建，出函数就销毁）给主函数里的指针，此后指针若进行解引用操作，就会形成非法访问\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int test() { int n = 100;//n是局部变量，进入函数，开辟一块空间存放n return \u0026amp;n;//n的地址返回 }//出函数，n的空间被销毁 int main() { int* p = test();//调用test函数，p得到n的地址，此时n对应的那块空间已经被销毁 printf(\u0026#34;%d\\n\u0026#34;, *p);//非法访问 return 0; } 如何避免野指针？\n（1）指针初始化（赋明确的地址 或 赋 NULL）\n（2）小心越界\n（3）指针变量不再使用时，及时置NULL，指针使用 之前检查有效性\n（4）避免返回局部变量的地址\n(1) 指针初始化\n当有明确的指向时，直接给指针对应的赋地址；当没有明确的指向时，给指针赋NULL\nNULL：是空指针，值为 0 ，是地址，读写该地址会 报错\nC语言中NULL的定义：（void*)0\n0是整型，强制转换成指针类型\n1 2 3 int a = 10; int* p = \u0026amp;a;//有明确的指向，赋值a的地址 int* p2 = NULL;//没有明确的指向，赋值NULL （2）小心越界\n对指针进行解引用操作前，要先确保指针指向的空间是当前程序所占有的\n（3）指针变量不再使用时，及时置NULL，指针使用 之前检查有效性\n1 2 3 4 5 6 7 int a = 10; int* p = \u0026amp;a; p = NULL;//当不再使用指针变量时，将其置为NULL if (p != NULL)//对指针进行解引用操作前，先检查指针的有效性 { *p = 200; } （4）避免返回局部变量的地址\n局部变量：进入作用域，变量创建，出作用域，变量就被销毁\n返回局部变量的地址，此后指针若进行解引用操作，会形成非法访问\n3.指针代码的优化 3.1 const修饰 3.1.1 const 修饰变量\n常量：值是固定的，不能更改\n变量：值可以改变\n比如下面这段代码中的num就是变量，num的值先是20，后面被修改为30\n1 2 int num = 20; num = 30; const修饰的变量叫常变量\n这个被修饰的变量本质上还是变量，只是不能被修改\n比如下面这段代码：\n1 2 const int num = 20;//num具有了常量的属性，num的值不能被修改 num = 30;//报错 变量num被const修饰，从而具有了常量的属性 ，当修改变量num的值时，编译器就会报错\n再看一段代码：\n1 2 int n = 10; int arr[n];//报错 这段代码会报错的原因是：\nC99之前不支持变长数组，数组的大小需要 常量或常量表达式 来指定，不能用变量来指定\n当我们用const修饰变量n后：\n1 2 const int n = 10;// n被const修饰后，本质上还是变量 int arr[n];//报错 这段代码还是会报错，原因是const修饰的变量本质上还是变量，只是它的值不能被修改\n3.1.2 const修饰指针变量\n引入\n看一段代码：\n1 2 3 4 5 const int n = 10; //n = 200;//无法直接修改 int* p = \u0026amp;n; *p = 200;//n = 200 可以修改 printf(\u0026#34;%d\\n\u0026#34;, n);//200 在上这段代码中：\nconst修饰变量，虽然变量n不能直接修改，但还是可以通过拿到 n 的地址对n进行修改\n但是如果我们不希望 n 能以任何方式被修改，不管是直接被修改，还是通过地址被修改，那么就需要使用const修饰指针变量\n语法\nconst修饰指针变量有两种形式，一种是const放在 * 左边，一种是 * 放在const右边\n（1）const在 * 左边修饰(两种写法)：\n1 2 3 4 5 int n = 10; //const在*左边修饰 const int* p = \u0026amp;n;//写法一 //int const * p = \u0026amp;n;//写法二 此时，如果通过指针变量 p 修改 变量 n 里的内容，就会报错\n1 *p = 20;//err 原因：\nconst放在 * 的左边修饰，不能更改指针指向的 对象里面的内容\n但是指针可以更改指向的对象，也就是指针可以不指向原来的地址\n比如：\n1 2 3 4 5 int n = 10; int m = 100; const int* p = \u0026amp;n;//const在*左边修饰 p = \u0026amp;m;//ok （2）const在 * 右边修饰：\n1 2 3 4 5 int n = 10; int m = 100; //const在*右边修饰 int* const p = \u0026amp;n; 此时如果更改 p 指向的对象，会报错\n1 p = \u0026amp;m;//err 原因：\nconst在*右边修饰的时候，指针不能更改指向的对象\n但是可以更改指针指向的 变量里的内容\n1 2 3 4 5 int n = 10; int m = 100; int* const p = \u0026amp;n;//const在*右边修饰 *p = 200;//ok （3）如果const在 * 左右两边都修饰：\n1 2 3 4 5 6 7 int n = 10; int m = 100; //const同时在 * 的左右两边修饰 const int* const p = \u0026amp;n; *p = 200;//err p = \u0026amp;m;//err 结论\n当const在 * 左边修饰时，指针指向的 变量的值 不能被修改\n当const在 * 右边修饰时，指针的指向不能变，指针不能更改指向的对象\n3.2 assert断言 可用于检测指针的有效性\n1.使用assert（）宏要包含头文件assert.h\n2.判断括号里的表达式，若为真，程序正常运行； 若为假，在屏幕上写入错误信息，未通过该表达 式，并显示出问题的文件名以及行号\n例如：\n1 2 int* p = NULL; assert(p != NULL);//括号里面的值为假就会报错 编辑\n3.如果不需要再执行assert（），可直接在它的头文件前面定义一个宏NDEBUG\n例如：\n1 2 3 4 5 6 7 8 9 #define NDEBUG #include\u0026lt;assert.h\u0026gt; int main() { int* p = NULL; assert(p != NULL);//定义了NEDBUG宏后，assert失效，不会报错 return 0; } 可以通过注释掉 #define NDEBUG 这条语句，使得 assert 语句可以执行\nassert（）会增加程序的运行时间\nVS中，在release版本下，可选择禁用assert（），默认会优化掉assert（）\n三、指针进阶 1. qsort函数 基本介绍\n冒泡排序，只能排序整型数组\nqsort函数，快速排序，可以排序任意类型的数据\n函数原型\n1 2 3 4 5 6 void qsort(void* base, //待排序数组的起始位置 size_t num, //待排序数组的元素个数 size_t width, //每个元素有几个字节 int(*compare)(const void* elem1, const void* elem2)//函数指针，函数要自己实现 // 要比较的那两个元素的地址 ); 函数参数 void* base 使用void*接收目标数组的起始位置，这样可以排任意类型的数据\nint(*compare)(const void* elem1, const void* elem2)\n中compare这个指针可以接收要比较的两个元素的地址，由于不知道要比较的两个元素的类型，\n所以使用void*来接收\n函数的返回值 当第一个元素小于第二个元素时，返回小于0的数字\n当第一个元素大于第二个元素时，返回大于0的数字\n当第一个元素等于第二个元素时，返回等于0的数字\n使用要包含头文件stdlib.h 模拟实现qsort函数(以结构体为例)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 int cmp_stu_by_age(const void* e1, const void* e2) { return ((struct Stu*)e1)-\u0026gt;age - ((struct Stu*)e2)-\u0026gt;age; } int cmp_stu_by_name(const void* e1, const void* e2) { //比较字符串，使用strcmp，要引头文件string.h return strcmp(((struct Stu*)e1)-\u0026gt;name, ((struct Stu*)e2)-\u0026gt;name); } //实现bubble_sort的程序员不知道未来排序的数据类型 //也不知道待比较的两个元素类型 void Swap(char* buf1, char* buf2, int width) { int i = 0; for (i = 0; i \u0026lt; width; i++) { char tmp = *buf1; *buf1 = *buf2; *buf2 = tmp; buf1++; buf2++; } } void bubble_sort(void* base, int sz, int width, int (*cmp)(const void* e1, const void* e2)) { int i = 0; for (i = 0; i \u0026lt; sz - 1; i++)//趟数 { int j = 0; for (j = 0; j \u0026lt; sz - 1 - i; j++)//每一趟比较的对数 { //两个元素的比较 if (cmp((char*)base + j * width, (char*)base + (j + 1) * width) \u0026gt; 0) { //交换 Swap((char*)base + j * width, (char*)base + (j + 1) * width, width); } } } } //测试 struct Stu { char name[20]; int age; }; void test5() { struct Stu s[3] = { {\u0026#34;zhangsan\u0026#34;, 20}, {\u0026#34;lisi\u0026#34;, 30}, {\u0026#34;wangwu\u0026#34;, 10} }; int sz = sizeof(s) / sizeof(s[0]); //使用bubble_sort的程序员一定知道自己排序的是什么数据 //就应该知道如何比较待排序数组中的元素 bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_name); } 2. 指针和数组笔试题解析 2.1 一维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int a[] = { 1, 2, 3, 4 }; printf(\u0026#34;%d\\n\u0026#34;, sizeof(a)); //sizeof(数组名) -- 计算的是整个数组的大小，4*4=16 printf(\u0026#34;%d\\n\u0026#34;, sizeof(a + 0)); //数组名表示数组首元素的地址，+0还是首元素地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*a)); //数组名表示首元素的地址，*a就是首元素，4字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(a + 1)); //数组名表示数组首元素的地址，+1跳过一个元素，是第二个元素的地址，4或8字节 // printf(\u0026#34;%d\\n\u0026#34;, sizeof(a[1])); //第二个元素的大小，4字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a)); //\u0026amp;a取出的是数组的地址，但数组的地址也是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*\u0026amp;a)); //\u0026amp;a数组的地址，数组的地址解引用访问的数组，sizeof计算的就是数组的大小，16字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a + 1)); //\u0026amp;a取出的是数组的地址，+1跳过整个数组，但还是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a[0])); //\u0026amp;a[0]第一个元素的地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a[0] + 1)); //\u0026amp;a[0]第一个元素的地址，\u0026amp;a[0] + 1第二个元素的地址，4或8字节 数组名是数组首元素的地址\n但有两个例外：\nsizeof(数组名) - 数组名表示整个数组\n\u0026amp;数组名 - 数组名表示整个数组，即取出整个数组的地址\n​\n2.2 字符数组 ==char arr[] = {\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;,\u0026lsquo;f\u0026rsquo;};==\nsizeof\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 char arr[] = { \u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39; }; printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr)); //sizeof(数组名) - 整个数组的大小，6*1=6字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr + 0)); //arr数组首元素地址，arr+0还是首元素的地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*arr)); //arr数组首元素地址，*arr首元素，1字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr[1])); //第二个元素的大小，1字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr)); //\u0026amp;arr取出整个数组的地址，但还是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr + 1)); //\u0026amp;arr整个数组的地址，\u0026amp;arr+1跳过整个数组，还是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr[0] + 1)); //\u0026amp;arr[0]首元素的地址，\u0026amp;arr[0]+1第二个元素的地址，4或8字节 strlen\n1 2 3 4 5 6 7 8 9 10 char arr[] = { \u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39; }; printf(\u0026#34;%d\\n\u0026#34;, strlen(arr));//随机值 printf(\u0026#34;%d\\n\u0026#34;, strlen(arr + 0));//随机值 printf(\u0026#34;%d\\n\u0026#34;, strlen(*arr));//err //*arr是元素\u0026#39;a\u0026#39;，对应ASCII码值为97，strlen把97当做地址，然后向后访问，形成非法访问 printf(\u0026#34;%d\\n\u0026#34;, strlen(arr[1]));//err printf(\u0026#34;%d\\n\u0026#34;, strlen(\u0026amp;arr));//取的是数组的地址，数组的地址也从起始位置开始，随机值 printf(\u0026#34;%d\\n\u0026#34;, strlen(\u0026amp;arr + 1));//跳过整个数组，从数组最后的地址开始访问，随机值-6 printf(\u0026#34;%d\\n\u0026#34;, strlen(\u0026amp;arr[0] + 1));//从第二个元素的地址开始，随机值-1 ​\n==char arr[] = \u0026ldquo;abcdef\u0026rdquo;;==\nsizeof\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { char arr[] = \u0026#34;abcdef\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr));//7，包括\\0 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr + 0));//4/8，地址 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*arr));//1，char类型元素的大小 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr[1]));//1，第二个元素的大小 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr));//4/8，取出整个数组的地址，还是地址 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr + 1));//4/8，跳过整个数组后的地址 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr[0] + 1));//4/8，第二个元素的地址 return 0; } strlen\n​\n==char *p = \u0026ldquo;abcdef\u0026rdquo;;==\nsizeof\nstrlen\nstrlen 和 sizeof区分\n1.strlen是求字符串长度的，只能针对字符串求长度，目的是找到\\0 \u0026ndash;是库函数，得引头文件\nstrlen的参数要的是地址，通过对该地址解引用，如果不是\\0就长度+1\n2.sizeof计算变量、数组、类型的大小 \u0026ndash; 单位是字节 \u0026ndash;是操作符\n2.3 二维数组 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n引言 C语言中的数据类型分为内置类型和自定义类型\n其中内置类型就是C语言本身就有的数据类型，比如我们学过的char,short,int,long,float,double… 自定义类型包括结构体、枚举、联合体\n由于内置类型能描述的数据有限，无法直接描述像人和书这样的复杂对象\n比如: 如果我们想描述学生，那么学生一定有姓名（字符型），年龄（整型），成绩（浮点型），学号（整型）…\n如果我们想描述书，那么书一定有书名（字符型），作者（字符型），价格（浮点型）…\n因此，这个时候我们就需要使用C语言中的自定义类型来自己创造这些复杂类型，用来描述复杂对象\n一. 结构体入门： 结构是一些值的集合，这些值被称为成员变量 结构体的每个成员可以是不同类型的变量（数组的每个成员必须是相同类型的变量） 结构体成员的类型可以是基本数据类型，数组，指针，甚至是结构体\n1.1 结构体类型的声明 一般结构体的声明：\n1 2 3 4 struct tag { member - list; }variable-list;//注意：分号不能少 struct：结构体的关键字 tag：结构体标签，可以随意替换，比如要描述书，就可以用Book，描述学生，就可以用Student member - list：成员列表，由一个或多个成员变量组成 variable-list：变量列表\n例如：如果我们想要创建一个学生对象，我们需要先声明学生类型，那么我们如何描述学生的属性呢？我们知道学生一定有姓名，年龄，性别，手机号等信息。因此，简单的学生结构体类型声明如下 1.2 结构体变量的创建和初始化 结构体变量的创建 结构体变量可以在声明的时候就创建 结构体既可以创建全局变量，也可以创建局部变量 结构体的初始化 结构体的初始化要使用大括号（数组初始化时也要用大括号） 结构体的初始化可以用通过两种方式，一种是按顺序来初始化，一种是不按顺序来初始化\n（1）按顺序来初始化 按照结构体类型声明时成员的顺序，给创建的结构体变量赋初始值\n一般初始化： 上面结构体成员声明的顺序是name，age，score，所以初始化的时候也按照这个顺序来初始化\n结构体的成员是结构体类型时的初始化： 结构体的初始化是一层一层往下初始化的，所以当结构体的成员是结构体类型时，我们要先初始化结构体 然后再对结构体里的成员初始化\n（2）不按顺序初始化 通过 .成员名=初始值 的方式初始化，可以不考虑顺序 1.2 结构体的成员访问 直接访问 结构体变量访问成员通过点操作符（.）来完成的 语法：结构体变量名.成员变量名\n例子1： 运行结果： 例子2： 运行结果： 间接访问 如果我们拿到的是指向结构体变量的指针(地址)，那么我们就可以通过结构体访问操作符 (-\u0026gt;) 加成员名的方式，来访问结构体成员\n同时，这种方式也可以用来修改结构体成员里保存的值\n语法：结构体指针-\u0026gt;成员名\n例如： 在上面这段代码中，我们拿到结构体变量p的地址，用结构体指针变量ptr来接收，通过ptr-\u0026gt;x的方式， 我们就可以访问结构体变量p里的成员x，通过ptr-\u0026gt;x = 10 就可以将成员 x 存放的值(3)修改为10\n1.5 typedef 与 结构体 typedef就是给类型重新取一个名字 有时候，结构体的类型名可能比较复杂，这时我们就可以使用 typedef 来简化结构类型的名字\n比如： 一个结构体的类型名为struct Stu 我们可以使用 typedef 将该类型重命名为Stu 那么这个时候，我们既可以使用struct Stu来创建变量，也可以使用Stu来创建变量\ntypedef 重新定义结构体类型有两种方式 方式一： 方式二： 注意：此时的Stu是类型，不是变量\n1.5 结构体传参 结构体传参分为 拷贝结构体数据 和 拷贝结构体的地址 既然有两种结构体传参方式，那我们在写有关结构体传参的函数时应该选择哪种传参方式呢？\n先看一段代码： 在上面这段代码中，我们先是创建了一个结构体变量s，然后想写一个函数将s里的数据打印出来， 这时，我们发现 在函数的参数部分，我们既可以传结构体的地址，也可以传结构体数据的拷贝 两个函数的实现如下： 如果传的是结构体的数据\n1.3 匿名结构体 匿名结构体类型的声明 匿名结构体类型指的是结构体类型没有名字\n需要注意的是： 匿名结构体的类型只能用一次，也就是【只能在类型声明的同时，直接用这个类型创建变量】 因为如果之后再创建结构体变量，需要类型名+变量名的方式创建，但由于匿名结构体类型没有类型名 所以无法创建 匿名结构体类型的应用 定义两个结构体类型，并且它们的成员相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct { char c; int i; double d; }s1; struct { char c; int i; double d; }* ps;//匿名结构体的指针类型 但是，运行下面这段代码时会报错\n1 2 3 4 5 6 int main() { ps = \u0026amp;s1;//报错 return 0; } 原因是虽然这两个结构体的成员相同，但是它们都是没有名字的， 编译器会认为这是两个不同结构体类型的变量\n二、结构体进阶 2.1 结构体的自引用 2.2 结构体内存对齐 结构体内存对齐\n2.3 结构体实现位段（位段的填充\u0026amp;可移植性） 2.4 结构体与指针 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n第八章 位运算和操作符属性 位运算操作符只适用于整型和字符型\n1.操作符的分类 2.二进制和进制转换 2进制，8进制，10进制，16进制是数值的不同表示形式\n例如：10进制下的15 对应\n​\t2进制的 1111\n​\t8进制的 17\n​\t16进制的 F\n16进制的数以0x开头\n8进制的数以0开头\n2.1 其它进制转10进制 进制的每一位都是有权重的，比如10进制的123\n3*10^0^+2*10^1^+1*10^2^ = 3+20+100=123\n2进制同理\n2.2 转2进制 （1）10转2\n将十进制数字除2的余数倒过来\n（2）八转二\n从低位开始，每一位转成3个相应的二进制数即可\n（3）十六转二\n从低位开始，每一位转成4个相应的二进制数即可\n2.3 2进制转8进制 8进制的数字范围：0~7\n从低位开始，每三位为一组，转成相应的八进制数即可\n2.4 2进制转16进制 从低位开始，每四位为一组，转成相应的十六进制数即可\n2.5原码、反码、补码 整数的2进制表示形式有3种：原码、反码、补码\n整数又分为有符号整数和无符号整数\n有符号整数的原码、反码、补码的二进制表示中均由符号位和\n数值位两部分组成\n1.二进制的最高位（最左边）是符号位：0表示正数，1表示负数\n2.正数原码，反码，补码都一样（三码合一）\n3.==负数的反码=它的原码符号位不变，其它位取反（0变1,1变0）==\n4.==负数的补码=它的反码+1==，负数的反码=负数的补码-1\n补码转原码：-1，取反（符号位不变）注意：正数三码合一\n注意\n0的反码，都是0\n==在计算机运算的时候，都是以补码的方式来运算的==\n(补码把正数和负数统一起来了)\n==看运算结果，要看原码==\n题目 法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { //1.输入x，s int x; int ret = 0; string s; cin \u0026gt;\u0026gt; x; cin \u0026gt;\u0026gt; s; //2.求出s的长度 int n = s.size(); //3.遍历字符串（从后往前遍历） int j = 0; for(int i = n - 1; i \u0026gt;= 0; i--) { //\t1)找出每一个字符-转换成整数 //\t如果是数字字符，让其减字符0； //\t如果是字母字符，让其减字符A，再加10 //\t2)再乘以这一位的权重 //\t3)最终求和 if(s[i] \u0026lt;= \u0026#39;9\u0026#39;) ret += (s[i] - \u0026#39;0\u0026#39;) * pow(x, j); else ret += (s[i] - \u0026#39;A\u0026#39; + 10) * pow(x, j); j++; } cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; return 0; } 法二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int x; string s; cin \u0026gt;\u0026gt; x; cin \u0026gt;\u0026gt; s; int ret = stoi(s, NULL, x); cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; return 0; } 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; string s = \u0026#34;0123456789ABCDEF\u0026#34;; void x_to_m(int x, int m) { if(x \u0026gt;= m) x_to_m(x / m, m); cout \u0026lt;\u0026lt; s[x % m]; } int main() { int n, m; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; m; //1.将s中的n进制数字转为10进制的整数 int x = stoi(s, NULL, n); //2.将x转换成m进制 x_to_m(x, m); return 0; } 3.位运算操作符 2进制序列中，最高位的1位是被当做符号位\n符号位都是用0表示正”，用1表示负 对于==整形==来说：数据存放==内存中==其实存放的是==补码==。 ==计算用补码，结果要看原码==（即用补码计算完后要把补码转为原码） 左移右移都不能移符号位\n左移操作符（乘2的效果）\na \u0026laquo; 1 对原变量无影响\na\u0026laquo;= 1 左移后赋给自己\n乘2的效果，主要针对正数/无符号数\n右移操作符（除2的效果）\n逻辑右移，左边补0\n算数右移（通常是），左边原来是正数：补0\n​ 负数：补1\n\u0026amp;按位与（二进制位的运算）\n对应二进制位 同为1，才为1；==有0为0==\n按位或（二进制位的计算）\n==有1为1==；同时为0，才为0\n^按位异或（二进制位的运算）\n==相同为0，相异为1==，不存在进位，不会溢出\n0 ^ 任何数 = 任何数本身 自身^自身 = 0 支持交换律 3 ^ 5 ^ 3=5 ~按位取反（二进制位），1个对象，0变1,1变0\n4.位运算的应用 4.1判断奇数和偶数 规律1：\n所有偶数的2进制表示中，最低位一定是0, 所有奇数的2进制表示中，最低位一定是1 规律2：\n(x \u0026amp; 1) == 0，说明x是偶数 (x \u0026amp; 1) == 1，说明x是奇数 题目\n通过判断n % 2的结果是1还是0，无法判断n是奇数还是偶数\n因为n可能为负数\n常规写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; if(n % 2 == 1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else if(n % 2 == -1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;even\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 使用\u0026amp;：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; if((n \u0026amp; 1) == 1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;even\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 4.2保留整数2进制中的指定位 场景：\n我们希望保留1个整数的2进制中某个位或者某几个位，其它位不需要就置为0。\n我们可以将一个值m的2进制位中需要取出的位 置为1，其它位为0\n然后 x\u0026amp;m 即可\n实际应用场景\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #define READ_PERMISSION 0x01 // 0001，表⽰读权限 #define WRITE_PERMISSION 0x02 // 0010，表⽰写权限 #define EXECUTE_PERMISSION 0x04 // 0100，表⽰执⾏权限 int main() { int permissions = 0x03; // ⼆进制: 0011，具有读和写权限 if (permissions \u0026amp; READ_PERMISSION) { printf(\u0026#34;阅读权限被设置\\n\u0026#34;); } else { printf(\u0026#34;阅读权限未被设置\\n\u0026#34;); } if (permissions \u0026amp; WRITE_PERMISSION) { printf(\u0026#34;写权限被设置\\n\u0026#34;); } else { printf(\u0026#34;写权限未被设置\\n\u0026#34;); } if (permissions \u0026amp; EXECUTE_PERMISSION) { printf(\u0026#34;执⾏权限被设置\\n\u0026#34;); } else { printf(\u0026#34;执⾏权限未被设置\\n\u0026#34;); } return 0; } 4.3获取二进制中的指定位 场景\n我们希望获得一个==整数x二进制中的第i位==（其实就是确定==第i位是0还是1==），\n就可以 (x \u0026raquo; i) \u0026amp; 1，结果是0，那么第i位就是0，结果是1，那么第i位就是1\nx \u0026raquo; i 使得x的第i位来到最低位，然后再按位与\u0026amp;1就能获得第i位是1还是0\n第i位是从右向左，最右边是第0位\n题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t ret = 0; uint32_t i = 0; for(i = 0; i \u0026lt; 32; i++) { //得到n的二进制位中的第i位 int b = (n \u0026gt;\u0026gt; i) \u0026amp; 1; //移动这个二进制位到合适的位置，然后 //存放在ret中 ret |= b \u0026lt;\u0026lt; (31-i); } return ret; } }; 应用场景\n例如：在嵌入式系统中，传感器通常通过寄存器返回数据。某些寄存器可能包\n含多个信息字段，例如状态标志、错误码等。这些字段往往位于寄存器的特定\n位中，需要通过获取指定位的值来读取。\n4.4将指定位设置为1 场景：有时候需要将一个整数x的二进制位中的，==某几位设置为1==，其余位置\n保留原值，那么可以让m的二进制对应位上是1，然后x |= m就可以将x的指\n定二进制位设置为1\n也可以将x的二进制位的第i位设置为1，只需要让m=1左移i位，然后让x|=m\n题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int findComplement(int num) { int ret = 0;//存放的是补码 //因为1 \u0026lt;= num \u0026lt; 2的31次方，所以num是正数 //当num向右移到num=0的时候，有效位就处理完了 int i = 0;//当前获取的位 while(num) { //num的第i位是1还是0 int b = num \u0026amp; 1; if(b == 0) { //将ret的第i位改为1 //因为ret本来=0 int tmp = 1; ret |= (tmp \u0026lt;\u0026lt; i); } num \u0026gt;\u0026gt;= 1; i++;//num的第i位 } return ret; } }; 4.5将指定位设置为0 例如：将x的二进制表示形式00001011中的第3位设置为0，其余位置保持不变\n那么我们需要有一个数m的二进制为11110111让它按位与上x，m如何得到呢\n我们可以1\u0026laquo;3然后取反，即x \u0026amp;= ~(1\u0026lt;\u0026lt;i);\n4.6反转指定二进制位 将一个整数x的二进制中第i位取反（0变1,1变0）\nx ^= (1\u0026lt;\u0026lt;i);\n比如：将x的二进制表示00101011的第2位反转，其余位保持原来的值不\n变，只需要将m = (1 \u0026laquo; 2) 和x异或\n4.7将2进制中最右边的1置为0 例如：将整数x的二进制位00101100中的最右边的1变成0，其余位不变\n就可以x \u0026amp;= (x-1)\n这个表达式常用于计算一个二进制序列中有几个1，因为该运算每次都\n会去掉一个1，一个整数的二进制中1的个数也就是该整数经过该运算后\n变为0之前运算了几次的个数\n题目\n方法1：\n1 2 3 4 5 6 7 8 9 int hammingWeight(int n) { int cnt = 0; while(n) { n \u0026amp;= (n-1); cnt++; } return cnt; } 方法2：\n1 2 3 4 5 6 7 8 9 10 11 int hammingWeight(int n) { int cnt = 0; //让n每次向右移1位，直到n为0（因为n是正数） while(n) { if(n \u0026amp; 1) cnt++; n \u0026gt;\u0026gt;= 1; } return cnt; } 法三：正数负数都可\n1 2 3 4 5 6 7 8 9 10 int hammingWeight(int n) { int cnt = 0; //让n每次向右移1位，直到n为0（因为n是正数） for(int i = 0; i \u0026lt; 32; i++) { if((n \u0026gt;\u0026gt; i) \u0026amp; 1) cnt++; } return cnt; } 题目\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: bool isPowerOfTwo(int n) { //1 - 01 //2 - 10 //4 - 100 //8 - 1000 //规律：2的幂次方的二进制表示中只有1个1 //所以2的幂满足：1.n\u0026gt;=1 2.n\u0026amp;(n-1)==0 return (n \u0026gt;= 1) \u0026amp;\u0026amp; ((n \u0026amp; (n-1)) == 0);//(n \u0026amp; (n-1)可以去掉1个1 } }; 4.8只保留2进制中最右边的1 4.9异或的巧用 5.操作符的优先级和结合性 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"第11章【加餐】使用指针实现链表 1.数据结构介绍 1.1什么是数据结构？ 数据结构是计算机的内存中存储和组织数据的方式\n数据结构关注如何以最有效的方式组织和存储数据，以便在计算机程序\n程序中进行操作和处理\n1.2为什么需要数据结构？ 在日常生活中，餐厅里如果客人很多，他们就会将客人的订单\n排列好，比如先上1号桌的菜、再上2号桌\u0026hellip;，这样就不会出现客户\n就餐体验差、等餐时间长、餐厅营业混乱等情况\n同理，程序如果不对数据进行管理，可能会导致数据丢失、操作数据困\n难、野指针等情况。\n通过数据结构，能够有效将数据组织和管理在一起。\n按照我们的方式任意对数据进行增、删、改、查等操作。\n1.3常见数据结构分类 一般按照组织形式，分为：线性数据结构和非线性数据结构\n2.链表 2.1概念 链表是一种线性的数据结构，由一系列的结点组成。\n每个结点包含两个部分：数据和指向下一个节点的指针\n链表中的元素在内存中不一定是顺序排列的，而是通过指针相互\n连接\n2.2链表的结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; //声明一个节点的类型 struct Node { int data; Node* next; }; int main() { struct Node n1 = {1, NULL}; struct Node n2 = { 2, NULL }; struct Node n3 = { 3, NULL }; struct Node n4 = { 4, NULL }; n1.next = \u0026amp;n2; n2.next = \u0026amp;n3; n3.next = \u0026amp;n4; return 0; } 2.3链表的分类 单向：每个节点只有一个指针指向下一个节点 双向：每个节点有两个指针，分别指向前一个节点和后一个节点 循环：尾结点指向头结点 不循环 2.4单链表的实现 动态申请链表结点和链表构建 我们前面实现的链表的节点都是局部变量，局部变量是存放在栈区的，\n生命周期比较短，出作用域就系统自动回收所在空间。\n但是我们希望创建一个链表，存好数据后，在我不希望这个节点回收的时候，\n它就不能回收，它得保持一直存在。（出了作用域也得存在）\n所以，我们可以使用之前学过的动态内存管理的知识，使用new和delete\nnew是在堆区申请空间，申请后会返回对应空间的地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //声明一个节点的类型 struct Node { int data; Node* next; }; Node* CreateNode(int d) { Node* pn = new Node; pn-\u0026gt;data = d; pn-\u0026gt;next = NULL; return pn; } int main() { Node* p1 = CreateNode(1); Node* p2 = CreateNode(2); Node* p3 = CreateNode(3); Node* p4 = CreateNode(4); p1-\u0026gt;next = p2; p2-\u0026gt;next = p3; p3-\u0026gt;next = p4; return 0; } 我们把创建一个新结点封装成一个函数，这样每次创建节点就不需要写三行\n代码了\n单链表的打印 1 2 3 4 5 6 7 8 9 10 void PrintList(Node* pn) { Node* cur = pn; while (cur) { cout \u0026lt;\u0026lt; cur-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } 单链表头插元素 首先，我们需要一个指针，指向链表的第一个节点。由于最开始链表\n是空的，所以Node* phead = NULL;又由于头插元素会改变指针phead\n的指向，所以我们传phead的引用\n两种情况\n情况1，链表里没有节点\n创建新节点后，让新节点成为头节点\n情况2，链表里有节点\n创建新节点\n让新节点指向头结点\n让新结点成为新的头节点\n法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void PushFront(Node* \u0026amp;phead, int d) { if (phead == NULL)//空链表 { phead = CreateNode(d); } else { Node* newNode = CreateNode(d); newNode-\u0026gt;next = phead; phead = newNode; } } 法二\n1 2 3 4 5 6 7 void PushFront(Node*\u0026amp; phead, int d) { Node* newNode = CreateNode(d); newNode-\u0026gt;next = phead; phead = newNode; } 单链表尾插元素 实现单链表尾插元素，需要先找尾节点\n然后让链表的尾结点的next指针指向新结点\n**注意：**需要先判断是不是空链表，因为如果是空链表，就不能对phead指针解引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void PushBack(Node*\u0026amp; phead, int d) { //1.创建新节点 Node* newnode = CreateNode(d); if (phead == NULL)//空链表 { phead = newnode; } else//非空链表 { //2.找尾结点 Node* ptail = phead; while (ptail-\u0026gt;next) { ptail = ptail-\u0026gt;next; } //3.让尾结点的next指针指向新节点 ptail-\u0026gt;next = newnode; } } 单链表头删元素 两种情况，链表为空和链表不为空\n链表为空，不删除元素\n链表不为空\n保存头节点的下一个节点的指针next 然后删除头结点 再让指向头节点的指针指向next 1 2 3 4 5 6 7 8 9 10 11 12 13 void PopFront(Node*\u0026amp; phead) { if (phead) { Node* next = phead-\u0026gt;next; delete phead; phead = next; } else { cout \u0026lt;\u0026lt; \u0026#34;链表为空，无法删除\u0026#34; \u0026lt;\u0026lt; endl; } } 单链表尾删元素 两种情况\n链表为空不可删除\n链表不为空\n需要找尾节点和尾结点的前一个结点 销毁尾节点，并让尾节点的前一个节点的next指针指向空 注意链表只有一个节点的情况，前一个节点是NULL，不能解引用\n而且因为可能尾删的时候链表只有一个节点，所以需要使用引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void PopBack(Node*\u0026amp; phead) { if (phead == NULL)//链表为空 { cout \u0026lt;\u0026lt; \u0026#34;链表为空，不可删除\u0026#34; \u0026lt;\u0026lt; endl; } else//链表不为空 { if (phead-\u0026gt;next == NULL)//链表只有一个节点 { delete phead; phead = NULL; } else { Node* prev = NULL; Node* tail = phead; while (tail-\u0026gt;next) { prev = tail; tail = tail-\u0026gt;next; } //释放tail节点 delete tail; tail = NULL; //前一个节点prev的next置为空 prev-\u0026gt;next = NULL; } } } 单链表删除所有元素 链表为空，不可销毁\n链表不为空\n定义一个指针pcur指向头结点，和next指向pcur的下一个节点\n让pcur遍历链表并释放pcur所指向的节点，然后pcur = next，next = next-\u0026gt;next\n循环直到pcur等于空\n因为要删除所有节点，也就是头结点也要置为空\n所以传引用\n法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void DestroyList(Node*\u0026amp; phead) { if (phead == NULL) { cout \u0026lt;\u0026lt; \u0026#34;链表为空，不可销毁\u0026#34; \u0026lt;\u0026lt; endl; } else { Node* next = phead-\u0026gt;next; while (phead) { delete phead; phead = next; if(next) next = next-\u0026gt;next; } next = phead = NULL; } } 法2：\n1 2 3 4 5 6 7 void DestroyList(Node*\u0026amp; phead) { while (phead) { PopFront(phead); } } 2.5面向对象的方式实现链表 在C++中，struct里面不仅可以有成员变量，还可以有成员函数\n在同一个struct中，成员函数默认可以直接访问成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include \u0026lt;iostream\u0026gt; using namespace std; //声明一个节点的类型 struct Node { int data; Node* next; }; //链表 class List { private: //成员变量 Node* phead; // 指向第一个节点的指针 public: //成员函数 //构造函数 List() { cout \u0026lt;\u0026lt; \u0026#34;调用构造函数\u0026#34; \u0026lt;\u0026lt; endl; phead = NULL; } //析构函数 - 释放链表 ~List() { cout \u0026lt;\u0026lt; \u0026#34;调用析构函数\u0026#34; \u0026lt;\u0026lt; endl; while (phead) { PopFront(); } } //创建节点 Node* CreateNode(int d) { Node* pn = new Node; pn-\u0026gt;data = d; pn-\u0026gt;next = NULL; return pn; } //链表元素的打印 void PrintList() { Node* cur = phead; while (cur) { cout \u0026lt;\u0026lt; cur-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } //头插 void PushFront(int d) { Node* newNode = CreateNode(d); newNode-\u0026gt;next = phead; phead = newNode; } //尾插 void PushBack(int d) { //1.创建新节点 Node* newnode = CreateNode(d); if (phead == NULL)//空链表 { phead = newnode; } else//非空链表 { //2.找尾结点 Node* ptail = phead; while (ptail-\u0026gt;next) { ptail = ptail-\u0026gt;next; } //3.让尾结点的next指针指向新节点 ptail-\u0026gt;next = newnode; } } //头删 void PopFront() { if (phead) { Node* next = phead-\u0026gt;next; delete phead; phead = next; } else { cout \u0026lt;\u0026lt; \u0026#34;链表为空，无法删除\u0026#34; \u0026lt;\u0026lt; endl; } } //尾删 void PopBack() { if (phead == NULL)//链表为空 { cout \u0026lt;\u0026lt; \u0026#34;链表为空，不可删除\u0026#34; \u0026lt;\u0026lt; endl; } else//链表不为空 { if (phead-\u0026gt;next == NULL)//链表只有一个节点 { delete phead; phead = NULL; } else { Node* prev = NULL; Node* tail = phead; while (tail-\u0026gt;next) { prev = tail; tail = tail-\u0026gt;next; } //释放tail节点 delete tail; tail = NULL; //前一个节点prev的next置为空 prev-\u0026gt;next = NULL; } } } }; int main() { List list1;//创建了一个空链表 list1.PushBack(1); list1.PushBack(2); list1.PushBack(3); list1.PushBack(4); list1.PrintList();//1 2 3 4 return 0; } ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"第十章【加餐】 指针和动态内存管理 1.指针 1.1内存和地址 计算机上CPU（中央处理器）在处理数据的时候，需要的数据是在内存中读取\n的，处理后的数据也会放回到内存中，为了高效管理内存空间，我们需要把内\n存划分成一个一个的内存单元单元，每个内存单元的大小为1个字节\n一个比特位可以存储一个2进制的位1或者0\n1.2指针变量 取地址操作符\u0026amp;\n变量创建的本质就是向内存申请空间\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; //创建a变量的时候，其实是向内存申请4个字节的空间，存放10这个数值 return 0; } 申请到的每个字节都有地址\n\u0026amp;a取出的是a所占4个字节中地址较小的字节的地址\n指针变量\n我们通过取地址操作符\u0026amp;，拿到的地址是一个数值，比如：0x0117FADB，这个\n数值有时候也是需要存储起来，方便后期再使用。\n我们把这样的地址值存放在指针变量中\n1 2 3 4 5 6 7 8 int main() { int a = 10; int* pa = \u0026amp;a;//pa就是一个存放地址的变量 -- 指针变量 //编号 == 地址 == 指针 return 0; } 如果创建一个指针变量的时候，还不知道存储谁的地址，这时我们可以给这个指\n针变量赋值为NULL，NULL在C++中的值是0，表示空指针，意思是没有指向任何\n有效的变量\n当然0也是作为地址编号的，这个地址是无法使用的，读写该地址会报错\n1 2 char ch = \u0026#39;w\u0026#39;; char* pc = \u0026amp;ch; 解引用操作符\n我们通过取地址操作符\u0026amp;取出了变量的地址，并用指针变量存储了变量的地址\n那么得到变量的地址后，我们如何通过指针变量来修改变量呢？\n需要使用解引用操作符\n1 2 3 4 5 6 7 8 9 int main() { int a = 10; int* pa = \u0026amp;a; *pa = 100;//* -- 解引用操作符 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//100 return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 int main() { //int* p = NULL; //*p = 100;//err //正确写法 int* p = NULL; if (p != NULL) *p = 100; return 0; } 1.3指针类型 指针类型的意义：1.指针的解引用 2.指针+-整数\n1.3.1指针的解引用 指针的类型决定了，对指针解引用的时候有多大的权限（⼀次能操作几个字节）\n比如： char* 的指针解引用就只能访问⼀个字节，而 int* 的指针的解引用就能访问四个字节\n1.3.2指针+-整数 结论：指针的类型决定了指针向前或者向后走⼀步有多大（距离）。\n字符的地址使用cout打印会以为是字符串，所以这里使用printf打印\n1.3.3void*指针 void类型的指针是一种无具体类型的指针，或者叫泛型指针。\n这种类型的指针可以用来==接受任意类型地址==，但是void*类型的指针不能直接进行\n指针+-整数和解引用运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int n = 0; char ch = \u0026#39;w\u0026#39;; int* p1 = \u0026amp;n; char* pc = \u0026amp;ch; void* p2 = \u0026amp;n; void* p3 = \u0026amp;ch; return 0; } void*类型的指针一般是使用在函数参数部分，用于接受不同类型数据的地址\n这样设计可以实现泛型编程的效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void test(void* p) { //... } int main() { int a = 10; test(\u0026amp;a); double d = 3.14; test(\u0026amp;d); return 0; } 1.4指针访问数组 练习：有一个整型数组，10个元素，默认初始化为0，现在要求让数组的内容设置\n为1~10，然后打印数组的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { int arr[10] = { 0 }; int* parr = arr; //赋值1~10 for (int i = 0; i \u0026lt; 10; i++) { *(parr + i) = i + 1; } //打印 for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; *parr \u0026lt;\u0026lt; \u0026#34; \u0026#34;; parr++; } cout \u0026lt;\u0026lt; endl; return 0; } 2.动态内存管理 我们知道变量的创建会为变量申请一块内存空间，数组的创建其实也向内存申请一块连续的空间\n这两种方式，如果创建的是全局的变量和数组，是在内存的静态区\n（数据段）申请的，如果是局部变量和数组，是在内存的栈区申请的\n不管是全局变量还是局部变量，申请和回收都是系统自动完成的，\n不需要程序员自己处理\n2.1new和delete 在C++中，使用new和delete操作符来进行动态内存管理\nnew负责申请内存 new操作符返回的是申请到的内存空间的起始地址，需要指针存放 new申请一个变量的空间，new[]申请一个数组的空间 delete负责释放（回收）内存 delete负责释放一个变量的空间，delete[]释放一个数组的空间 new和delete配对使用，new[]和delete[]配对使用 申请变量空间\n1 2 3 4 5 6 7 8 9 10 11 //申请内存 //申请一块整型空间 int* ptr1 = new int; //申请一块整型空间的时候，给它初始化一个值10 int* ptr2 = new int(10); //释放 delete ptr1; ptr1 = NULL; delete ptr2; ptr2 = NULL; 申请数组空间\n1 2 3 4 int* ptr3 = new int[10]; //... //释放 delete[] ptr3; 提示\nnew 不是只能给内置类型开辟空间，也可以给自定义类型开辟空间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main() { int* ptr3 = new int[10]; //使用ptr3给数组赋值：1~10 int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(ptr3 + i) = i + 1; } //打印 for (i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; *(ptr3 + i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //释放 delete[] ptr3; ptr3 = NULL; return 0; } *(ptr3 + i)也可以写成ptr3[i]\n注意：使用new和delete申请的空间需要程序员自己手动释放\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n第四章 数组 1.一维数组 数组是一组相同类型元素的集合\n数组中存放1个或多个数据，但是数组元素个数不能为0\n1.1范围for 范围for是C++11引入的新特性\n语法\n1 2 for(类型 变量名 : 数组名) 语句 //多条语句使用大括号 范围for会将数组里面的元素依次放到变量里面，然后通过循环可以打印变量\n例如：使用范围for打印数组里的每一个元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; //范围for int main() { int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; for(int e : arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 使用范围for不会修改数组里元素的值\n因为变量e和数组是两块独立的空间\n==注意：范围for一定会将整个数组遍历完==\n1.2auto关键字 auto作用：让编译器自动推导出变量的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //auto自动推导类型 for(auto e : arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 1.3memset设置数组内容 memset是用来来设置内存的，将内存中的值==以字节为单位==设置成想要的内容\n需要包含头文件\u0026lt;ctring\u0026gt;\nmemset会一个字节一个字节地设置内存里的值\nptr：指向要设置的内存块的起始位置\nvalue：要设置的值\nnum：设置字节的个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //memset int main() { char arr[] = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; //将字符串从第2个字符开始的后五个字符设置为字符x memset(arr + 2, \u0026#39;x\u0026#39;, 5); // 数组名是数组首元素的地址 cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; //将字符串的前五个字符设置为字符x //\tmemset(arr, \u0026#39;x\u0026#39;, 5); //\tcout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; return 0; } 注意：如果是整型数组，一般使用memset将数组设置为0\n因为==memset是一个字节一个字节设置内存的==\n例如下面这段代码不会将数组里的每个元素设置为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { int arr[5] = {1, 2, 3, 4, 5}; //将数组里的每个字节改为1 memset(arr, 1, 20); for(auto e : arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 1.4memcypy拷贝数组内容 destnation：目标空间的起始地址\nsource：源数据空间的起始地址\nnum：拷贝的数据的==字节个数==\n将源数据空间里的内容拷贝到目标数据空间\n使用场景：\n将a数组中的内容拷贝到b数组\n如果我们使用下面这种方式是无法实现的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //memcpy int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[10] = {0}; //数组名是地址，地址是常量的值，常量不能被修改 // 例如 5=3这种写法是错误的 b = a; // 报错 return 0; } 需要使用memcpy函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //memcpy int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[10] = {0}; //数组名表示数组首元素的地址 memcpy(b, a, 10 * sizeof(int)); for(auto e : b) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //数组名是地址，地址是常量的值，常量不能被修改 // 例如 5=3这种写法是错误的 //b = a; // 报错 return 0; } 题目 思路分析： 1.创建一个数组，保存患者就诊的年龄，数组大小110 0-18、19-35、36-60、61及以上的人数分别为a,b,c,d 2.循环遍历数组N次，输入每个患者的年龄，并判断 该患者是在0-18、19-35、36-60、61及以上的哪个区间内 从而确定是a++还是b++还是c++还是d++ 3.计算百分比，该年龄段的患者人数/总人数 1)注意保留小数点后两位 2)注意是百分比，计算结果还要乘以100\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; //思路分析： //1.创建一个数组，保存患者就诊的年龄，数组大小110 //\t0-18、19-35、36-60、61及以上的人数分别为a,b,c,d //2.循环遍历数组N次，输入每个患者的年龄，并判断 //\t该患者是在0-18、19-35、36-60、61及以上的哪个区间内 //\t从而确定是a++还是b++还是c++还是d++ //3.计算百分比，该年龄段的患者人数/总人数 // 1)注意保留小数点后两位 // 2)注意是百分比，计算结果还要乘以100 const int N = 110; int arr[N]; int a, b, c, d; int main() { //输入患者人数 int n; cin \u0026gt;\u0026gt; n; //输入患者年龄 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; arr[i]; if(arr[i] \u0026gt;= 0 \u0026amp;\u0026amp; arr[i] \u0026lt;= 18) a++; else if(arr[i] \u0026gt;= 19 \u0026amp;\u0026amp; arr[i] \u0026lt;= 35) b++; else if(arr[i] \u0026gt;= 26 \u0026amp;\u0026amp; arr[i] \u0026lt;= 60) c++; else d++; } //计算输出 printf(\u0026#34;%.2f%%\\n\u0026#34;, a * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, b * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, c * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, d * 1.0 / n * 100); return 0; } **优化：**我们原先是先将数据读到数组里面，然后对数组里的每个数据进行分析\n​\t其实我们可以读一个数据，然后分析一个数据，也就是不将数据存起来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int a, b, c, d; int main() { int age; //输入患者人数 int n; cin \u0026gt;\u0026gt; n; //输入患者年龄并判断 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; age; if(age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 18) a++; else if(age \u0026gt;= 19 \u0026amp;\u0026amp; age \u0026lt;= 35) b++; else if(age \u0026gt;= 26 \u0026amp;\u0026amp; age \u0026lt;= 60) c++; else d++; } //计算输出 printf(\u0026#34;%.2f%%\\n\u0026#34;, a * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, b * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, c * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, d * 1.0 / n * 100); return 0; } 题目 //思路分析： //1.n盏灯的每盏灯的状态都需要存下来，使用数组 //2. 灯开启用1表示，灯关闭用0表示 //3. 灯的编号从1开始 // 即灯的状态信息从数组下标为1的地方开始向后存 //4.n个人遍历数组n次 // n个人都是对这n盏灯进行处理\n//具体实现：定义两个变量 int j 表示第几盏灯\n//第一个人一上来就把灯全部关闭，相当于全局数组的初始状态 //我们从第2个人开始处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 5010; int arr[N]; const int N = 5010; int arr[N]; int main() { //2. n盏灯，n个人 int n; cin \u0026gt;\u0026gt; n; //3. 循环处理，共n个人 //但我们从第二个人开始处理灯的状态 for(int i = 2; i \u0026lt;= n; i++) // i表示人的编号 { //1）处理n盏灯，遍历数组 for(int j = i; j \u0026lt;= n; j++) // j表示灯的编号 { //2）判断灯的编号是不是人的编号的倍数 if(j % i == 0) { //3）是i的倍数，开始判断，如果灯是开的就关闭 // 如果灯是关闭的就打开 if(arr[j] == 1) arr[j] = 0; else arr[j] = 1; }\t} } //4.遍历数组，将灯是关着的编号输出，中间用逗号隔开 for(int i = 1; i \u0026lt;= n; i++) { if(arr[i] == 0) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 2.二维数组 行可以省略，列不能省略\n使用memset初始化二维数组\n使用memset函数要包含头文件cstring\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { int arr[10][10]; // 值是随机的 //从哪开始初始化，初始化成什么， 初始化多少个字节 // sizeof()里面直接跟数组名，计算的是整个数组的大小 memset(arr, 0, sizeof(arr)); //打印 for(int i = 0; i \u0026lt; 10; i++) // 行 { for(int j = 0; j \u0026lt; 10; j++) // 列 { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t}\tcout \u0026lt;\u0026lt; endl; } return 0; } 3.字符数组 3.1基础部分 1 2 3 4 //字符串 cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; //string - C++ 字符数组的初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { //1-直接使用字符串初始化 char ch1[10] = \u0026#34;abcdef\u0026#34;;//abcdef\\0 char ch2[] = \u0026#34;abcdef\u0026#34;;//根据初始化的内容来确定个数 cout \u0026lt;\u0026lt; ch2 \u0026lt;\u0026lt; endl; //2-直接使用字符初始化 char ch3[10] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;};//剩下的四个字符默认初始化为0 char ch4[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;};//末尾没有\\0 cout \u0026lt;\u0026lt; ch4 \u0026lt;\u0026lt; endl; return 0; } 3.2 strlen求字符串长度 strlen统计的是字符串中\\0之前的字符个数\nstr \u0026ndash; 指针，存放的是字符串的起始地址，从这个地址开始计算字符串的长度\n使用要包含头文件\u0026lt;cstring\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr[10] = \u0026#34;abcdef\u0026#34;; //abcdef\\0 //strlen统计字符串\\0之前字符的个数 int len = strlen(arr); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; //6 //计算数组的长度（元素个数） int sz = sizeof(arr) / sizeof(arr[0]); // 字符数组可以直接sizeof(arr) // 10 1 cout \u0026lt;\u0026lt; sz \u0026lt;\u0026lt; endl; //10 return 0; } 如果要使用这种方式 char ch4[] = {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;f\u0026rsquo;};\n最好在末尾主动加上\\0 \u0026mdash;\u0026gt; char ch4[] = {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;f\u0026rsquo;, \u0026lsquo;\\0\u0026rsquo;};\n3.3字符数组的输入 3.3.1输入没有空格字符串 使用printf和scanf\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char arr[10]; scanf(\u0026#34;%s\u0026#34;, arr); printf(\u0026#34;%s\\n\u0026#34;, arr); return 0; } 使用cin和cout\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char arr[10]; cin \u0026gt;\u0026gt; arr; // 会在末尾放\\0 cout \u0026lt;\u0026lt; arr; return 0; } 从指定位置开始输入\n例如：\n1 2 3 4 5 6 7 8 int main() { char arr[10]; scanf(\u0026#34;%s\u0026#34;, arr + 1);//从数组的第二个元素再开始存放 printf(\u0026#34;%s\\n\u0026#34;, arr); return 0; } 3.3.2 输入有空格的字符串 scanf在读取字符串的时候，遇到空格就停止读取\nscanf中的占位符%s，不能简单地等同于字符串，它的规则是：从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止\n==%s的读取不会包含空白字符，所以无法用来读取多个单词==，除非多个%s一使用。 scanf不适合读取可能包含空格的字符串，比如书名或歌曲名 细节：\nsancf（）遇到%s占位符，会在字符串末尾存储一个\\0字符·\nscanf()将字符串读入字符数组时，不会检测字符串是否超过了数组长度，可能会越界\n使用%[m]s，[m]表示读取字符串的最大长度，后面的字符会被丢弃\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char arr[20]; scanf(\u0026#34;%10s\u0026#34;, arr); // 最多读10个字符 printf(\u0026#34;%s\\n\u0026#34;, arr); return 0; } 3.3.2.1解决办法 gets和fgets\n最好使用fgets\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20]; gets(arr); cout \u0026lt;\u0026lt; arr; return 0; } gets函数是从第一个字符开始读取，一直读取到\\n为止，但是不会读取\\n\n但是会在读取到的内容后面自动加上\\0\nstr：读到的内容放哪去\nnum：最多读多少个字符\nstream：从哪里读\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20]; fgets(arr, 20, stdin); // stdin 标准输入流 -- 键盘 cout \u0026lt;\u0026lt; arr; return 0; } fgets也是从第一个字符开始读取，最多读num-1个字符，最后一个位置留给\\0，\n如果num的长度远大于输入的字符串长度，就会一直读取到\\n停止，并且会读取\\n，\n将\\n作为读取到内容的一部分，同时在读取到的内容后自动加上\\0\n使用scanf读取\n将%s改成%\\[^\\n]s，表示一直读取，直到遇到\\n\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20]; scanf(\u0026#34;%[^\\n]s\u0026#34;, arr); cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; return 0; } 这种方式读取，不会将\\n读进来，但是在读取到的字符串末尾加上\\0\n使用getchar一个一个地去读取字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20] = {0}; //开始的时候将数组全部初始化为0，读取后就不需要再在末尾补\\0 //abc def\\n int ch = 0; int i = 0; while((ch = getchar()) != \u0026#39;\\n\u0026#39;) { arr[i] = ch; i++; } cout \u0026lt;\u0026lt; arr; return 0; } 3.7 isdigit判断是否是数字字符 如果给的字符是数字，返回非0，如果不是数字，返回0\n3.8 isalpha判断是否是字母 3.4 字符数组的输出 printf+%s cout 循环的方式逐个字符打印 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a[] = \u0026#34;hello world\u0026#34;; // hello world\\0 int i = 0; while(a[i] != \u0026#39;\\0\u0026#39;) { cout \u0026lt;\u0026lt; a[i]; i++; } return 0; } 使用strlen求字符串长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char a[] = \u0026#34;hello world\u0026#34;; // hello world\\0 int len = strlen(a); // strlen使用要包含头文件cstring int i = 0; for(i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; a[i]; } return 0; } 使用sizeof求数组的长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;}; int sz = sizeof(arr) / sizeof(arr[0]); int i = 0; for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i]; } retunr 0; } 3.5 strcpy 和 strcat strcpy字符串拷贝\n将源拷贝到目的地\n使用要包含头文件cstring\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr1[] = \u0026#34;hello world\u0026#34;; char arr2[20]; strcpy(arr2, arr1);//字符串拷贝 string copy cout \u0026lt;\u0026lt; arr2; return 0; } strcat在字符串末尾追加一个字符\n在目标字符串后面追加源里面的字符串，包括将源字符串里的\\0追加进去了\n目标字符串所在的数组空间要足够大，能放下源里面的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr1[20] = \u0026#34;hello \u0026#34;; char arr2[] = \u0026#34;world\u0026#34;; strcat(arr1, arr2); cout \u0026lt;\u0026lt; arr1; return 0; } 3.6大小写转换函数 3.6.1 islower和tolower 使用要包含头文件\u0026lt;cctype\u0026gt;\n传一个字符或者整数，如果参数c是小写字母，函数就返回一个非0的数字，\n如果不是小写字母，就返回0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int main() { char c = \u0026#39;x\u0026#39;; //cout \u0026lt;\u0026lt; islower(c) \u0026lt;\u0026lt; endl; // 返回非0的数字 if(islower(c)) cout \u0026lt;\u0026lt; \u0026#34;小写字母\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;大写字母\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; (char)tolower(\u0026#39;X\u0026#39;) \u0026lt;\u0026lt; endl; return 0; } 3.6.2 isupper和toupper 3.7判断子串strstr 在str1字符串中查找str2这个子串第一次出现的位置\n如果找到了，就返回第一次出现的地址 如果没有找到，就返回NULL（0） 题目：找第一个只出现一次的字符 法一：暴力统计\n将输入的字符串用字符数组str保存，用两层循环，外层用变量i遍历str，内层再用变量j\n遍历str，让str[i]和str中所有元素相比较，统计个数，因为题目中说只需要找出第一个\n仅出现一次的字符，所以当str[i]遍历完str后，如果统计个数为1就退出循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1110; char str[N]; int main() { cin \u0026gt;\u0026gt; str; // 末尾放上\\n int flag = 0; // 表示是否有仅出现一次的字符 ，默认为0，表示还没出现 int i = 0; while(str[i]) { //拿str[i]和str数组中所有的元素比较，统计个数 int j = 0; int count = 0; while(str[j]) { if(str[i] == str[j]) count++; j++; } //如果是只出现一次，就退出循环 if(count == 1) { cout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; endl; flag = 1; break; } i++; } if(flag == 0) cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 法二：优化\n思路：\n因为给定的字符串只包含小写字母，所以我们可以定义一个大小为128或26的数组\nint nums[128]，每读一个字符，我们就让nums对应的位置++\n再次遍历字符串中的每一个字符，看nums对应位置的值是不是1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1110; char str[N]; int nums[128]; int main() { //\t//1.输入字符串 //\tcin \u0026gt;\u0026gt; str; // abcabd\\0 //\t//\t//2.遍历字符串，顺便统计每个字符的个数 -- int nums[128];//0~127 //\tint i = 0; //\twhile(str[i]) //\t{ //\tnums[str[i]]++; //\ti++; //\t} //1.2.逐个读取字符，然后统计字符出现的个数 int i = 0; while((str[i] = getchar()) != \u0026#39;\\n\u0026#39;) { nums[str[i]]++; i++;\t} //3.再遍历字符串，看一下，哪一个是只出现1次的字符 int flag = 0; // 表示没找到只出现一次的字符 i = 0; while(str[i]) { if(nums[str[i]] == 1) { cout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; endl; flag = 1; break;\t}\ti++; } if(flag == 0) cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 第五章 string 1.string的概念 string字符串是一种更加高级的封装，string字符串串中包含了大量的方法\n在C++中将字符串直接作为一种类型，也就是string类型，使用string类型\n创建的对象就是C++的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 空字符串 string s2 = \u0026#34;abcd\u0026#34;; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } 2.string常见操作 文档\n2.1创建字符串 ==使用string来创建字符串需要包含头文件\u0026lt;string\u0026gt;==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 空字符串 string s2 = \u0026#34;hello world\u0026#34;;//末尾不包含\\0 cout \u0026lt;\u0026lt; \u0026#34;s1:\u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s2:\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } string s1表示创建空字符串，相当于创建整型a，但是未给a一个初始值 string s2 = \u0026ldquo;hello world\u0026quot;表示创建一个字符串s2，它的内容是“hello world”，但是==string中字符串不再以\\0作为结束标志了== 除了以上的两种方式创建字符串，还有一些方式可以创建字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s3(\u0026#34;hello world\u0026#34;); string s4 = s3; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; return 0; } string创建的对象可以直接赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); string s2 = \u0026#34;hehe\u0026#34;; s1 = s2; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // hehe //\tchar arr1[] = \u0026#34;hello world\u0026#34;; //\tchar arr2[] = \u0026#34;hehe\u0026#34;; //\tarr2 = arr1; // 数组名是数组首元素的地址，地址是一个常量值 //\t//3=5//err return 0; } 2.2 string字符串的输入 2.2.1cin的方式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string s(\u0026#34;hello\u0026#34;); //输入 std::cin \u0026gt;\u0026gt; s; //输出 std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; return 0; } cin在读取字符串的时候，如果遇到空格就不会继续读\n2.2.2getline的方式 getline是C++标准库中的一个函数，用于从输入流中读取一行文本，并将其存储为字符串\ngetline函数有两种不同的形式，分别对应着字符串的结束方式\nistream是输入流类型，cin是istream类型的标准输入流对象\nostream是输出流类型，cout是ostream类型的标准输出流对象\ngetline函数是==输入流中读取一行文本信息==，所以如果是在标准输入流（键盘）中读取\n数据，就可以传cin给第一个参数\n第一种getline函数以换行符\\n作为字符串的结束标志，它的一般格式是：\n1 2 string str; getline (cin, str); // cin 表示从输入流中读取信息，str 是存放读取到的信息的字符串 这种方式getline一直读到\\n才停止（不包含 \\n），然后将读到的文本存储到str中\n1 2 3 string s; getline(cin, s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; ​\n第二种getline函数允许用户自定义结束标志，它的一般格式是：\n1 getline (istream\u0026amp; is, string\u0026amp; str, char delim); cin \u0026ndash; 表示从输入流中读取信息\nstr是存放读取到的信息的字符串\ndelim是自定义的结束标志\n从输入流中读取文本，直到遇到用户指定的结束标志字符为止（不包括标志字符）\n1 2 3 string s; getline(cin, s, \u0026#39;q\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.3 size()求字符串长度 size()函数用于获取字符串的长度\n在C++中关于字符串的操作函数都是包含在string中的，所以需要调用这些函数时，\n通常用运算符.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; string s2 = \u0026#34;hello\u0026#34;; string s3 = \u0026#34;hello world\u0026#34;; string s4 = \u0026#34;abc123 !#\u0026#34;; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s3.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4.size() \u0026lt;\u0026lt; endl; return 0; } string是C++提供的一种更加复杂的封装类型，在string类型的变量中加入了\n操作这个字符串的各种方法（函数），比如求字符串的长度，字符串末尾\n插入一个字符等操作。\n所以要对string类型的变量进行各种操作，就可以使用.操作符来使用这些函数\nstring类型的字符串是有下标的，可以实现逐个字符的打印\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; //逐个字符打印 int sz = s.size() ; int i = 0; for(i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; s[i]; } cout \u0026lt;\u0026lt; endl; return 0; } 2.4迭代器(iterator)遍历字符串 迭代器是一种对象，他可以用来遍历容器（比如string）中的元素\n迭代器的作用类似于指针或者数组下标，通过迭代器就可以逐个去找到它的元素\n不过，访问迭代器指向的值的时候，需要解引用*\nstring可以认为是存放字符的容器\nc++中的string提供了多种迭代器，用于遍历和操作字符串中的内容\n2.4.1begin()和end() begin()：返回指向字符串第一个字符的迭代器，需要一个迭代器的变量来接收 end()：返回指向字符串最后一个字符的下一个位置的迭代器 string中begin()和end()返回的迭代器的类型是string::iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; string::iterator it1 = s.begin(); string::iterator it2 = s.end(); //可以打印迭代器指向的那个字符 cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; endl; // 解引用操作 it1++; cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; endl; //可以比较大小 if(it1 \u0026lt; it2) cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;=\u0026#34; \u0026lt;\u0026lt; endl; //计算之间有多少个元素 cout \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; endl; return 0; } 使用迭代器的方式遍历字符串并打印\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; //遍历字符串，打印 //for(auto it1 = s.begin(); it1 \u0026lt; s.end(); it1++) // 可以写auto for(string::iterator it1 = s.begin(); it1 \u0026lt; s.end(); it1++) { cout \u0026lt;\u0026lt; *it1;\t} cout \u0026lt;\u0026lt; endl; return 0; } 还可以倒着打印\n1 2 3 4 5 for(string::iterator it1 = s.end()-1; it1 \u0026gt;= s.begin(); --it1) { cout \u0026lt;\u0026lt; *it1;\t} cout \u0026lt;\u0026lt; endl; 可以通过迭代器找到元素，还可以进行修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; for(string::iterator it = s.begin(); it \u0026lt; s.end(); it++) { *it = \u0026#39;x\u0026#39;; } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.5 push_back()尾部插入 作用：在字符串尾部插入一个字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello \u0026#34;; s.push_back(\u0026#39;w\u0026#39;); s.push_back(\u0026#39;o\u0026#39;); s.push_back(\u0026#39;r\u0026#39;); s.push_back(\u0026#39;l\u0026#39;); s.push_back(\u0026#39;d\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 可以连续插入，如输入26个字母\n1 2 3 4 5 6 string s; for(char i = \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;z\u0026#39;; i++) { s.push_back(i); } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.6字符串的+=和+运算 +=会将原字符串改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello \u0026#34;; s += \u0026#34;world\u0026#34;; // 也可以只+=一个字符 cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } +不会改变原字符串\n1 2 3 string s1 = \u0026#34;hello \u0026#34;; cout \u0026lt;\u0026lt; s1 + \u0026#34;world\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; 字符串可以头部拼接\n1 2 3 string s2 = \u0026#34;hello\u0026#34;; s2 = \u0026#34;world\u0026#34; + s2; // worldhello cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; 2.7 pop_back()尾部删除 pop_back()用于删除字符串中尾部的一个字符。\n使用该函数需要先做一下配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello\u0026#34;; s.pop_back(); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; return 0; } 当一个字符串是空字符串的时候，不能再调用pop_back，这是一种标准未定义的行为\n1 2 string s; s.pop_back(); 如何一个字符一个字符地删除呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello\u0026#34;; //一个字符一个字符的删 while(s.size()) { s.pop_back(); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; // 0 return 0; } 2.8 insert任意位置插入 我们之前学过push_back即在字符串的末尾插入字符，那如果我们想在字符串的中间插入\n字符呢？我们可以使用成员函数insert\n文档\n在这里，我们先学3种：\n在pos前面插入一个string字符串 1 string\u0026amp; insert(size_t pos, const string\u0026amp; str); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; string str = \u0026#34;xxx\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 在3这个下标前面插入str中的字符串 s.insert(3, str); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } pos位置前面插入一个C风格的字符串 1 string\u0026amp; insert(size_t pos, const char* s); 1 2 3 4 5 6 7 string s = \u0026#34;abcdef\u0026#34;; string str = \u0026#34;xxx\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 在3这个下标前面插入字符串\u0026#34;xxx\u0026#34; s.insert(3, \u0026#34;xxx\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; pos位置前面插入n个字符c 1 string\u0026amp; insert(size_t pos, size_t n, char c); 1 2 3 4 5 6 7 string s = \u0026#34;abcdef\u0026#34;; string str = \u0026#34;xxx\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 在3这个下标前面插入1个字符\u0026#39;x\u0026#39; s.insert(3, 1, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.9 find()查找字符/子串 find()函数用于查找字符串中指定子串/字符，并返回子串/字符在字符串中==第一次出现的位置==\n查找string类型的字符串str，默认是从头开始查找，pos可以指定位置开始\n返回值：\n若找到。返回子串/字符在字符串中第一次出现的起始下标位置\n若未找到。返回一个整数值npos。\n通常判断find()函数的返回值是否等于npos就能知道是否查找到子串或字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; string str = \u0026#34;llo\u0026#34;; //默认从头开始查找 size_t n = s.find(str); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; //可以指定要查找的位置 n = s.find(str, n + 1); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 查找C风格的字符串s，默认是从头开始查找，pos可以指定位置开始\n1 2 3 string s = \u0026#34;hello world hello everyone\u0026#34;; size_t n = s.find(\u0026#34;llo\u0026#34;); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; 在字符串的pos这个位置开始查找C风格的字符串s中的前n个字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; //从字符串s下标为0处开始，找word的前3个字符 size_t n = s.find(\u0026#34;word\u0026#34;, 0, 3); // 6 cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; n = s.find(\u0026#34;everyday\u0026#34;, n + 1, 5); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 查找字符c，默认是从头开始，pos可以指定位置开始\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; //查找字符o int n = s.find(\u0026#39;o\u0026#39;); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; n = s.find(\u0026#39;o\u0026#39;, n + 1); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 如果查找不到，会返回npos的值-1，转为无符号整型就是一个非常大的数字\n2.10 substr()截取子串 截取字符串中指定位置指定长度的子串（截取一个字符串中的某个子串）\nsubstr()：不传参数，就从下标为0的位置开始截取，直到结尾，得到的\n​\t是整个字符串\nsubstr(pos)：从指定下标pos位置开始截取子串，直到结尾\nsubstr(pos,len)：从指定下标pos位置开始截取长度为len的子串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; string s1 = s.substr(); // 得到整个字符串 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //从下标为7的位置开始截取字符串，[7, 末尾] string s2 = s.substr(7); cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; //从下标为7的位置开始截取6个字符 string s3 = s.substr(7, 6); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; return 0; } substr()和find()经常配合使用，find()负责查找到位置，substr()从这个位置开始\n向后获得字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { //substr()通常和find()配合使用 string s = \u0026#34;hello world hello everyone\u0026#34;; // 0123456 size_t n = s.find(\u0026#34;world\u0026#34;); string s1 = s.substr(n, 5); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 3.string的关系操作 应用场景：\n登录一个网站，输入的密码要和数据库中正确的密码比较\n介绍：\n我们之前学过C/C++中的内置类型，比如：bool、char、int、long等这些都是\n天然支持关系操作符（\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、==、！=）的。但是string是一种C++\n中封装类型，需要使用运算符重载才能支持关系运算符\nstring字符串和string字符串比较 C风格字符串和string字符串比较， string字符串和C风格字符串比较 注意：至少有一个参数是string类型的字符串。\n​\t两个C风格的字符串只能用strcpy来比较\n字符串比较的规则：比较的是对应位置上字符的ASCII值的大小。不是比较长度\n1 2 3 4 \u0026#34;abc\u0026#34; \u0026lt; \u0026#34;aq\u0026#34; \u0026#34;abcdef\u0026#34; \u0026lt; \u0026#34;ff\u0026#34; \u0026#34;100\u0026#34; \u0026lt; \u0026#34;9\u0026#34; \u0026#34;abc\u0026#34; == \u0026#34;abc\u0026#34; 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1 = \u0026#34;hello world\u0026#34;; string s2 = \u0026#34;hello\u0026#34;; if(s1 == s2 + \u0026#34;world\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;==\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;!=\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 4.和string相关的函数 4.1 stoi/stol stoi是将字符串转换成int类型的值\nstol是将字符串转换成long int类型的值\nstr：要转换的字符串\nidx：是一个输出型参数，也就是这个通过这个参数会带回一个值。\n​\tidx是一个指针，需要在外边创建一个size_t类型的值，传递它的\n​\t地址给idx，这个参数将带回str中==无法正确匹配数字的第一个字符==\n​\t的位置(下标)\nbase：被解析的字符串中数字的进制值，\n2、8、10、16表示将2或8或10或16进制转换成10进制\n如果传递的是0，会根据字符串的内容的信息自动推导进制\n比如：字符串中有0x就认为是16进制，0开头会被认为是8进制\n最终会转换成10进制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;11x22\u0026#34;; // 01234 size_t pos = 0; int r = stoi(s, \u0026amp;pos); // 默认认为s中的数字是10进制的 cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pos=\u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; return 0; } 如果不想要返回的下标，可以传NULL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;11x22\u0026#34;; // 2^1 + 2^0 = 3 size_t pos = 0; int r = stoi(s, \u0026amp;pos, 2); // 认为s中的数字是2进制的 cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; // 3 cout \u0026lt;\u0026lt; \u0026#34;pos=\u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; return 0; } 4.2 stod/stof stod将字符串转换成double类型的值\nstof是将字符串转换成float类型的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;3.14abc234\u0026#34;; size_t pos; double d = stod(s, \u0026amp;pos); //double d = stod(s, 0); //double d = stod(s, NULL); cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; // 4 return 0; } 4.3 to_string to_string函数可以将数字转换成字符串，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { //string s = to_string(3.14); //\tstring s = to_string(110); //\tcout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; string pi = \u0026#34;pi is \u0026#34; + to_string(3.14); cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; return 0; } 题目 思路1：\n读取整个字符串（可能包含空格），cin遇到空格就结束了，getline函数\n可以\n统计字符串中字符的个数，不包含空格和换行符，遍历字符串\n下标 范围for 迭代器 空格和换行符 \u0026ndash; 空白字符\nisspace \u0026ndash; 专门用来判断一个字符是否是空白字符，需要包含头文件cctype\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int main() { string s; //1.读取 getline(cin, s); //2.分析和统计 int cnt = 0; for(auto e : s) { if(isspace(e)) continue; else cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } 下标的方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { string s; //1.读取 getline(cin, s); //2.分析和统计 int sz = s.size(); int cnt = 0; for(int i = 0; i \u0026lt; sz; i++) { if(isspace(s[i])) continue; else cnt++: } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } 方法2：\n逐个单词的方式读取，计算所有单词的字符串长度 \u0026ndash; 求和\ncin \u0026raquo; s会返回一个流对象的引用，即cin本身。\n​\t在C++中，流对象（如cin）可以被用作布尔值来检查流的状态。\n​\t如果流的状态良好（即没有发生错误），流对象的布尔值为true\n​\t如果发生错误（如遇到输入结束符或类型不匹配），布尔值为false\n在while(cin \u0026raquo; s)语句中，循环的条件部分检查cin流的状态。\n如果流成功读取到一个值，cin\u0026raquo;s返回的流对象cin将被转换为true，循环将继续。\n如果读取失败（例如遇到输入结束符或无法读取到一个值），cin \u0026raquo; s返回的流\n对象cin将被转换为false，循环将停止\n题目 思路：\n1.输入字符串 - string 2.输入带空格的字符串 getline 3.循环处理字符串中的每个字符，解密 如果是bz(BZ)的字母，直接-1，就是解密后的字符 如果是a/A \u0026ndash;\u0026gt; z/Z 其余字符不变\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s; //输入 getline(cin, s); //遍历字符串 int i = 0; for(i = 0; i \u0026lt; s.size(); i++) { if((s[i] \u0026gt;= \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;z\u0026#39;) || (s[i]) \u0026gt;= \u0026#39;B\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;Z\u0026#39;) s[i] -= 1; else if(s[i] == \u0026#39;a\u0026#39;) s[i] = \u0026#39;z\u0026#39;; else if(s[i] == \u0026#39;A\u0026#39;) s[i] = \u0026#39;Z\u0026#39;; } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } reverse 需要包含头文件\u0026lt;algorithm\u0026gt;\nfirst：指向要反转范围的第一个元素的迭代器（也可以是地址）\nlast：指向要反转范围的最后一个元素的下一个位置的迭代器（也可以是地址）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; reverse(s.begin(), s.end()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 也可以逆序整型数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int sz = sizeof(arr) / sizeof(arr[0]); reverse(arr, arr + sz);//可以传地址 for(int e: arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 题目 句子只包含英文小写字母和空格\n思路：\n输入字符串 - 包含空格 getline\n遍历字符串，计算每个字符的按键次数，然后累加在一起\n26个小写英文字母，每个字母都有自己的按键次数 把26个字母的按键次数存储下来 \u0026ndash; 使用数组 当有一个字符来的时候，就将这个字符的按键次数累加上去 数组下标是从0开始的，让英文字母-\u0026lsquo;a\u0026rsquo;得到对应下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int count[26] = {1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4}; int main() { //\t1.输入字符串 - 包含空格 getline int n = 0; string s; getline(cin, s); //\t2.遍历字符串，计算每个字符的按键次数，然后累加在一起 for(char ch: s) { //查看ch这个字符的按键次数 if(ch == \u0026#39; \u0026#39;) n += 1; else n += count[ch-\u0026#39;a\u0026#39;]; } cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 题目 输入：\n1.第一个是字符代表操作，后面两个是数字\n2.输入的两个是数字，表示进行上一次的操作 \u0026ndash; 上一次的操作需要保存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int i = 0; cin \u0026gt;\u0026gt; i; string op;//操作 string last; while(i--) { //输入数据 int n1, n2; int r;//计算结果 string ans; cin \u0026gt;\u0026gt; op; if(op == \u0026#34;a\u0026#34; || op == \u0026#34;b\u0026#34; || op == \u0026#34;c\u0026#34;) { cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2; ans += to_string(n1); if(op == \u0026#34;a\u0026#34;) { //加法运算 r = n1 + n2; ans += \u0026#34;+\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r);\t} else if(op == \u0026#34;b\u0026#34;) { //减法运算\tr = n1 - n2; ans += \u0026#34;-\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); } else { //乘法运算 r = n1 * n2; ans += \u0026#34;*\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); }\tlast = op; } else // 这一行有两个数据，执行上一次的运算 { n1 = stoi(op); cin \u0026gt;\u0026gt; n2; ans += to_string(n1); if(last == \u0026#34;a\u0026#34;) { //加法运算 r = n1 + n2; ans += \u0026#34;+\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r);\t} else if(last == \u0026#34;b\u0026#34;) { //减法运算\tr = n1 - n2; ans += \u0026#34;-\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); } else { //乘法运算 r = n1 * n2; ans += \u0026#34;*\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); } }\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; } return 0; } ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n第九章 结构体和类 1.结构体 结构体是一种自定义的类型，使用这种自定义类型可以描述一些复杂对象\n复杂对象比如：人、书等\n描述⼀本书，书有作者、出版社、定价等信息； 描述⼀个⼈，⼈有名字、性别、年龄、⾝⾼、体重等信息 1.1结构体类型声明和变量定义 声明结构体类型的关键字是struct\n语法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; struct Stu { string name; // 名字 int age; //年龄 int chinese; // 语文成绩 int math; // 数学成绩 int total; // 总成绩 }s4, s5, s6; // s4, s5, s6就是在结构体类型声明的同时，顺便创建的三个结构体变量 //s4, s5, s6是全局变量 struct Stu s7; // 全局变量 int main() { //局部的结构体变量 struct Stu s1; struct Stu s2; Stu s3; // C++中struct 可以省略 Stu arr[6]; // 结构体类型的数组 return 0; } 注意：\n在创建变量的时候，结构体类型中的struct可以省略\n在创建结构体变量的时候，==结构体变量的名字不能和结构体类型的名字相同==\nStu Stu; // 这种写法是错的\n声明的结构体类型是不占用内存空间，只有创建了结构体类型的变量后，才\n向内存申请空间\n变量创建的本质是：在内存申请空间\nint a = 10; // 是向内存申请了4个字节的空间，用来存放整数10\n结构体变量可以是全局变量，也可以是局部变量\n1.2 结构体变量的特点 1.2.1结构体的初始化 结构体的初始化和数组的初始化类似，使用{}\n只不过需要将初始化的内容按照顺序放在{}中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { string name; int chinese; int math; int total; } int main() { //int arr[5] = {1, 2, 3, 4, 5}; struct Stu s1 = {\u0026#34;zhangsan\u0026#34;, 85, 95, 180}; return 0; } 1.2.2结构体整体操作 结构体变量中成员可以是不同类型的。但是一个结构体变量可以看做一个整体，\n是可以进行赋值操作的\n1 2 3 struct Stu s1 = {\u0026#34;zhangsan\u0026#34;, 85, 95, 180}; Stu s2; s2 = s1;//整体赋值，这样s2的内容就会和s1一样 1.2.3结构体成员的访问 语法：结构体变量.成员名\n1 2 3 4 5 6 Stu s1; s1.name = \u0026#34;lisi\u0026#34;; s1.chinese = 100; cin \u0026gt;\u0026gt; s1.math; s1.total = s1.chinese + s1.math; cout \u0026lt;\u0026lt; s1.total \u0026lt;\u0026lt; endl;\t1.2.4结构体嵌套 结构体的成员的类型也可以是结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Score { int chinese; int math; int english; }; struct Stu { string name; Score sc; // 三门成绩 int total; // 总成绩 int avg; // 平均成绩 }; int main() { Stu s1 = {\u0026#34;zhangsan\u0026#34;, {80,90,60}, 0, 0}; s1.total = s1.sc.chinese + s1.sc.math + s1.sc.english; s1.avg = s1.total / 3; cout \u0026lt;\u0026lt; s1.total \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s1.avg \u0026lt;\u0026lt; endl; return 0; } 1.3 结构体成员函数 在C++中，结构体里不仅可以有成员变量，还可以有成员函数\n注意：\nC++的结构体会有一些默认的成员函数（比如：构造函数、析构函数等），是\n编译器默认生成的，自动调用，我们也可以自己显示定义这些函数\n除了默认成员函数，我们也可以自定义一些成员函数\n成员函数可以直接访问成员变量\n成员函数的调用也使用.操作符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; //成员函数 //初始化结构体的成员变量 void Init_stu() { name = \u0026#34;小明\u0026#34;; chinese = 100; math = 100; total = chinese + math; } //打印结构体信息 void print_stu() { cout \u0026lt;\u0026lt; \u0026#34;名字：\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;语文：\u0026#34; \u0026lt;\u0026lt; chinese \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数学：\u0026#34; \u0026lt;\u0026lt; math \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总成绩：\u0026#34; \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } }; int main() { Stu s1; s1.Init_stu(); s1.print_stu(); return 0; } 构造函数\n作用：初始化结构体变量\n构造函数是在结构体变量创建的时候，编译器自动被调用的\n函数名与结构体（类）名相同 没有返回值，也不写void 构造函数可以重载 如果没有显示定义构造函数，系统会自动生成默认的构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; //成员函数 Stu() { name = \u0026#34;翠花\u0026#34;; chinese = 99; math = 100; total = chinese + math; } //打印结构体信息 void print_stu() { cout \u0026lt;\u0026lt; \u0026#34;名字：\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;语文：\u0026#34; \u0026lt;\u0026lt; chinese \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数学：\u0026#34; \u0026lt;\u0026lt; math \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总成绩：\u0026#34; \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } }; int main() { Stu s1; s1.print_stu(); return 0; } 析构函数\n作用：完成结构体变量中资源清理工作\n在结构体变量销毁的时候，被自动调用\n析构函数名是在结构体（类）名前加上~ 无参数无返回值类型 一个类只能有一个析构函数。（析构函数不能重载） 如果没有显示定义析构函数，系统会自动生成默认的析构函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Stu { //成员变量 string name; int chinese; int math; int total; //成员函数 //构造函数 Stu() { cout \u0026lt;\u0026lt; \u0026#34;调用构造函数Stu()\u0026#34; \u0026lt;\u0026lt; endl; name = \u0026#34;翠花\u0026#34;; chinese = 99; math = 100; total = chinese + math; } ~Stu() { cout \u0026lt;\u0026lt; \u0026#34;调用析构函数~Stu()\u0026#34; \u0026lt;\u0026lt; endl; //资源释放的工作 chinese = 0; }\t}; 1.4 运算符的重载 在C++中打印数据，我们通常习惯使用cout来直接打印数据，但是如果\n我们希望打印类类型的对象，直接使用cout来打印会报错\n比如下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; } int main() { struct Stu s = {\u0026#34;张三\u0026#34;, 90, 80, 170}; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 如果我们确实希望打印类类型的对象，那么就需要对输出运算符进行运算符重载。运算符重载是为了让自定义类型能够使用运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; }; //运算符重载 //重载的是输出运算符\u0026lt;\u0026lt;，让\u0026lt;\u0026lt;支持struct Stu类型数据的打印 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const struct Stu\u0026amp; s) { cout \u0026lt;\u0026lt; \u0026#34;名字：\u0026#34; \u0026lt;\u0026lt; s.name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;语文：\u0026#34; \u0026lt;\u0026lt; s.chinese \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数学：\u0026#34; \u0026lt;\u0026lt; s.math \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总分：\u0026#34; \u0026lt;\u0026lt; s.total \u0026lt;\u0026lt; endl; return os; } int main() { struct Stu s = {\u0026#34;张三\u0026#34;, 90, 80, 170}; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 1.5 结构体排序-sort sort函数是C++的STL中的库函数，可以直接用来排序数据\n1.5.1 sort函数介绍 1.5.2排序内置类型数据 对数组进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int arr[] = {4,5,6,9,7,1,2,8,5,4,2}; //数组名就是数组首元素的地址 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素的个数 //arr + sz跳过sz个元素，就是第sz+1个元素的地址 sort(arr, arr + sz);//升序 for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; return 0; } 对字符串中的字符进行排序\n这里是对字符串中的字符顺序来进行排序，是按照字符的ASCII码值进行排序的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;defxxxabccba\u0026#34;; sort(s.begin(), s.end()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 1.5.3自定义排序 sort在默认情况下是按照升序排序，如果我们希望按照降序排序呢？\n如果是结构体类型数据进行排序呢?\n如果第一个参数应该排在第二个参数之前，则返回true，否则返回false\ncom表示可以自定义一个排序方法，有两种方法可以实现：\n创建比较函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //方法1：比较函数 bool compare(int x, int y) { return x \u0026gt; y;//降序 //return x \u0026lt; y;//升序 } int main() { int arr[] = {4,5,6,9,7,1,2,8,5,4,2}; //数组名就是数组首元素的地址 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素的个数 //arr + sz跳过sz个元素，就是第sz+1个元素的地址 sort(arr, arr + sz, compare);//降序 for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; return 0; } 结构体中重载（）运算符-仿函数\n仿函数也叫函数对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; //方法2：仿函数的方式 struct cmp { bool operator()(int x, int y) { return x \u0026gt; y;//降序 } }cmp; int main() { int arr[] = {4,5,6,9,7,1,2,8,5,4,2}; //数组名就是数组首元素的地址 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素的个数 //arr + sz跳过sz个元素，就是第sz+1个元素的地址 sort(arr, arr + sz, cmp);//降序 for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; return 0; } 1.5.4排序结构体数据 两个结构体数据也是不能直接比较大小的，在使用sort函数排序的时候\n也是需要提供自定义的比较方法\n方法1：提供比较函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct S { string name; int age; }; //提供比较函数：按照名字升序排 bool cmp_s_by_name(struct S s1, struct S s2) { return s1.name \u0026lt; s2.name; } //提供比较函数：按照年龄降序排 bool cmp_s_by_age(struct S s1, struct S s2) { return s1.age \u0026gt; s2.age; } int main() { struct S arr[] = {{\u0026#34;zhangsan\u0026#34;, 20}, {\u0026#34;lisi\u0026#34;, 25}, {\u0026#34;wangwu\u0026#34;, 18}}; int sz = sizeof(arr) / sizeof(arr[0]); sort(arr, arr+sz, cmp_s_by_age); for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt;arr[i].name \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\t年龄：\u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; endl; } return 0; } 方法2：仿函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct S { string name; int age; }; //按照年龄升序 struct Cmp { bool operator()(struct S s1, struct S s2) { return s1.age \u0026lt; s2.age;\t}\t}cmp; int main() { struct S arr[] = {{\u0026#34;zhangsan\u0026#34;, 20}, {\u0026#34;lisi\u0026#34;, 25}, {\u0026#34;wangwu\u0026#34;, 18}}; int sz = sizeof(arr) / sizeof(arr[0]); sort(arr, arr+sz, cmp); for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt;arr[i].name \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\t年龄：\u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; endl; } return 0; } 2.类 C++中为了更好的实现面向对象，更喜欢使用class（类）来替换struct（结构体）\n2.1 类的定义 class是用来定义类类型的关键字\n1 2 3 4 5 6 class tag { public: 成员变量列表; 成员函数列表; };//注意后面要加分号 public 是类成员权限访问限定符，标志类中的成员可以公开访问及调用\n结构体中的成员变量和成员函数默认就是公开的\nclass中的成员变量和成员函数默认是私有的(private)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Stu { public: //成员变量 string name; int chinese; int math; int total; //成员函数 - 自定义 void init_stu() { name = \u0026#34;小明\u0026#34;; chinese = 90; math = 98; total = chinese + math; } //类也是有默认成员函数-构造函数、析构函数... }; 2.2 类的使用 2.2.1 创建对象 1 2 3 4 5 6 7 int main() { Stu s1; Stu s2; return 0; } 2.2.2 调用类对象成员 1 2 3 4 5 6 7 8 int main() { Stu s1; s1.init_stu(); s1.name = \u0026#34;明明\u0026#34;; return 0; } 2.3 访问权限控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Stu { private: //成员变量 string name; int chinese; int math; int total; public: //成员函数 - 自定义 void init_stu() { name = \u0026#34;小明\u0026#34;; chinese = 90; math = 98; total = chinese + math; } //类也是有默认成员函数-构造函数、析构函数... }; int main() { Stu s1; s1.init_stu();//ok s1.name = \u0026#34;明明\u0026#34;;//err return 0; } 2.4 结构体和类的区别 C++兼容C语言，所以C++中struct既可以当成结构体使用，还可以用来\n定义类。\nstruct和class的区别是 struct定义的类默认访问权限是public\nclass定义的类默认访问权限是private\n3.练习 题目 方法1：打擂台\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //方法1：打擂台 struct S { int score; string name; }; int main() { int N; cin \u0026gt;\u0026gt; N; //1.输入一个学生的信息，假设这个学生的成绩就是最大的 struct S max; // 假设max中存放的是成绩最高学生的信息 cin \u0026gt;\u0026gt; max.score \u0026gt;\u0026gt; max.name; N--; //2.依次输入N-1个学生的信息，依次和假设的最大数据进行比较 //\t如果比假设的这个学生大，就更新最大的信息 struct S s;//存放临时的信息 while(N--) { cin \u0026gt;\u0026gt; s.score \u0026gt;\u0026gt; s.name; if(s.score \u0026gt; max.score) max = s; } //3.找出最大值了，输出 cout \u0026lt;\u0026lt; max.name \u0026lt;\u0026lt; endl; return 0; } 方法2\n1.输入N个学生的信息，并存储 2.排序-sort-排序为降序 3.第一个数就是最大的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; //方法2： //1.输入N个学生的信息，并存储 //2.排序-sort-排序为降序 //3.第一个数就是最大的 const int N = 110; struct S { int score; string name; }arr[N]; //比较函数 bool cmp(struct S s1, struct S s2) { return s1.score \u0026gt; s2.score;//降序\t} int main() { int n; cin \u0026gt;\u0026gt; n; //输入信息并存储 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; arr[i].score \u0026gt;\u0026gt;arr[i].name;\t} //排序 - 降序 sort(arr, arr+n, cmp); cout \u0026lt;\u0026lt; arr[0].name \u0026lt;\u0026lt; endl; return 0; } 题目 注意排序函数sort的自定义排序\nbool compare(int x, int y) { return x \u0026gt; y;//降序 }\n可以这样理解：\nx是要排在前面的\nx\u0026gt;y，x大于y，x排前面，也就是大的排前面，即降序\nx\u0026lt;y，x小于y，x排前面，也就是小的排前面，即升序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 310; struct Stu { int stu_no;//学号 int chinese;//语文 int math;//数学 int english;//英语 int total;//总分\t}arr[N]; struct Cmp { //总分不同，总分高的在前 //总分相同，语文成绩不同，语文成绩高的在前 //总分相同，语文成绩相同，学号小的在前 bool operator()(const Stu\u0026amp; s1, const Stu\u0026amp; s2) { if(s1.total != s2.total) return s1.total \u0026gt; s2.total; else if(s1.chinese != s2.chinese) return s1.chinese \u0026gt; s2.chinese; else return s1.stu_no \u0026lt; s2.stu_no; } }cmp; int main() { //思路： //1.输入学生人数n并用结构体存储 //2.输入n名学生的三科成绩，并计算总分 //3.按照总分降序排序 //4.输出前五名的学号和总分 int n; cin \u0026gt;\u0026gt; n; //输入n名学生的三科成绩，并计算总分 for(int i = 1; i \u0026lt;= n; i++) { arr[i-1].stu_no = i;//存储学号 cin \u0026gt;\u0026gt; arr[i-1].chinese \u0026gt;\u0026gt; arr[i-1].math \u0026gt;\u0026gt; arr[i-1].english; //计算总成绩 arr[i-1].total = arr[i-1].chinese + arr[i-1].math + arr[i-1].english; } //排序 - 降序 sort(arr, arr+n, cmp); //输出 for(int i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; arr[i].stu_no \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; arr[i].total \u0026lt;\u0026lt; endl; } return 0; } 题目\n分析：\n描述学生的结构体\nstruct S\n{\n​\tstring name;\n​\tint y;//年\n​\tint m;//月\n​\tint d;//日\n​\tint id;//顺序\n}\n输入n\n输入n个学生的信息-数组存储\n循环n次，每次输入一个学生的信息，加上表示顺序的id\n自定义排序\na. 日期比较\n年龄从大到小 == 日期从小到大\nb.输入顺序比较，晚输入的，编号大，排到前面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 110; struct Stu { string name; int y; int m; int d; int id;//顺序，如果年月日都相同，那么id大的先输出 }arr[N]; struct Cmp { bool operator()(Stu s1, Stu s2) { if(s1.y != s2.y) { //年小就大 return s1.y \u0026lt; s2.y; } else if(s1.y == s2.y \u0026amp;\u0026amp; s1.m != s2.m) { //年相同，月小就大 return s1.m \u0026lt; s2.m; } else if(s1.y == s2.y \u0026amp;\u0026amp; s1.m == s2.m \u0026amp;\u0026amp; s1.d != s2.d) { //年月相同，天小就大 return s1.d \u0026lt; s2.d; } else { //生日相同，输入靠后的同学先输出 return s1.id \u0026gt; s2.id; } } }cmp; int main() { //1.输入n //2.输入n名同学的姓名s、出生年y、月m、日d //3.按照年龄降序排序，如果有两个同学生日相同， //\t输入靠后的同学先输出 int n; cin \u0026gt;\u0026gt; n; //输入n名学生的姓名和生日 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; arr[i].name \u0026gt;\u0026gt; arr[i].y \u0026gt;\u0026gt; arr[i].m \u0026gt;\u0026gt; arr[i].d; arr[i].id = i; } //按照年龄降序排序，如果有两个同学生日相同， //输入靠后的同学先输出 sort(arr, arr+n, cmp); //输出 for(int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; arr[i].name \u0026lt;\u0026lt; endl; } return 0; } ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n【从零开始学C++】 第一章 C++入门 0.C++历史 C++是在C语言的基础上进行扩展的，C++完全兼容C\n1. C++入门 1.1 打印hello world C++的源文件的后缀名为.cpp 是c plus plus 的缩写，意思是C++是C的进阶\n首先，我们先写一个C++程序，在屏幕 上打印：hello world\n1 2 3 4 5 6 7 8 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 在DevC++中\nF9 编译，F10运行，F11编译运行\n1.2 main 函数 main函数是程序的入口，也就是不管你前面写了多少行代码，运行时都是从main函数开始执行\nmain函数也叫主函数\nint 表示main函数最后会返回一个int类型的值（int也就是整型），对应{ } 中的 return 0 ，也就是\n我们的main函数如果正常运行，最终会返回0\nmain函数的固定模版\n1 2 3 4 5 int main() { return 0; } 注意：\nmain函数是程序的入口\nmain函数在一个项目中有且只能有一个，也就是程序的入口只能有一个\n一个项目中允许有多个源文件(.cpp)，但是如果你在多个源文件中写了main函数，那么\n程序到底执行哪一个呢？这样就会有问题\n1.3 字符串 在C/C++中，我们用单引号括起来一个字符，表示字符字面值，双引号括起来多个字符，表示字符串\n1 2 3 4 5 6 7 8 9 //字符 \u0026#39;a\u0026#39;; \u0026#39;1\u0026#39;; \u0026#39;x\u0026#39;; //字符串 \u0026#34;abc\u0026#34;; \u0026#34;hello world\u0026#34;; \u0026#34;\u0026#34;;//空字符串 \u0026ldquo;hello world\u0026rdquo; 被双引号包裹，所以是字符串\n1.4 头文件 在我们写的第一个C++程序中，第一行是下面这样的\n1 #include\u0026lt;iostream\u0026gt; #include\u0026lt;\u0026gt;\n#include\u0026lt;\u0026gt;表示包含，#include\u0026lt;iostream\u0026gt;也就是说包含一个文件，这个文件叫iostream\n我们把#include\u0026lt;\u0026gt;这种形式的叫头文件\niostream\niostream是intput output stream的缩写，是输入输出流的头文件\n程序中只要涉及输入输出操作的都要包含这个头文件\n头文件\n一个头文件可以理解为一个工具箱，工具箱中包含了很多的工具，想要使用这些工具\n就得包含头文件\nC++手册\n注意\nC语言中的头文件扩展名是.h，C++自己的头文件没有扩展名，C++对老式C的头文件\n保留了扩展名.h\n有些C的头文件被转换成C++头文件，这些文件名被重命名，去掉了.h扩展名，并在\n文件名的前面加上了前缀c 表示来自C语言\n例如C语言中和数学有关的头文件名字是math.h，在C++中就是cmath\n但是有时头文件的C语言版本和C++版本相同，而==有时候新版本做了一些修改==\n头⽂件类型 约定 实例 说明 C++旧式⻛格 以.h结尾 \u0026lt;iostream.h\u0026gt; C++程序可以使⽤，⼀些新的IDE可能不再⽀持 C旧式⻛格 以.h结尾 \u0026lt;math.h\u0026gt; C、C++程序可以使⽤ C++新式⻛格 没有扩展名 C++程序可以使⽤，使⽤namespace std 转换后的C 加上前缀，没有扩展名 C++程序可以使⽤，可能包含不是C的特性 1.5cin和cout初识 cout是标准输出流对象，针对的是控制台，也就是屏幕，它要把一些信息打印到屏幕上\ncin是标准输入流对象，\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int num;//num是一块空间 ，可以存放一个整数 cin \u0026gt;\u0026gt; num;//输入操作，输入一个整数 存放到num中 cout \u0026lt;\u0026lt; num;//输出操作，将num里的值打印到屏幕上 return 0; } cin和cout是全局的流对象，cin负责输入数据，cout负责输出数据 endl是C++中一个特殊的操作符，效果是换行和刷新缓冲区，使用时必须包含在iostream头文件 \u0026lt;\u0026lt;是流插入运算符和cout配合使用。\u0026gt;\u0026gt;是流提取运算符，和cin配合使用 C++的输入输出可以自动识别变量类型，而C语言的printf/scanf需要手动输出格式 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { float f; cin \u0026gt;\u0026gt; f;//自动识别f的类型，识别为浮点数 cout \u0026lt;\u0026lt; f; return 0; } 细节\ncin 是⽀持连续读入几个数值的 cout 也是⽀连续输出几个数值的 1.6 命名空间 在我们写的第一个C++程序中有这样一段代码using namespace std;，意思是使用名字空间std\n其中namespace是命名空间的关键字，std就是空间的名字\n那么什么是名字空间呢？为什么要有名字空间呢？\n在C++程序中，如果我们是几个人一起开发，那么可能一个人在程序中定义了一个变量，另一个\n也想用这个变量名，那么就会造成命名冲突。如果我们使用命名空间，让每个人都在自己的命名空间\n中写代码，相当于做了隔离，需要使用的时候，我们就指定命名空间。\n所以，命名空间就是解决命名冲突的问题\nstd\n是C++标准库的名字空间名，C++将标准库的定义实现都放到这个命名空间中，当我们需要使用\n标准库中的内容时，就需要加上： using namespace std\n1.7 注意事项 编写C++代码的语法细节\n注意main函数的写法，大括号的匹配，中英文标点符号的使用，包含头文件 OJ - online judge 在线判题\n算法竞赛 \u0026ndash; OJ\nOI型 \u0026ndash; 从0开始写代码，包括main函数，编写所有代码，有输入输出 核心代码模式 - 编写核心代码 OJ题⽬输出的结果有严格的检查，代码输出的结果必须和题⽬要求的统⼀才是可以的。\n2.数据类型 数据类型可以用来描述生活中的各种数据。\n类型，就是相似数据所拥有的共同特征。编译器只有知道了数据类型，才知道怎么操作数据\n简单的数据类型分为：字符型，整型，浮点型，布尔型\n2.1 字符型 C/C++中，我们通常把字符用单引号引起来，例如 'a' ，1，@，我们给他们抽象出\n一种数据类型，就是字符型 char\n1 char ch = \u0026#39;w\u0026#39;; ASCII\n我们知道，在计算机中所有的数据都是以二进制的形式存储的，那么字符在内存中是\n怎样以二进制方式存储的呢？我们把每个字符编一个二进制序列，这个就叫编码。\n美国国家标准学会（ANSI）出台了一个标准ASCII编码\n字符A~Z的ASCII码值从65~90 字符a~Z的ASCII码值从97~122 大小写字符的ASCII码相差32 数字字符0~9的ASCII码值为10 换行字符\\n的ASCII码值为48~57 注意：ASCII码值从0~31 这32个字符是不可打印字符，无法在屏幕上观察\n2.2 整型 short int 短整型\nint 整型\nlong int 长整型\nlong long int 更长的整型\n1 2 3 4 5 6 7 short s = -10; short int s2 = 10; int n1 = 100; long l = 101; long int l2 = 102; long long int ll2 = 1001; 2.3 浮点型 float 单精度浮点型\ndouble 双精度浮点型\nlong double 更长的双精度浮点型\n细节：\n编译器默认会认为小数是double类型的，如果想定义浮点类型的小数，需要在后面加f 1 2 3 float f = 5.5f;// 编译器默认认为是double类型 double d = 3.14; long double ld = 5.5; C/C++中小数的书写形式\n1 2 3 4 5 3.14; // 编译器会默认认为是doble类型 3.14f; //编译器会认为是float类型 1e5; //科学计数法的形式，1*10^5 1e5+10; //1*10^5+10 1.23e5+10; //1.23*10^5+10 2.4 布尔型 布尔类型bool，这种类型只能用来表示true(真)或false(假)。\n在C/C++中，0表示假，非0表示真\n2.5 signed与unsigned signed和unsigned是用来修饰整型和字符的\nsigned修饰一个类型后，就可以表示正负数，比如：温度\nunsigned修饰一个类型后，就只能表示0和正数，比如：年龄\n变量声明为unsigned的后，同样长度的内存能够表示的最大整数值，增大了一倍\n比如16 位的signed short int 的取值范围是-32768~32767，最大是32767；\n而unsigned short int的取值范围是0~65535\n整型默认是有符号的，如果想要表示无符号的整型，需要用unsigned修饰 1 2 int a;// 等价于有符号的，即signed int a; unsigned int b; // 无符号的 char是signed cahr 还是 ungned char 取决于编译器\n大部分编译器上char是有符号的char\n2.6 数据类型的长度 每一种数据类型都有自己的长度，使用不同的数据类型，能够创建出长度不同的变量\n2.6.1 sizeof操作数 sizeof是一个关键字，也是操作符，专门用来计算特定数据类型长度的，单位字节 sizeof操作符的操作数可以是类型，也可以是变量名或表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 100; //sizeof 计算结果的单位是字节 cout \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; // 4 return 0; } sizeof计算的结果是==无符号整型size_t类型==的，该类型可能是unsigned int、unsigned long\n、unsigned long long，具体取决于编译器\nsizeof后面跟的如果是==变量或表达式==时，可以不跟小括号\n1 2 3 int a = 100; cout \u0026lt;\u0026lt; sizeof a \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof a+4.0 \u0026lt;\u0026lt; endl; // 8 2.6.2 各种数据类型的长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(bool) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(long) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(long long) \u0026lt;\u0026lt; endl; // 8 cout \u0026lt;\u0026lt; sizeof(float) \u0026lt;\u0026lt; endl; //4 cout \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; endl; //8 cout \u0026lt;\u0026lt; sizeof(long double) \u0026lt;\u0026lt; endl; // 16 return 0; } C/C++标准规定：sizeof(long) \u0026gt;= sizeof(int)\n2.6.3 各种类型的取值长度 类型 取值范围 速记最⼩值 速记最⼤值 ==char== -128~127 CHAR_MIN- 27 CHAR_MAX 27 - 1 unsigned char 0~255 0 UCHAR_MAX 28 -1 ==short== -32878 ~ 32767 SHRT_MIN - 2^15 SHRT_MAX2^15 -1 unsigned short 0 ~ 65535 0 USHRT_MAX2^16-1 ==int== -2147483648 ~2147483647 INT_MIN-2^31 INT_MAX2^31-1 unsigned int 0 ~ 4294967295 0 UINT_MAX2^32-1 long -2147483648 ~ 2147483647 LONG_MIN-2^31 INT_MAX2^31-1 unsigned long 0 ~ 4294967295 0 ULONG_MAX2^32-1 ==long long== -9223372036854775808~ 9223372036854775807 LLONG_MIN- 2^63 LLONG_MAX2^63-1 ==unsigned long long== 0~18446744073709551615 0 ULLONG_MAX2^64-1 为了代码的可移植性和方便记忆，需要知道某种整数类型的极限值\nlimits.h文件中说明了整型类型的取值范围。（C++中头文件为\u0026lt;climits\u0026gt;）\nfloat.h这个头文件中说明了浮点型类型的取值范围。（C++中头文件名为\u0026lt;cfloat\u0026gt;）\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;climits\u0026gt; int main() { cout \u0026lt;\u0026lt; CHAR_MIN \u0026lt;\u0026lt; endl; //-128 cout \u0026lt;\u0026lt; CHAR_MAX \u0026lt;\u0026lt; endl; //127 return 0; } 2.6.4 typedef 有些类型的名字比较复杂，可以用typedef给类型起别名\n1 typedef 旧类型名 新类型名 例如我们可以给unsigned long long起个别名为ull\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; typedef unsigned long long ull; int main() { unsigned long long num1; ull num2; return 0; } 对于复杂的类型都是可以重命名的\n对于复杂的指针类型 对于复杂的自定义类型 一道练习 https://www.luogu.com.cn/problem/B2018\n注意:\n题目中说的是”输入一个整数，即字符的ASCII码值“，\n如果我们使用cin的话就只能用一个int类型的变量来接收输入的值，\n因为对于cin来说，它会根据变量的类型来读取数据。\n如果用char类型的变量来接收输入的值，那么cin就会认为它只需要读一个字符。\n例如我们输入的是97，那么cin就会只读9\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { //输入 int num; // 使用int来接收 cin \u0026gt;\u0026gt; num; //输出 char ch = num; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } 3.变量和常量 3.1 变量的创建 变量就是值是可以变化的，常量就是值是固定的\n变量创建的语法：数据类型 变量名\n1 2 3 int age; double weight; unsigned int height; 变量命名的规则\n变量只能由数字、字母、下划线组成。 变量名不能以纯数字开头，也不能包含特殊字符，如空格、连字符等 变量名不能直接用语言的关键字，例如 int char 这样创建变量是非法的 变量名严格区分大小写，例如myVariable和myvariable被视为两个不同的变量 变量名应该具有实际意义，并且简短明了 3.2 变量的初始化 在创建变量的同时给变量赋值，就叫变量的初始化\n3.3 变量的分类 全局变量：在大括号外面定义的变量\n局部变量：在大括号内部定义的变量\n==当局部变量和全局变量同名且都可以使用的时候，局部变量会优先被使用==\n但是如果就是想使用全局的变量，可以在变量前加上::\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int m = 100; // 全局变量 int main() { int m = 1; // 局部变量 { int a = 10; // 局部变量 cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; // 1 ，局部优先 cout \u0026lt;\u0026lt; ::m \u0026lt;\u0026lt; endl; // 100 } cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; ::m \u0026lt;\u0026lt; endl; // 100 return 0; } 在定义的时候如果没有指定初始值，\n那么，全局变量的值通常会被初始化为0，局部变量的值是随机的\n建议：局部变量初始化\n在竞赛中：\n能使用全局变量，一般直接使用全局变量，因为\n变量不需要初始化，因为默认会初始化为0，这样写会比较快 很多时候，会避免传参，因为全局变量到处都可以使用 但是在企业里软件开发的工程中一般建议：能使用局部变量的尽量少使用全局变量。\n因为企业级开发，代码量比较大，全局变量在任意地方都可以使用，这样就不可控了\n3.4常量 字面常量 #define定义的常量 语法：#define 常量名 内容\n注意后面没有分号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; #define M 22 #define CH \u0026#39;X\u0026#39; #define PI 3.14159 int main() { //M = 33; // error int m = M; cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; // 22 cout \u0026lt;\u0026lt; M \u0026lt;\u0026lt; endl; // 22 cout \u0026lt;\u0026lt; CH \u0026lt;\u0026lt; endl; // x cout \u0026lt;\u0026lt; PI \u0026lt;\u0026lt; endl; // 3.14159 return 0; } 常量的值不能被修改\n细节：\n使用#define定义常量的时候是不关注类型的，只关注常量的名字叫啥，常量的值是啥\n编译器在处理常量的时候就是直接替换，在出现常量名字的地方，统统替换成常量的内容\n所以，一定要注意#define定义的常量中能否有分号\n​\nconst定义的常量 使用const来定义的常量，这种常量会有具体的类型，比#define定义常量更严谨\n语法：const 类型 常量名 = 常量值;\n注意：\n==常量在创建的时候最好给它一个值==，因为后面再想给它值就给不进去了\n因为常量不能被修改。\nconst定义常量后面有分号\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { const int n = 10; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; n = 20; // error cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 习惯上，常量的名字一般会全是大写\n使用const常量的好处\n增加了程序的可读性。PI比3.14159更加容易理解和书写、使用\n增加了程序的可维护性。如果改变常量的值，只要在定义的部分修改，使用的地方也就\n随之改变了\n常量是不能被修改的\n4.算术运算 4.1算术操作符 操作符也被叫做运算符\n算术操作符有：+ - * / %\n这些操作符都是双目操作符，也就是有两个操作数\n7 + 2\n操作数为：7和2\n操作符为：+\n需要注意的除号/和取余%\n1 2 3 int c = 7 / 2; // 打印结果为3 而不是3...1 double d = 7 / 2; // 打印结果为3 而不是3...1 cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 取余(取模)操作符，得到的是整除后的余数\n1 2 int e = 7 % 2; cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl;// 1 注意事项和细节：\n/除法操作符，除数不能为0，如果除数为0，程序会崩溃 %取模操作符计算的结果是两个操作数进行除法运算后的余数 ==取模操作符的操作数只能是整型，不能是浮点型==，否则编译器会报错 1 2 3 float f = 0.4f; int n = 2; int d = f % n; //error 4.2 浮点数的除法 如果希望得到浮点数结果，那么除号的两端的操作数至少有一个是浮点数\n1 2 3 4 a = 6; float f1 = a / 4; // 1 float f2 = 6.0 / 4; // 1.5 float f3 = a * 1.0 / 4; // 1.5 4.3 负数取模 取模操作符%计算的结果是两个操作数进行除法运算后的余数。\n负数取模的结果由第一个运算数的正负号决定\n如果第一个运算数是正数，那么取模的结果就是正数 如果第一个运算数是负数，那么取模的结果就是负数 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; 11 % -5 \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; -11 % -5 \u0026lt;\u0026lt; endl; // -1\tcout \u0026lt;\u0026lt; -11 % 5 \u0026lt;\u0026lt; endl; // -1 return 0; } 4.4 数值溢出 根据我们前面学到的，我们了解到每种数据类型都有对应的取值范围，而我们在实际运算\n过程中可能会超出该数据类型所能表示的范围。\n数值溢出就是数值超过了当前数据类型所能表示的范围，部分数据丢失，导致最终存进去\n的不是我们想要的数据\n以char类型为例，char类型的取值范围是-128~127 ，当值为127的字符+1后，字符的取值\n就是-128了\n4.5 练习 1. 时间转换 前提知识：\n60秒 \u0026ndash; 1分钟 60分钟 \u0026ndash; 1小时 3661 / 60 == 61分钟 余 1秒\n61分钟 / 60 == 1小时 余 1分钟\n小时：我们拿到秒数，除以60，看能凑多少分钟；因为每60分钟可以凑一个小时\n​\t所以，我们再将分钟除以60看能凑多少个小时\n分钟：同样，因为每60秒可以凑一分钟，所以我们先将总的秒数除以60，看能凑多少分钟；\n​\t因为60分钟可以凑一小时，所以再除以60后得到的余数就是凑不够一小时的分钟\n秒：因为60秒能凑一分钟，所以总的秒数除以60，得到的整数就是能凑够的分钟\n​\t得到的余数就是没办法凑够一分钟的秒数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int secondes; cin \u0026gt;\u0026gt; secondes; int s = secondes % 60 ; int m = secondes / 60 % 60; int h = secondes / 60 / 60; cout \u0026lt;\u0026lt; h \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; endl; return 0; } 2. 小鱼的游泳时间 思路：\n​\t使用借位的方法算比较麻烦，我们可以将小鱼开始游泳的时间和结束游泳的时间都转换\n成分钟，然后结束游泳的分钟减去开始游泳的分钟，得到的结果/60得到小时，%60得到分钟\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int a, b, c, d; int main() { //输入 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; //计算 //1.a时b分到 0:0的差值单位是分钟 int t1 = a * 60 + b; int t2 = c * 60 + d; int t = t2 - t1; int h = t / 60; // 小时 int m = t % 60; // 分钟 //输出 cout \u0026lt;\u0026lt; h \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 5. 赋值操作符 5.1 连续赋值 初始化和赋值\n初始化：变量在定义的同时给它一个值，这叫变量的初始化。 赋值：使用赋值操作符= ，将=右边的值赋给=右边的变量 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; // 初始化 a = 100; // 赋值 return 0; } 连续赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 3; int b = 0; int c = 0; c = b = a + 2; // 先将 a+2 的结果赋给 b，然后将b的结果赋给a return 0; } 5.2 复合赋值符 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; a += 3;\t// 等价于 a = a + 3; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 除此外，还有-=，*=，/=，%=等\n复合赋值符 样例 ⼀般写法 += a += 10 a = a + 10 -= a -= 10 a = a - 10 *= a *= 10 a = a * 10 /= a /= 10 a = a / 10 %= a %= 10 a = a % 10 \u0026raquo;= a \u0026raquo;= 1 详⻅《第 7 章 操作符》 \u0026laquo;= a \u0026laquo;= 1 \u0026amp;= a \u0026amp;= 10 |= a |= 10 ^= a ^= 10 5.3 练习 6. 类型转换 不同类型的数据进行混合计算的时候，或者赋值时等号两边的类型不统⼀的时候，\n都会发生类型转换 ，这时就需要根据类型的转换规则转换成合适的类型。\n6.1混合运算时的类型 整数，浮点数，字符可以混合运算，在这种情况下首先要将不一致的数据类型进行转换\n类型统一后才能进行计算\n整型提升：表达式中的char和short类型一定会先转换成int类型，然后参与运算\n算术转换：表达式中出现下面的任意两种类型的值进行计算的时候。要先将位于下面\n的类型转换成位于上面的类型\n1 2 3 4 5 6 7 long double double float unsigned long int long int unsigned int int 下面的转换成上面的类型\n6.3赋值时类型转换 当赋值操作符两端的数据类型不一致的时候，就需要类型转换，这种转换是隐式自动发生的\n规则如下：\nfloat和double赋值给 int 直接截断小数部分，保留整数部分 较小的类型转换成较大的类型，直接转换，值不变 较大类型转换成较小类型，一般会发生截断，按照较小类型的长度，保留低位数据给较小的类型。一般编译器会报警 6.4 强制类型转换 根据需要，将某一数据类型转换为指定的数据类型。\n强制类型转换是临时转换，不会影响变量本身\n语法：(类型)表达式\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 0; //int \u0026lt;--- double a = (int)3.14; //将double类型的3.14强制类型转换成int类型 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 3 return 0; } 6.5练习 1. 浮点数向零舍入 题目中说输入一个双精度浮点数，也就是我们需要用一个double类型的变量来接收。\n向零舍入其实就是强制类型转换。\n**正数向下舍入：**12.3 强制类型转换成整数时，舍去小数部分，结果为 12 ，和12.3相比是变小了 负数向上舍入：-2.7 强制类型转换成整数时，舍去小数部分，结果为 -2，和-2.7相比是变大了 注意：==题目中说x的取值范围在-10^-15^ 到 -10^15^，不在整数的范围内==，因此我们需要把浮点数强转成\n比int类型大的类型（比如long long)\n7. 单目操作符 7.1 ++和\u0026ndash; ++和\u0026ndash;分为：\n前置++，前置\u0026ndash; 后置++，后置\u0026ndash; 前置 ++ 或者 后置 ++ ，都是让操作数⾃增1的\n前置 \u0026ndash; 或者 后置 \u0026ndash; ，都是让操作数⾃减1的\n对于前置的++，都是先使用，再自增1；对于前置的\u0026ndash;，都是先使用，再自减1\n对于后置的++，都是先自增1，再使用；对于后置的\u0026ndash;，都是先自减1，再使用\n7.2正号和负号 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = -10; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // -10 int b = -a; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; // 10 return 0; } 第二章 C/C++的输入与输出 1. getchar和putchar getchar()和putchar()是C语言里面的库函数，由于C++兼容C，所以在C++中只要正确包含头文件\n就可以正常使用这两个函数\n1.1getchar() 1 int getchar ( void ); getchar()函数返回用户从键盘输入的一个字符，使用时不需要传参\n需要包含头文件cstdio\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int ch = getchar(); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; // 以整型的形式打印 cout \u0026lt;\u0026lt; (char)ch \u0026lt;\u0026lt; endl; // 以字符的形式打印 return 0; } ==getchar()总是返回当前读取的第一个字符，无论是否为空格。==\n如果读取失败，会返回常量EOF，EOF的值通常是-1，所以返回值的类型要设为int而不是char\n**注意：**我们输入一个字符后回车，其实回车也是一个字符\\n，也就是当我们再次读取字符\n​\t时，会读取 \\n\n如何让 getchar() 函数读取失败返回-1呢？在不输入任何字符之前，按ctrl+z\n1.2 putchar() 1 int putchar ( int character ); putchar() 函数将它的参数字符输出到屏幕，它的原型头文件\u0026lt;cstdio\u0026gt;\n操作成功时，返回输出的字符，否则返回常量EOF\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { int ch = getchar(); putchar(ch); return 0; } getchar和putchar的使用场景：\n当涉及到大量数据的读写时，我们可以封装这两个函数帮助我们快速读写\n2.scanf 和printf 2.1 printf() 占位符 格式输出 可以限定最小宽度\n默认是右对齐（%5d），前面加上负号变为左对齐（%-5d）\n整数限定宽度 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { printf(\u0026#34;%5d\\n\u0026#34;, 123); // %5d 至少打印5位 printf(\u0026#34;%5d\\n\u0026#34;, 44); return 0; } 小数宽度控制\n%f在打印的时候，默认小数点后会打印6位\n1 2 printf(\u0026#34;%f\\n\u0026#34;, 123.45); // 123.450000 printf(\u0026#34;%12f\\n\u0026#34;, 123.45); 限定小数点后面的位数\n%.2f表示小数点后只打印2位\n1 2 3 printf(\u0026#34;%.2f\\n\u0026#34;, 123.45); // 123.45 printf(\u0026#34;%6.2f\\n\u0026#34;, 0.5); // 总宽度至少6位（小数点也算一位），小数点后打印两位 printf(\u0026#34;%*.*f\\n\u0026#34;, 6, 2, 0.5);//等价于%6.2f，但是更灵活 2.2 scanf() 2.2.1基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int i = 0; //输入 scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); // \u0026amp; --- 取地址操作符 printf(\u0026#34;i = %d\\n\u0026#34;, i); return 0; } 特别注意，scanf函数的占位符后⾯⼀般不会加 \\n ， \\n 是换⾏，⼀般在输出的时候才使⽤\n输入时以逗号隔开\n1 2 3 int a, b, c, d; scanf(\u0026#34;%d,%d,%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d %d %d %d\\n\u0026#34;, a, b, c, d); 输入时，以空格隔开\n1 2 scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d %d %d %d\\n\u0026#34;, a, b, c, d); scanf() 处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。\n小数有时候在内存中无法精确保存\n2.2.2 占位符 %[]只能匹配数字字符\n1 2 3 char ch = 0; scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); // 输入空格 printf(\u0026#34;---%c---\\n\u0026#34;, ch); // --- --- 如何强制跳过%c前面的空格呢？在%c前加空格\n1 2 3 char ch = 0; scanf(\u0026#34; %c\u0026#34;, \u0026amp;ch); printf(\u0026#34;%c\\n\u0026#34;, ch); 2.2.3 scanf返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a = 0, b = 0; while(scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b) == 2) { printf(\u0026#34;a = %d, b = %d\\n\u0026#34;, a, b); } return 0; } 练习 1 2 3 4 5 6 7 8 #include\u0026lt;cstdio\u0026gt; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%.3lf%%\\n\u0026#34;, b * 100.0 / a); return 0; } 3. cin和cout 3.1基本介绍 cin是C++提供的标准输入流对象，一般针对键盘，读取键盘上输入的字符流\n一般和\u0026gt;\u0026gt;（流提取运算符）配合使用\ncout是C++提供的标准输出流对象，一般针对的控制台的窗口，将数据以字符流的形式输出到控制台窗口显示。一般和\u0026lt;\u0026lt;（流插入运算符）配合使用\n3.2连续输入输出 使用 cout 进行变量的输出，实质上是将变量插入到 cout 对象里，并==以 cout 对象作为返回值返回==。因此我们还可以用 \u0026laquo; 在后面连续输出多个内容\n3.3（选学）cin和cout控制输出格式 控制整数的输出\nsetw()括号里填字符的最小宽度\nsetfill()括号里填当宽度不够的时候以什么字符来填充\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;iomanip\u0026gt; int main() { int a = 123; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//宽度5个字符 cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//宽度5个字符 return 0; } 控制小数的格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;iomanip\u0026gt; int main() { double pi = 31.4159265358; cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; scientific \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; return 0; } 左右对齐\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;iomanip\u0026gt; int main() { int a = 123; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 默认是右对齐 cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; left \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 题目 题目1\n输入输出的都是字符流，可以把输入的123.4看做由字符1、字符2、字符3、字符.、字符4组成\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a,b,c,d,e; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; d \u0026lt;\u0026lt; c \u0026lt;\u0026lt; b \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 写法2\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; int main() { char a,b,c,d; scanf(\u0026#34;%c%c%c.%c\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%c.%c%c%c\\n\u0026#34;, d, c, b, a); return 0; } 题目2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { //输入 double a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt;c; //计算 double p = (a + b + c) / 2.0; double area = sqrt(p * (p - a) * (p - b) * (p - c)); //输出 cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(1) \u0026lt;\u0026lt; area \u0026lt;\u0026lt; endl; return 0; } 4、string 1.string的概念 2.string的操作 string的创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 空字符串 string s2 = \u0026#34;abc\u0026#34;; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; string s3(\u0026#34;hello world\u0026#34;); string s4 = s3; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; return 0; } C++中的string创建的字符串对象可以直接复制，而char类型的数组所表示的字符串不行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { char arr1[] = \u0026#34;hello world\u0026#34;; char arr2[] = \u0026#34;hello\u0026#34;; arr1 = arr2; // error 数组名是数组首元素的地址 ，地址是一个常量值 string s1(\u0026#34;hello world\u0026#34;); string s2 = \u0026#34;hello\u0026#34;; s1 = s2; // ok return 0; } string对象的输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; //输入 cin \u0026gt;\u0026gt; s1; //输出 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 注意：cin读取数据的时候，遇到空格就不再读取了\n第三章 条件判断与循环 1. if-else 题目1：求绝对值\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;cmath\u0026gt; int main() { float n; cin \u0026gt;\u0026gt; n; n = fabs(n); printf(\u0026#34;%.2f\\n\u0026#34;, n); return 0; } fabs是专门用来求浮点数绝对值的\n库函数 fabs 是用来求⼀个浮点数的绝对值的，需要的头文件是 cmath\u0026gt;\nabs是专门用来求整数绝对值的\n要包含头文件cstdlib\n题目2 奇偶数判断\n注意：取模运算符如果前面的数是负数，那么结果也为负数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; if(n % 2 == 1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else if(n % 2 == -1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;even\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 2.关系操作符 关系表达式的结果要么是1要么是0，关系操作符是从左向右计算的\n==注意：关系操作符不宜连用==\n1 2 i \u0026lt; j \u0026lt; k; // 实际执行的是(i \u0026lt; j) \u0026lt; k; //(i \u0026lt; j)返回的是0或1 如果想表示j在i和k之间，需要使用下面的写法\n1 (j \u0026gt; i \u0026amp;\u0026amp; j \u0026lt; k) 浮点数比较大小\n在⽐较浮点数时，由于浮点数在计算机中是以有限精度表⽰的，也就是说有些浮点数在内存中其实⽆法精确保存，这可能导致浮点数⽐较中的⼀些精度误差问题。如果直接使⽤ == 来⽐较两个浮点数，很可能会由于这些微⼩的误差导致不准确的结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int main() { double a = 0.1; double b = 0.2; double c = 0.3; if(fabs((a + b) - c) \u0026lt; 0.0000001) // 1e-6 是允许的 cout \u0026lt;\u0026lt; \u0026#34;a + b == c\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;a + b != c\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 题目 题目1 思路1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //1.定义一个变量count，依次判断成绩是否合格 //合格就count++ //2.判断count，如果count=2那么就输出1，否则输出0 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int count = 0; int a; //输入+判断+统计 for(int i = 0; i \u0026lt; 3; i++) { cin \u0026gt;\u0026gt; a; if(a \u0026gt;= 60) count++; } //判断count + 输出 if(count == 2) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } 思路2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //思路2 //关系表达式的结果要么是1要么是0 //如果(s1 \u0026lt; 60) + (s2 \u0026lt; 60) + (s3 \u0026lt; 60) 的结果是1那么就输出1 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int s1, s2, s3; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2 \u0026gt;\u0026gt; s3; //判断 if(((s1 \u0026lt; 60) + (s2 \u0026lt; 60) + (s3 \u0026lt; 60)) == 1) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } 题目2 分析： 1.n是大于0，小于等于1000的 1)a1和a2最大取值是100，最小取值是-100，所以它们两者的差最大是200 差最大是200，项数最大是1000，int能存下 2)n可以取1或2，如果是1或2，那么第一项和第二项的结果已经有了 2.找规律 1)第1项和第2项之间的差值是x 2)第2项和第3项之间差值是x \u0026mdash; (3-2)x 第2项和第4项的差值是2个x \u0026mdash; (4-2)x 第2项和第5项的差值是3个x \u0026mdash; (5-2)x 3)推出第n项和第2项的差值是(n-2)x 3.第n项的值为 (n-1)x+第二项的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n1, n2, n; cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2 \u0026gt;\u0026gt; n; if(n == 1) cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; endl; else if(n == 2) cout \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; (n-2) * (n2-n1) + n2 \u0026lt;\u0026lt; endl; return 0; } 3.条件操作符 也叫三目操作符\n题目1 思路：过去了s分钟 / 吃一个苹果需要花费的时间t = 现在已经吃了的苹果个数 总的苹果个数m - 已经吃了的苹果个数 = 剩下的苹果个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int m, t, s; int r; // 剩余苹果数 cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s; //特殊情况：吃一个苹果需0分钟 if(t == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } //计算 ，注意：要考虑计算出的剩下苹果为负数的情况 if(s % t == 0) r = ((m - s / t) \u0026lt; 0) ? 0 : m - s / t;\telse r = ((m - s / t) \u0026lt; 0) ? 0 : m - s / t - 1; cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } 题目3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if((a + b \u0026gt; c) \u0026amp;\u0026amp; (a + c \u0026gt; b) \u0026amp;\u0026amp; (b + c \u0026gt; a)) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } 注意是==任意==两条边之和大于第三边，要用且\n题目4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i; cin \u0026gt;\u0026gt; i; if(i % 3 == 0) cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if(i % 5 == 0) cout \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if(i % 7 == 0) cout \u0026lt;\u0026lt; 7 \u0026lt;\u0026lt; endl; if(i % 3 != 0 \u0026amp;\u0026amp; i % 5 != 0 \u0026amp;\u0026amp; i % 7 != 0) cout \u0026lt;\u0026lt; \u0026#34;n\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 题目5 注意：条件表达式的结果是1或0\n题目中小B喜欢符合一个性质的，等价于两个条件相加等于1\n正妹喜欢不符合这两个性质的整数，等价于两个条件相加等于0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x; cin \u0026gt;\u0026gt; x; //小A if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) \u0026amp;\u0026amp; (x % 2 == 0)) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //Uim if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) || (x % 2 == 0)) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //小B //条件表达式的结果是1或0 if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) + (x % 2 == 0) == 1) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //正妹 if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) + (x % 2 == 0) == 0) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 4.switch语句 基本语法：\n1 2 3 4 5 6 7 8 9 10 11 12 switch(整型表达式) { case value1: ... break; case value2: ... break; default: ... break; } case语句决定分支的入口，break语句决定分支的出口\n注意/细节：\nswitch后面必须跟的是整型表达式(字符本质也是整型)，不能跟浮点型 case后面必须跟的是整型常量表达式 case和后面的值之间必须要加空格 注意不要忘加break switch语句中case和default是没有顺序要求的 题目 两种方式\nC语言的方式，scanf在读的时候可以指定读取的位数 C++的方式，一个数模上100剩下的就是0~99的数字 C语言的方式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int y,m; scanf(\u0026#34;%4d%2d\u0026#34;, \u0026amp;y, \u0026amp;m); switch(m) { case 3: case 4: case 5: cout \u0026lt;\u0026lt; \u0026#34;spring\u0026#34; \u0026lt;\u0026lt; endl; break; case 6: case 7: case 8: cout \u0026lt;\u0026lt; \u0026#34;summer\u0026#34; \u0026lt;\u0026lt; endl; break; case 9: case 10: case 11: cout \u0026lt;\u0026lt; \u0026#34;autumn\u0026#34; \u0026lt;\u0026lt; endl; break; case 12: case 1: case 2: cout \u0026lt;\u0026lt; \u0026#34;winter\u0026#34; \u0026lt;\u0026lt; endl; break; } return 0; } C++的方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int m; cin \u0026gt;\u0026gt; m; m = m % 100; switch(m) { case 3: case 4: case 5: cout \u0026lt;\u0026lt; \u0026#34;spring\u0026#34; \u0026lt;\u0026lt; endl; break; case 6: case 7: case 8: cout \u0026lt;\u0026lt; \u0026#34;summer\u0026#34; \u0026lt;\u0026lt; endl; break; case 9: case 10: case 11: cout \u0026lt;\u0026lt; \u0026#34;autumn\u0026#34; \u0026lt;\u0026lt; endl; break; case 12: case 1: case 2: cout \u0026lt;\u0026lt; \u0026#34;winter\u0026#34; \u0026lt;\u0026lt; endl; break; } return 0; } 使用if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int m; cin \u0026gt;\u0026gt; m; m = m % 100; if(m \u0026gt;= 3 \u0026amp;\u0026amp; m \u0026lt;= 5) cout \u0026lt;\u0026lt; \u0026#34;spring\u0026#34; \u0026lt;\u0026lt; endl; else if(m \u0026gt;= 6 \u0026amp;\u0026amp; m \u0026lt;= 8) cout \u0026lt;\u0026lt; \u0026#34;summer\u0026#34; \u0026lt;\u0026lt; endl; else if(m \u0026gt;= 9 \u0026amp;\u0026amp; m \u0026lt;= 11) cout \u0026lt;\u0026lt; \u0026#34;autumn\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;winter\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 5.循环 5.1 while循环 题目 注意数据类型的选取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n, i = 1; long long sum = 0; cin \u0026gt;\u0026gt; n; while(n) { sum += i; i++; n--; } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } 使用等差数列公式：（首项+尾项）*项数 / 2\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long n; long long sum = 0; cin \u0026gt;\u0026gt; n; sum = (1 + n) * n / 2; cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } 题目 注意：\n​\t1. 这道题虽然给的数据不会超过int，但是如果一直是奇数，那么一直\n​\t乘三+1可能就会超出能表示的范围，最好使用long long\n​\t2.printf打印long long类型的数据时，要使用%lld\n​\t3. 使用了printf最好包头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { long long n; cin \u0026gt;\u0026gt; n; while(n != 1) { if(n % 2 == 0) { printf(\u0026#34;%lld/2=%lld\\n\u0026#34;, n, n/2); n /= 2; } else { printf(\u0026#34;%lld*3+1=%lld\\n\u0026#34;, n, n * 3 + 1); n = n * 3 + 1; } } cout \u0026lt;\u0026lt; \u0026#34;End\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 题目 1 + 1x + x * x^1^ + x * x^2^+\u0026hellip;+x(x^(n-1)^)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { double x; double d = 1, sum = 1;//初始化为1 int n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; while(n--) { d *= x; sum += d; } printf(\u0026#34;%.2f\\n\u0026#34;, sum); return 0; } for循环 题目 注意局部变量如果不初始化，它的值是随机的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { //读取n int n; cin \u0026gt;\u0026gt; n; //读取n个年龄 int age; int sum = 0; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; age; sum += age; } double avg = sum * 1.0 / n; printf(\u0026#34;%.2f\\n\u0026#34;, avg); return 0; } 题目 时间：\n去的时间 \u0026ndash; 距离 回来的时间 \u0026ndash; 距离 上船的时间 \u0026ndash; 人数 下船的时间 \u0026ndash; 人数 每一个屋顶都是单独营救的，总时间和屋顶的个数有关\n向上取整\n6.1 \u0026mdash;-\u0026gt; 7\n6.5 \u0026mdash;-\u0026gt; 7\n6.0 \u0026mdash;-\u0026gt; 6\n我们可以将小数部分取出来，如果小数部分大于0.0那么整个数+1之后再强转\n反之就直接强转\n1 2 3 4 5 6 7 double d = 6.5; int q = (int)d; double p = d - p; //6.5-6 == 0.5 if(p \u0026gt; 0.0) (int)(d + 1); else (int)d; 库函数中有\nceil \u0026ndash; 向上取整\nfloor \u0026ndash; 向下取整\n头文件cmath\n思路\n1. 输入n 2. 循环n次 每次处理一个屋顶 x,y,m (1)计算距离 (2)计算时间 (3)时间累加 3.输出时间 - 向上取整 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; //\t1. 输入n //\t2. 循环n次 //\t每次处理一个屋顶 x,y,m //\t(1)计算距离 //\t(2)计算时间 //\t(3)时间累加 //\t3.输出时间 - 向上取整 #include \u0026lt;cmath\u0026gt; double x,y; // 坐标 int m; // 人数 double t; int main() { int n; //输入屋顶数 cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; m; //计算距离 double dis = sqrt(x * x + y * y); //计算时间 t += dis / 50 * 2 + m * 1.5; } //输出时间 -- 向上取整 cout \u0026lt;\u0026lt; (int)ceil(t) \u0026lt;\u0026lt; endl; return 0; } 题目 使用pow函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;cmath\u0026gt; int main() { int n; double sum = 0; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) { sum += pow(-1, i-1) * 1.0 / i; } printf(\u0026#34;%.4f\\n\u0026#34;, sum); return 0; } break和continue 题目 分析：\nn = m1 * m2，m1 != m2 m1和m2是质数 什么是质数？\n质数就是只能被1和它本身整除的数\n我们只需要在2~n-1之间找到m1，m1就是较小的那个质数\n然后n/m1就是m2\n因为m1和m2都是质数，所以m1和m2都只能被1和本身整除\nn又可以通过m1*m2得到，所以实际上n只能被0,m1,m2,n整除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int i; for(i = 2; i \u0026lt; n; i++) { if(n % i == 0) { cout \u0026lt;\u0026lt; n / i \u0026lt;\u0026lt; endl; break; } } return 0; } 题目 思路分析 1.输入n 2.sum=1 3.循环n次\u0026ndash;解决n项求和 1)算出阶乘 2)1/阶乘 3)求和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { double sum = 1; int n; cin \u0026gt;\u0026gt; n; //n项 long long fac = 1; for(int i = 1; i \u0026lt;= n; i++) { //求i的阶乘 -- n!=(n-1)!*n fac *= i;\tsum += 1.0 / fac; } printf(\u0026#34;%.10f\\n\u0026#34;, sum); return 0; } 第n小的质数 分析：\n质数又称为素数。\n质数只能被1和它本身整除。比如7,7能被1和7整除，但是2,3,4,5,6都不能整除7\n第n小的质数，就是从小到大的第n个质数\n写题思路：\n1.输入n 2.从2开始向后，找到n个质数，第n个质数就是第n小的质数\n​\t判断i是否为质数 试除法：产生2到i-1之间的数字\n​\t如果i是素数，count++\nTLE超出时间限制\n**优化思路：**如果n有一个因子a，那么必然存在另一个因子b，使得n=a*b。如果a和b都\n大于根号n，那么ab的结果将会大于n，这与n=ab矛盾。因此至少有一个因子不会超过根号n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; //分析 //1.输入n //2.从2开始向后，找到n个质数，第n个质数就是第n小的质数 int main() { int n; cin \u0026gt;\u0026gt; n; int count = 0; int i = 2; while(1) { //\t判断i是否为质数 //\t试除法：产生2到i-1之间的数字 int flag = 1; // 假设i是素数 for(int j = 2; j \u0026lt;= sqrt(i); j++) { if(i % j == 0) { //不是质数 flag = 0; break;\t}\t} //如果i是素数，count++ if(flag == 1) count++; if(count == n) break; i++; } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } 水仙花数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; //分析 //1.产生100~999中的数字 -- 循环 //2.判断i是否是水仙花数 //\t1)得到每一位%10 /10，立方相加 //\t2)和原数相比较 int main() { int temp, sum; for(int i = 100; i \u0026lt;= 999; i++) { sum = 0; temp = i; while(temp) { sum += pow(temp % 10, 3); temp /= 10; } //判断是否为水仙花数 if(sum == i) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 补充：\n自幂数 \u0026ndash; 一个n位数，你的每一位的n次方之和等于你自己\n3位的自幂数是水仙花数\n总结做题时的注意事项 输出格式，注意许多题要求输出时中间有空格，\n有些还指定了宽度位（需要用printf）,要包含对应头文件#include \u0026lt;cstdio\u0026gt;\n例如：\n这道题目的输出只要求了按5位宽度输出，没要求空格\n实数就是小数\nscanf在读的时候可以指定位数\n一定要注意整数是使用int还是long long，如果是单个数字满足int，但是可能会有\n两个数相加/相乘等，那么结果可能会超出int所能表示的范围\n比如下面这道题，题目要求计算的是从1加到n的结果，需要使用long long\n使用printf 时如果是long long类型的数据，要使用%lld\nlong double类型的数据要使用%Lf\n使用scanf时，整数使用%d，float类型的使用%f，double类型的使用%lf\nlong double类型的使用%Lf\n比较大的数组最好声明为全局变量，且最好多开辟一点空间\n原因：局部变量是存储在栈区的，空间有限；全局变量存储在静态区，空间较大\n注意输出的标点，比如中间有逗号，但是结尾没有\n可以把第一个单独打印，后面,数字为一组\nint类型最大可以表示到10的9次方\n==算不明白数据范围就用 long long==\n注意：==结构体最后要加上分号==\n注意 if() 后面不要把 == 写成了 =\n子串是连续的一部分，子序列是可以不连续的\n处理负数取模\n除留余数法：hash(key) = key % N\n但是需要注意，key有可能是负数，取模之后会变成负数\n负数补正的操作为：加上模数即可 但是正数加上模数会变大，所以统一再取一次模 最终就是**（key % N + N) % N ，简称 模加模**\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n第六章 C/C++输入输出（下） 1.OJ题目输入情况汇总 OJ（online judge）\n1.1单组测试数据 程序运行1次，只处理一组数据\n要处理多组数据，需要运行多次\n1.2 多组测试数据 程序运行一次，会处理多组数据\n测试数据组数已知 测试数据组数未知 特殊值结束测试数据 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n1,n2; while(cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2, n1 || n2) { cout \u0026lt;\u0026lt; n1 + n2 \u0026lt;\u0026lt; endl; } return 0; } 逗号表达式\n从左向右依次计算 整个表达式的结果是最后一个表达式的结果 2.输入中的特殊技巧 2.1含空格字符串的输入技巧 含有空格的字符串，读取有四种方式：fgets、scanf、getchar、getline四种\n1 2 char arr[20]; fgets(arr, 20, stdin); // stdin 标准输入流 -- 键盘 1 2 char arr[20]; scanf(\u0026#34;%10s\u0026#34;, arr); // 最多读10个字符 1 2 3 4 5 6 7 char ch = 0; int i = 0; while((ch = getchar()) != \u0026#39;\\n\u0026#39;) { arr[i] = ch; i++; } 1 2 string str; getline (cin, str); // getline遇到换行就结束 fgets会读取\\n，并在读取的内容后面自动加上\\0\nscanf(%[num]s)不会读取\\n，但会在读取的内容后面加上\\0\ngetchar读取一个字符，所以\\n会读取\ngetline不会读取\\n，第三个参数可以指定结束的标志字符\n有时候不一定要完整读取这个带空格的字符串，而是将字符串当做一个个单词处理\n2.2数字的特殊处理方式 当程序运行时，我们从控制台输入123的时候，其实是输入的123是3个字符\n但是编译器会根据代码中的数据类型，将读取到的字符序列解析成对应类型的数据\n1 2 3 4 5 int num = 0; cin \u0026gt;\u0026gt; num;//输入的123会被解析成整型 string s; cin \u0026gt;\u0026gt; s;//输入的123会被解析成字符串 题目 方法一：权重\n读取整个整数，然后%10得到一位，/10去掉一位\n由于十进制的每一位都有权重，所以如果我们得到的一位是奇数，那么就\n1*10^位数， 如果是偶数就是0*10^位数，然后将它们相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int ret = 0; int i = 0; while(n) { if(n % 10 % 2) ret += 1 * pow(10, i); n /= 10; i++; } cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; return 0; } 方法二：当成字符串读取\n当成字符串读取，然后遍历字符串，修改字符串中的字符，最后输出时需要转换成\n整型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { char ch; string s; while(cin \u0026gt;\u0026gt; ch) { if(ch % 2 == 0) s += \u0026#39;0\u0026#39;; else s += \u0026#39;1\u0026#39;; } cout \u0026lt;\u0026lt; stoi(s) \u0026lt;\u0026lt; endl; return 0; } 3.scanf-printf和cin-cout的区别 3.1格式控制差异 prinf和scanf需要手动指定格式字符串，而cin和cout会自动推导类型 prindf和scanf格式化输出更精确和直观 prinf在打印的时候默认打印小数点后六位，cout会自动忽略小数点后多余的0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { float a = 3.50; double d = 16.50; cout \u0026lt;\u0026lt; \u0026#34;cout:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; printf(\u0026#34;printf:%f %lf\\n\u0026#34;, a, d); return 0; } 3.2cin-cout性能问题 通常scanf和prinf比cin和cout快\n**原因：**cin和cout由于要考虑兼容C语言的输入和输出，封装实现的更加复杂\n这种差异在大多数应用场景中可以忽略不计，但是在竞赛中，当输入输出数据量\n较大的时候，使用cin和cout就可能出现Time Limit Exceeded\n总结性能低的原因：\nC++中为了支持混合使用cin/cout和printf/scanf，C++标准库默认会将cin/cout\n等C++流对象与stdin/stdout等C标准库的流对象同步在一起。这种同步操作意味着每次使用cin/cout时，都会自动刷新C标准库的缓冲区，以确保C++和C的I/O是一致的\n在默认情况下，cin和cout之间存在一种绑定关系。这种绑定关系意味着每当cin\n读取数据时，任何之前通过cout输出的内容都会被强制刷新到屏幕上。这种绑定\n也可能导致性能问题，特别是在需要频繁读取大量数据的情况下\n3.3 优化方案和演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; #include\u0026lt;ctime\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int num = 10000000; int main() { ios::sync_with_stdio(false); //取消给C语⾔输⼊输出缓冲区的同步 cin.tie(0); //取消了cin和cout的绑定 freopen(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); int i, x; clock_t t1, t2; t1 = clock(); for (i = 0; i \u0026lt; num; i++) { cin \u0026gt;\u0026gt; x; } t2 = clock(); cout \u0026lt;\u0026lt; \u0026#34;Runtime of cin: \u0026#34; \u0026lt;\u0026lt; t2 - t1 \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; 如果追求性能，那就使用scanf/printf或优化后的cin/cout\n如果输入的数据量比较小（10^6以内）的话，用cin/cout和prinf/scanf都行\n如果输入的数据量比较大（10^9左右）的话，更推荐使用scanf/printf，避免\n因为输入输出的开销，导致代码超时\n当输入输出的规模非常大的时候，scanf/printf也不能满足的时候，使用快速读写\n第七章 函数 1.函数是什么 函数就是一个完成某项特定的任务的一小段代码\n函数的好处：\n模块化开发\n一个大的功能，总能拆分成各种子功能，每个子功能都可以设计成一个函数\n每个函数可以作为一个独立的模块存在，程序的逻辑更加清晰、明确\n代码可以复用\n只需要定义出一个函数，需要这个功能的地方，直接调用函数就行\n方便多个程序员之间协作开发，方便程序的多个模块之间互相交互\n代码的编写、阅读、调试、维护都更加容易\n2.函数的分类 2.1库函数 库函数是标准库中提供的现成的函数，我们只要学习函数的功能，就能直接使⽤。\n有了库函数，⼀些常⻅的功能就不需要程序员⾃⼰实现了，⼀定程度提升了效率；同时库\n函数的质量和执⾏效率上都更有保证。\n编译器的标准库中提供了⼀系列的库函数，这些库函数根据功能的划分，都在不同的头⽂\n件中进⾏了声明。\nC/C++官⽅参考⼿册：https://zh.cppreference.com/w/cpp/header\nC/C++第三⽅⽹站：https://legacy.cplusplus.com/reference/\n2.1.1库函数使用举例 sqrt 开平方 需要包含头文件cmath\nsqrt是函数名\nx是函数参数，表示调用sqrt函数需要传递一个double类型的值\ndouble是返回值类型，表示函数计算的结果是double类型的值\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double x = 16.0; double r = sqrt(x); cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl;//4 return 0; } pow次方 它接受两个参数，第一个参数是底数，第二个参数是指数，然后返回底数的指数次幂的结果。\n例如，pow(2,3)会计算 2 的 3 次方，结果为 8。\n2.2自定义函数 3.函数参数和返回值 3.1实参 实参就是真实传递给函数的参数\n3.2形参 形参只有在函数调用的时候才会向内存申请空间，\n而如果不去调用函数，那么形参只是形式上存在，不会向内存申请空间\n形参是实参的一份临时拷贝 形参有自己独立的空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; int Add(int n1, int n2) { return n1 + n2; } int main() { int a = 0; int b = 0; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int r = Add(a, b);\tcout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } 在Add函数中，返回值会先把值放到寄存器中，然后再把寄存器里的值赋值给\nmain函数中的r\n原因：返回值是局部变量，函数一旦调用结束，返回值的这块空间\n就要还给操作系统，这样就没办法把值带给r，所以会先备份到寄存器\n寄存器是CPU上的一个硬件，是一个存储空间\n数组传参\n形参如果是二维数组，那么行可以省略，但是列不能省略 形参的数组和实参的数组是同一个数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; void test(int arr[][5], int r, int c) { for(int i = 0; i \u0026lt; r; i++) { for(int j = 0; j \u0026lt; c; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } int main() { int arr[3][5] = {{1,2, 3, 4, 5}, {2, 3, 4, 5, 6}, {3, 4, 5, 6, 7}}; test(arr, 3, 5); return 0; } 字符串做函数参数\n如果将字符串做函数参数，那么形参的改变也不会影响实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; void test(string s) { s = \u0026#34;hehe\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } int main() { string s = \u0026#34;hello world\u0026#34;; test(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 全局变量在整个程序中都可以使用，不用传参\n3.3 返回值 返回值可以是一个数值，也可以是一个表达式，也可以什么都没有\n如果有返回值，也可以选择不接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; void test(int n) { if(n == 2) return; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } int main() { test(1); test(2); test(5); return 0; } return 会彻底结束该函数，该函数后面的代码不会再执行\n4.函数的声明和调用 4.1函数的声明 函数声明只需要返回类型 函数名(函数参数);\n注意\n函数要满足先声明，后使用 函数的定义是一种特殊的声明 4.2函数的调用 4.2.1传值调用 4.2.2引用 引用不是新定义一个变量，而是==给已经存在的变量取了一个别名==\n==编译器不会为引用变量开辟内存空间==，它和它引用的变量是同一块空间\n语法：类型\u0026amp; 引用变量名 = 引用实体;\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; int\u0026amp; ra = a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //10 cout \u0026lt;\u0026lt; ra \u0026lt;\u0026lt; endl; //10 return 0; } 注意\n引用在定义时必须初始化\n1 int\u0026amp; a; // err 一个变量可以有多个引用\n1 2 3 4 5 6 7 int a = 10; int\u0026amp; r1 = a; int\u0026amp; r2 = a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//10 cout \u0026lt;\u0026lt; r1 \u0026lt;\u0026lt; endl;//10 cout \u0026lt;\u0026lt; r2\u0026lt;\u0026lt; endl;//10 引用一旦引用一个实体，就不能引用其它实体了\n1 2 3 4 5 6 7 8 9 int a = 10; int b = 20; int\u0026amp; r1 = a; int\u0026amp; r2 = a; r1 = b;//赋值 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; r1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; r2\u0026lt;\u0026lt; endl; ​\n4.2.3传址（引用）调用 string类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void test(string\u0026amp; s1) { cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl;//hello world s1 = \u0026#34;hehe\u0026#34;; } int main() { string s = \u0026#34;hello world\u0026#34;; test(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;//hehe return 0; } 改造Swap函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Swap(int\u0026amp; x, int\u0026amp; y) { int z = x; x = y; y = z; } int main() { int a = 0, b = 0; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;交换前：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; Swap(a, b); cout \u0026lt;\u0026lt; \u0026#34;交换后：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 库函数swap\n这个函数可以用来交换两个变量，也可以交换两个数组（容器的值）\n使用需要包含头文件\u0026lt;utility\u0026gt;\n1 2 3 int arr1[4] = {0}; int arr2[4] = {10, 20, 30, 40}; swap(arr1, arr2); 5.函数重载 C++中函数重载是指在同一个作用域中可以有多个同名函数，\n要求函数名相同，但是形参列表不同（形参个数、顺序、类型 至少一个不同）\n6.函数练习 6.1库函数max和min max用于返回两个值中的较大值，使用要包含头文件\u0026lt;algorithm\u0026gt;\nmax函数可以用于各种类型，包括内置类型（如int、double、类、结构体）\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int a = 10; int b = 20; int m = max(a, b); cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; //提供一个返回布尔值的函数，表示第一个参数是否小于第二个参数 bool cmp_str(string str1, string str2) { return str1.size() \u0026lt; str2.size(); } int main() { string s1 = \u0026#34;abcdef\u0026#34;; string s2 = \u0026#34;bcq\u0026#34;; //默认按照对应位置的ASCII码值的大小比较 //\tstring m = max(s1, s2); //\tcout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; //指定比较方式，如按照字符串的长度来比较 string m = max(s1, s2, cmp_str); cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 题目 法1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int n = 0; int _max, _min; int t = 0; cin \u0026gt;\u0026gt; n; //读取第一个数字 cin \u0026gt;\u0026gt; t; //假设第一个数就是最大值/最小值 _max = _min = t; for(int i = 1; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; t; _max = max(_max, t); _min = min(_min, t);\t} cout \u0026lt;\u0026lt; _max - _min \u0026lt;\u0026lt; endl; return 0; } 法二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int n = 0; //整数范围0~100 int _max = 0; int _min = 100; int t = 0; cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; t; _max = max(_max, t); _min = min(_min, t);\t} cout \u0026lt;\u0026lt; _max - _min \u0026lt;\u0026lt; endl; return 0; } 题目 思路：\n输入M、N 产生[M，N]之间的数 for(int i = m; i \u0026lt;= n; i++) 判断i是否是真素数 i是素数 i的反序也是素数 产生反转后的数 转成string类型，reverse()，stoi 反转思路2：\nint ret = 0;\nret = ret * 10 + i % 10;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool is_prime(int m) { //素数：只能被1和自身整数的数 if(m \u0026lt;= 1) return false; //产生2~sqrt(m)之间的数，去试除m for(int i = 2; i \u0026lt;= sqrt(m); i++) { if(m % i == 0) return false;\t} return true; } //int reverse_int(int k) //{ //\tstring s = to_string(k); //\treverse(s.begin(), s.end()); //\treturn stoi(s); //} int reverse_int(int k) { if(k \u0026lt;= 9) return k; int ret = 0; while(k) { ret = ret * 10 + k % 10; k /= 10; } return ret; } int main() { //\t思路： //\t1.输入M、N //\t2.产生[M，N]之间的数 for(int i = m; i \u0026lt;= n; i++) //\t3.判断i是否是真素数 //\t1)i是素数 //\t2)i的反序也是素数 //\t1)产生反转后的数 //\t2)转成string类型，reverse()，stoi int M, N; int flag = 0; cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N; for(int i = M; i \u0026lt;= N; i++) { //产生i的反序数字 i2 int i2 = reverse_int(i); //判断i和i2是否同时为素数 if(is_prime(i) \u0026amp;\u0026amp; is_prime(i2)) { if(flag) cout \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; i; flag = 1; } } if(flag == 0) cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 7.递归 7.1递归概念 递归具体是指函数在定义的时候直接或间接调用自身的方式（函数自己调用自己）\n每一次函数调用都要向栈区申请空间\n最简单的递归：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;hehe\u0026#34; \u0026lt;\u0026lt; endl; main();//调用main函数自己 return 0; } 7.2 递归思想 递归可以把一个==大型复杂问题==层层转化为一个与==原问题相似==，但==规模较小的子问题==\n来求解，直到子问题不能再被拆分，可以直接求解，递归就结束了。\n递归的思考方式就是把==大事化小==的过程\n递归就是递推回归的意思\n7.3递归的必要条件 递归在书写的时候，需要满足两个必要条件\n递归==存在限制条件==，当满足这个限制条件的时候，递归就不再继续 ==每次递归调用后会越来越接近这个限制条件== 例子1：求n的阶乘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int Fact(int n) { //4！= 1 * 2 * 3 * 4 = 3! * 4 //n! = n*(n-1)! //0的阶乘=1 if(n == 0) return 1; else return n * fac(n-1);\t} int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; Fact(n) \u0026lt;\u0026lt; endl; return 0; } 例子2：求第n个斐波那契数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; //int Fib(int i) //{ //\tif(i \u0026lt;= 2) //\treturn 1; //\telse //\treturn Fib(i-1) + Fib(i-2); //} int Fib(int i) { int a = 1; int b = 1; int c = 1; while(i \u0026gt;= 3) { c = a + b; a = b; b = c; i--; } return c; } int main() { //思路： //1.第1个和第2个数是1，从第3个数开始， // 后一个数等于前两个数之和 //2. res = (n-1) + (n-2) int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; Fib(n) \u0026lt;\u0026lt; endl; return 0; } 7.4 递归和循环（迭代） 8.递归练习 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; int digit(int n, int k) { if(k == 1) return n % 10; else return digit(n / 10, k - 1); } int main() { //思路 //1.输入正整数n和从右边数第k个数字 //2.k=1，n%10 //\tk=2，n/10 k=1，n%10 //\tk=3，n/10 k=2，n/10 k=1，n%10 //\tk=N，n/10 k=2，n/10 ... k=1，n%10 int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; digit(n, k) \u0026lt;\u0026lt; endl; return 0; } 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; double f(double x, int n) { if(n == 1) return sqrt(1 + x); else if(n \u0026gt; 1) return sqrt(n + f(x, n-1)); } //f(x,n) //n==1，sqrt(1+x) //n\u0026gt;1，sqrt(x+f(x,n-1)) int main() { double x; int n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; double r = f(x, n); printf(\u0026#34;%.2lf\\n\u0026#34;, r); return 0; } 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; string s = \u0026#34;0123456789ABCDEF\u0026#34;; void x_to_m(int x, int m) { //1.如果x\u0026gt;=m if(x \u0026gt;= m) x_to_m(x / m, m); //2.x\u0026lt;m，直接打印该数字 cout \u0026lt;\u0026lt; s[x % m]; } int main() { int x,m; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; m; x_to_m(x, m);\treturn 0; } ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n【数据结构初阶】OJ题 1、栈和队列 1.1有效括号 题目链接\n题目描述： 输出true的典型情况\n示例1：\n输入：s = \u0026ldquo;()\u0026rdquo;\n输出：true\n示例2：\n输入：s = \u0026ldquo;(){}[]\u0026rdquo;\n输出：true\n示例3：\n输入：s = \u0026ldquo;({[]})\u0026rdquo;\n输出：true\n示例4：\n输入：s = \u0026ldquo;()[{}]\u0026rdquo;\n输出：true\n输出false的典型情况\n示例1：\n输入：s = \u0026ldquo;[\u0026rdquo;\n输出：false\n示例2:\n输入：s = \u0026ldquo;]\u0026rdquo;\n输出：false\n示例3：\n输入：s = \u0026ldquo;(]\u0026rdquo;\n输出：false\n示例4：\n输入：s = \u0026ldquo;()[]{}(\u0026rdquo;\n输出：false\n示例5：\n输入：s = \u0026ldquo;()[]{})\u0026rdquo;\n输出：false\n思路 我们使用栈来实现。\n遍历字符串，while(*ps != \u0026lsquo;\\0\u0026rsquo;){ }\n若ps遍历到的字符是左括号的时候，入栈。 若ps遍历到的字符是右括号 如果栈为空，直接返回false 和栈顶元素相匹配的时候，出栈，s++。 和栈顶元素不相匹配的时候，返回false 遍历完字符串后，如果==最后栈为空==，则返回true，否则返回false 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 typedef char STDataType; typedef struct Stack { STDataType* arr; int capacity; int top; }ST; //栈的初始化 void STInit(ST* ps) { assert(ps); ps-\u0026gt;arr = NULL; ps-\u0026gt;capacity = ps-\u0026gt;top = 0; } //栈的销毁 void STDestroy(ST* ps) { assert(ps);//保证栈是存在的 if(ps-\u0026gt;arr)//判断栈是否为空 free(ps-\u0026gt;arr); ps-\u0026gt;capacity = ps-\u0026gt;top = 0; } //入栈 void STPush(ST* ps, STDataType x) { assert(ps); //如果满了就增容 if(ps-\u0026gt;top == ps-\u0026gt;capacity) { int newCapacity = ps-\u0026gt;capacity == 0 ? 4 : 2 * ps-\u0026gt;capacity; STDataType* tmp = (STDataType*)realloc(ps-\u0026gt;arr, newCapacity * sizeof(STDataType)); if(tmp == NULL) { perror(\u0026#34;realloc fail!\u0026#34;); exit(1); } ps-\u0026gt;arr = tmp; ps-\u0026gt;capacity = newCapacity; } //空间足够 ps-\u0026gt;arr[ps-\u0026gt;top++] = x; } //判断栈是否为空 bool STEmpty(ST* ps) { assert(ps); return ps-\u0026gt;top == 0;//为空，返回true } //出栈 void STPop(ST* ps) { assert(ps); assert(!STEmpty(ps)); --ps-\u0026gt;top; } //取栈顶元素 STDataType STTop(ST* ps) { assert(ps); assert(!STEmpty(ps)); return ps-\u0026gt;arr[ps-\u0026gt;top - 1]; } bool isValid(char* s) { ST st; STInit(\u0026amp;st); //遍历字符串 char* ps = s; while(*ps != \u0026#39;\\0\u0026#39;) { //左括号，入栈 if(*ps == \u0026#39;(\u0026#39; || *ps == \u0026#39;[\u0026#39; || *ps == \u0026#39;{\u0026#39;) { STPush(\u0026amp;st, *ps); } else//右括号，和栈顶元素比较是否匹配 { //栈为空，直接返回false if(STEmpty(\u0026amp;st)) { return false; } char ch = STTop(\u0026amp;st); if((*ps == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; ch == \u0026#39;(\u0026#39;) || (*ps == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; ch == \u0026#39;[\u0026#39;) || (*ps == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; ch == \u0026#39;{\u0026#39;)) { //匹配，出栈 STPop(\u0026amp;st); }else { //销毁栈 STDestroy(\u0026amp;st); //不匹配 return false; } } ps++;//访问往后一个字符 } //先判断栈是否为空 bool ret = STEmpty(\u0026amp;st); //销毁栈 STDestroy(\u0026amp;st); return ret; } 1.2 用队列实现栈 题目链接\n题目 思路 队列特点：先进先出\n栈的特点：后进先出\n用两个队列实现 栈的普通操作\n出栈：找不为空的队列，将size-1个数据导入到另一个队列中 入栈：往不为空的队列中插入数据 取栈顶元素 代码 队列的基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 typedef int QDataType; // 队列结点结构 typedef struct QueueNode { QDataType data; struct QueueNode* next; } QueueNode; // 队列结构 typedef struct Queue { QueueNode* phead; QueueNode* ptail; int size; } Queue; // 初始化 void QueueInit(Queue* pq) { assert(pq); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } // 入队列，队尾 void QueuePush(Queue* pq, QDataType x) { assert(pq); // 申请一个新结点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror(\u0026#34;malloc fail!\u0026#34;); exit(1); } newnode-\u0026gt;data = x; newnode-\u0026gt;next = NULL; // 初始情况下，队列为空，phead和ptail都指向空 if (pq-\u0026gt;phead == NULL) { pq-\u0026gt;phead = newnode; pq-\u0026gt;ptail = newnode; } else { // 在队尾入队列 pq-\u0026gt;ptail-\u0026gt;next = newnode; pq-\u0026gt;ptail = newnode; } pq-\u0026gt;size++; } bool QueueEmpty(Queue* pq) { assert(pq); return pq-\u0026gt;phead == NULL \u0026amp;\u0026amp; pq-\u0026gt;ptail == NULL; } // 出队列，队头 void QueuePop(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); // 只有一个结点的情况，避免ptail成野指针 if (pq-\u0026gt;phead == pq-\u0026gt;ptail) { free(pq-\u0026gt;phead); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; } else { // 删除头结点 QueueNode* next = pq-\u0026gt;phead-\u0026gt;next; free(pq-\u0026gt;phead); pq-\u0026gt;phead = next; } pq-\u0026gt;size--; } // 取队头数据 QDataType QueueFront(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;phead-\u0026gt;data; } // 取队尾数据 QDataType QueueBack(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;ptail-\u0026gt;data; } // 取有效元素个数 int QueueSize(Queue* pq) { assert(pq); return pq-\u0026gt;size; } // 队列的销毁 void QueueDestroy(Queue* pq) { assert(pq); // 循环遍历销毁结点 QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { QueueNode* next = pcur-\u0026gt;next; free(pcur); pcur = next; } pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } 用两个队列实现栈的基本结构 MyStack由两个队列构成，对MyStack的初始化就是对里面的两个队列进行初始化\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { Queue q1; Queue q2; } MyStack; MyStack* myStackCreate() { MyStack* pst = (MyStack*)malloc(sizeof(MyStack)); QueueInit(\u0026amp;pst-\u0026gt;q1); QueueInit(\u0026amp;pst-\u0026gt;q2); return pst; } 用两个队列实现入栈 往不为空的队列中插入数据\n1 2 3 4 5 6 7 void myStackPush(MyStack* obj, int x) { if (!QueueEmpty(\u0026amp;obj-\u0026gt;q1)) { QueuePush(\u0026amp;obj-\u0026gt;q1, x); } else { QueuePush(\u0026amp;obj-\u0026gt;q2, x); } } ​\n用两个队列实现出栈 找不为空的队列 假定其中一个队列是空队列 判断假定是否正确 将不为空的队列的前size-1个结点导入到空队列中 最后，出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int myStackPop(MyStack* obj) { // 1.找不为空的队列 // 1）假定队列q1是空队列 Queue* empQ = \u0026amp;obj-\u0026gt;q1; Queue* noneQ = \u0026amp;obj-\u0026gt;q2; // 2）判断假定是否正确 if (!QueueEmpty(\u0026amp;obj-\u0026gt;q1)) { empQ = \u0026amp;obj-\u0026gt;q2; noneQ = \u0026amp;obj-\u0026gt;q1; } // 2.将不为空的队列的前size-1个结点导入到空队列中 while (QueueSize(noneQ) \u0026gt; 1) { int front = QueueFront(noneQ); QueuePush(empQ, front); QueuePop(noneQ); } // 非空队列中只剩下一个数据--要出栈的数据 int ret = QueueFront(noneQ); QueuePop(noneQ); return ret; } ​\n用两个队列实现取栈顶元素 取非空队列的队尾元素\n1 2 3 4 5 6 7 8 9 10 int myStackTop(MyStack* obj) { if(!QueueEmpty(\u0026amp;obj-\u0026gt;q1)) { return QueueBack(\u0026amp;obj-\u0026gt;q1); } else { return QueueBack(\u0026amp;obj-\u0026gt;q2); } } ​\n判空两个队列是否为空 1 2 3 4 bool myStackEmpty(MyStack* obj) { assert(obj); return QueueEmpty(\u0026amp;obj-\u0026gt;q1) \u0026amp;\u0026amp; QueueEmpty(\u0026amp;obj-\u0026gt;q2); } ​\n用两个队列实现销毁 1 2 3 4 5 6 void myStackFree(MyStack* obj) { QueueDestroy(\u0026amp;obj-\u0026gt;q1); QueueDestroy(\u0026amp;obj-\u0026gt;q2); free(obj); obj = NULL; } ​\n1.3 用栈来实现队列 题目 思路 代码 两个栈实现一个队列的结构\n入队列\n出队列\n​\n取队头元素\n​\n判断队列是否为空\n​\n队列的销毁\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"数据结构初阶 1、单链表 2、双向链表 3、栈 4、队列 4.1基本介绍 概念：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表 特点：==先进先出== 入队列：进行==插入==操作的一端称为==队尾==\n出队列：进行==删除==操作的一端称为==队头==\n4.2 实现队列的方式 底层使用数组\n入队列，如果在数组末尾插入数据，那么时间复杂度为O(1)\n出队列，如果在数组开头删除数据，那么后面的数据要整体向前挪动一位，时间复杂度为O(N)\n底层使用单链表\n入队列，如果在链表尾部插入数据，那么需要遍历链表找到尾结点，时间复杂度为O(N)\n出队列，如果在链表头部删除数据，时间复杂度为O(1)\n优化：定义一个指向尾结点的指针ptail，此时，我们再插入数据时，就直接让ptail指向\n的结点指向新结点，然后让新结点成为ptail ，时间复杂度为O(1)\n4.3 实现队列 队列的底层是一个链表，而链表是由一个个结点组成\n4.3.1 队列的定义 在队列这个数据结构中，我们有两个指针\n一个指向链表的头结点phead， 一个指向链表的尾结点ptail 当我们要插入数据时，往队尾插；当我们要删除数据时，往队头删\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef int QDataType; //定义队列结点的结构 typedef struct QueueNode { QDataType data; struct QueueNode* next; }QueueNode; //定义队列的结构 typedef struct Queue { QueueNode* phead; QueueNode* ptail; int size;//记录队列有效元素个数 }Queue; 4.3.2队列的功能实现 队列的初始化 1 2 3 4 5 6 void QueueInit(Queue* pq) { assert(pq); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } 入队列，队尾 入队列要往队尾入，所以要向操作系统申请一个结点大小的空间\n如果队列为空，新插入进来的结点既是头结点，也是尾结点\n如果队列不为空，直接让ptail指向的结点的next指针指向新结点，然后让ptail指向新结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void QueuePush(Queue* pq, QDataType x) { assert(pq); //申请新结点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror(\u0026#34;malloc fail!\u0026#34;); exit(1); } newnode-\u0026gt;data = x; newnode-\u0026gt;next = NULL; //队列为空 if (pq-\u0026gt;phead == NULL) { pq-\u0026gt;phead = pq-\u0026gt;ptail = newnode; } else//队列不为空 { pq-\u0026gt;ptail-\u0026gt;next = newnode; pq-\u0026gt;ptail = newnode; } ++pq-\u0026gt;size; } 出队列，队头 队列为空：不可以出队列\n队列不为空，可以出队列\n队列只有一个结点(phead == ptail)，释放头结点后，让phead和ptail都置为空\n队列有两个结点，出队列有两种方式\n1）先用指针next指向phead-\u0026gt;next，然后释放phead，最后phead = next\n2）先用指针del指向phead指向的结点，然后phead = phead-\u0026gt;next，最后释放del\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //队列判空 bool QueueEmpty(Queue* pq) { assert(pq); return pq-\u0026gt;phead == NULL \u0026amp;\u0026amp; pq-\u0026gt;ptail == NULL; } //出队列，队头 void QueuePop(Queue* pq) { assert(pq); //队列为空，不能出队列 assert(!QueueEmpty(pq)); //只有一个结点的情况，避免ptail成野指针 if (pq-\u0026gt;phead == pq-\u0026gt;ptail) { free(pq-\u0026gt;phead); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; } else { //删除头结点 QueueNode* next = pq-\u0026gt;phead-\u0026gt;next; free(pq-\u0026gt;phead); pq-\u0026gt;phead = next; } --pq-\u0026gt;size; } 取队头数据，取队尾数据 队列为空，不能取队头或队尾数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //取队头数据 QDataType QueueFront(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;phead-\u0026gt;data; } //取队尾数据 QDataType QueueBack(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;ptail-\u0026gt;data; } 取队列有效元素个数 方法一：遍历队列，时间复杂度为O(N)\n对于可能会频繁调用取队列有效元素个数的情况，使用遍历队列中的结点，效率低\n方法二：在队列中定义一个size用来记录队列中有效元素个数\n出栈的时候，size\u0026ndash; 入栈的时候，size++\n1 2 3 4 5 6 7 8 9 10 11 12 13 int QueueSize(Queue* pq) { assert(pq); /*int size = 0; QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { size++; pcur = pcur-\u0026gt;next; } return size;*/ return pq-\u0026gt;size; } 队列的销毁 要将队列中所有结点销毁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void QueueDestroy(Queue* pq) { assert(pq); //队列为空，不可销毁 assert(!QueueEmpty(pq)); QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { QueueNode* next = pcur-\u0026gt;next; free(pcur); pcur = next; } pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = NULL; } Queue.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #pragma once #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;assert.h\u0026gt; #include\u0026lt;stdbool.h\u0026gt; typedef int QDataType; //定义队列结构 typedef struct QueueNode { QDataType data; struct QueueNode* next; }QueueNode; typedef struct Queue { QueueNode* phead; QueueNode* ptail; int size;//保存队列有效数据个数 }Queue; void QueueInit(Queue* pq); //入队列，队尾 void QueuePush(Queue* pq, QDataType x); //出队列，队头 void QueuePop(Queue* pq); //队列判空 bool QueueEmpty(Queue* pq); //取队头数据 QDataType QueueFront(Queue* pq); //取队尾数据 QDataType QueueBack(Queue* pq); //取队列有效元素个数 int QueueSize(Queue* pq); //队列的销毁 void QueueDestroy(Queue* pq); Queue.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #include\u0026#34;Queue.h\u0026#34; void QueueInit(Queue* pq) { assert(pq); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } //入队列，队尾 void QueuePush(Queue* pq, QDataType x) { assert(pq); //申请新结点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror(\u0026#34;malloc fail!\u0026#34;); exit(1); } newnode-\u0026gt;data = x; newnode-\u0026gt;next = NULL; //如果队列为空，新插入进来的结点既是头结点，也是尾结点 if (pq-\u0026gt;phead == NULL) { pq-\u0026gt;phead = pq-\u0026gt;ptail = newnode; } else//队列不为空 { pq-\u0026gt;ptail-\u0026gt;next = newnode; pq-\u0026gt;ptail = newnode; } ++pq-\u0026gt;size; } //队列判空 bool QueueEmpty(Queue* pq) { assert(pq); return pq-\u0026gt;phead == NULL \u0026amp;\u0026amp; pq-\u0026gt;ptail == NULL; } //出队列，队头 void QueuePop(Queue* pq) { assert(pq); //队列为空，不能出队列 assert(!QueueEmpty(pq)); //只有一个结点的情况，避免ptail成野指针 if (pq-\u0026gt;phead == pq-\u0026gt;ptail) { free(pq-\u0026gt;phead); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; } else { //删除头结点 QueueNode* next = pq-\u0026gt;phead-\u0026gt;next; free(pq-\u0026gt;phead); pq-\u0026gt;phead = next; } --pq-\u0026gt;size; } //取队头数据 QDataType QueueFront(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;phead-\u0026gt;data; } //取队尾数据 QDataType QueueBack(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;ptail-\u0026gt;data; } //取队列有效元素个数 int QueueSize(Queue* pq) { assert(pq); /*int size = 0; QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { size++; pcur = pcur-\u0026gt;next; } return size;*/ return pq-\u0026gt;size; } void QueueDestroy(Queue* pq) { assert(pq); //队列为空，不可销毁 assert(!QueueEmpty(pq)); QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { QueueNode* next = pcur-\u0026gt;next; free(pcur); pcur = next; } pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } 5、二叉树 5.1 二叉树 5.2 堆 5.3 二叉树链式结构 6、排序 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\nHTML学习 👋1. 初识HTML 1.1 基本介绍 HTML是==超文本标记语言==（Hyper Text Markup Language）\n超文本包括：文字、图片、音频、视频、动画等\n1.2 HTML发展史 当前==最新版本HTML5==\n网页实现动态渲染图形、图表、图像和动画，以及不需要安装任何插件直接使用网页\n播放视频等\n1.3 HTML5的优势 世界知名浏览器厂商对HTML5的支持 微软 Google 苹果 Opera Mozilla 市场需求 跨平台 1.4 W3C标准 ==万维网联盟==（World Wide Web Consortium）\n成立于1994年，Web技术领域最权威和具影响力的==国际中立性技术标准机构==\nhttp://www.w3.org/\nhttp://www.chinaw3c.org/\nW3C标准包括\n结构化标准语言（HTML、XML） 表现标准语言（CSS） 行为标准（DOM、ECMAScript） 1.3 HTML基本结构 1.4网页基本信息 注释：\n快捷键：ctrl+/\nDOCTYPE声明\n\u0026lt; title \u0026gt;标签\n\u0026lt; meta \u0026gt;标签\n😃2. 网页基本标签 2.1 标题标签[\u0026lt; h1 \u0026gt; \u0026lt; /h1 \u0026gt;] 1 2 3 4 5 6 7 \u0026lt;!--标题标签--\u0026gt; \u0026lt;h1\u0026gt;一级标签\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;二级标签\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;三级标签\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;四级标签\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;五级标签\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;六级标签\u0026lt;/h6\u0026gt; 效果：\n2.2 段落标签[\u0026lt; p\u0026gt;\u0026lt; /p\u0026gt;] 1 2 3 4 5 \u0026lt;p\u0026gt;两只老虎，两只老虎，\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;跑得快，跑得快，\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;一只没有眼睛，\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;一只没有尾巴，\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;真奇怪！真奇怪！\u0026lt;/p\u0026gt; 效果：==段与段之间空隙比较大==\n2.3 换行标签[\u0026lt; br/\u0026gt;] 1 2 3 4 5 两只老虎，两只老虎，\u0026lt;br/\u0026gt; 跑得快，跑得快，\u0026lt;br/\u0026gt; 一只没有眼睛，\u0026lt;br/\u0026gt; 一只没有尾巴，\u0026lt;br/\u0026gt; 真奇怪！真奇怪！\u0026lt;br/\u0026gt; 效果：==段与段之间空隙比较小==\n2.4 水平线标签[\u0026lt; hr/\u0026gt;] 1 \u0026lt;hr/\u0026gt; 效果：生成一条水平线\n例如：\n2.5 字体样式标签 1 2 粗体：\u0026lt;strong\u0026gt;I love you\u0026lt;/strong\u0026gt; 斜体：\u0026lt;em\u0026gt;I love you\u0026lt;/em\u0026gt; 效果：\n2.6 注释[\u0026lt; !\u0026ndash; \u0026ndash;\u0026gt;]和特殊符号[\u0026amp; ;] 1 2 3 注释：\u0026lt;!-- 要注释的文字 --\u0026gt; 快捷键：ctrl+/ 特殊符号：\n1 2 空 格\u0026lt;br/\u0026gt; 空\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;格 效果：\n1 2 3 4 5 6 \u0026lt;!--大于号--\u0026gt; \u0026amp;gt; \u0026lt;!--小于号--\u0026gt; \u0026amp;lt; \u0026lt;!--版权符号--\u0026gt; \u0026amp;copy;版权所有xxx 效果：\n特殊符号记忆方式\n\u0026amp; ;\n中间敲一个字母，就会出现提示，里面有各种字符\n🥳3. 图像，超链接，网页布局 3.1 常见的图像格式 JPG\nGIF\nPNG\nBMP\n\u0026hellip;\n​\n3.2 图像标签 1 2 3 4 5 6 7 8 \u0026lt;img src=\u0026#34;path\u0026#34; alt=\u0026#34;text\u0026#34; title=\u0026#34;text\u0026#34; width=\u0026#34;x\u0026#34; height=\u0026#34;y\u0026#34;/\u0026gt; \u0026lt;!-- src：填图像的路径 alt：图像显示不出来时的替代文字 title：鼠标悬停提示文字 width：图像宽度 height：图像高度 --\u0026gt; 图片路径：\n相对路径：../ 表示上一级 绝对路径：从磁盘开始定位 3.3 超链接标签 页面间链接（从一个页面链接到另一个页面） 1 2 3 4 5 6 7 \u0026lt;a href=\u0026#34;path\u0026#34; target=\u0026#34;目标窗口位置\u0026#34;\u0026gt; 链接文本或图像 \u0026lt;/a\u0026gt; \u0026lt;!-- href：链接路径，表示要跳转到哪个界面 target：链接在哪个窗口打开，常用_self 或 _blank _blank表示在新页面打开 _self表示在当前页面打开 --\u0026gt; E.G.\n1 2 \u0026lt;a href=\u0026#34;1.我的第一个网页.html\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;点击我跳转到我的第一个页面\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://www.baidu.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;点击我跳转到百度\u0026lt;/a\u0026gt; 效果：\n还可以有图像链接\n1 2 3 \u0026lt;a href=\u0026#34;1.我的第一个网页.html\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;../resources/image/button.jpg\u0026#34; alt=\u0026#34;无法显示\u0026#34; title=\u0026#34;悬停文字\u0026#34; width=\u0026#34;300\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; 锚链接（实现页面间的跳转）\n从当前页面的任意位置回到当前页面的顶部\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 锚链接 1.需要一个标记 2.跳转到标记 --\u0026gt; \u0026lt;!--使用name作为标记--\u0026gt; \u0026lt;a name=\u0026#34;top\u0026#34;\u0026gt;顶部\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#top\u0026#34;\u0026gt;回到顶部\u0026lt;/a\u0026gt; 实现从页面三跳转到页面四的底部\n1 2 3 4 5 \u0026lt;!-- 这是页面三中的 --\u0026gt; \u0026lt;a href=\u0026#34;4.链接标签.html#down\u0026#34;\u0026gt;跳转到页面4的底部\u0026lt;/a\u0026gt; \u0026lt;!--这是页面四中的 --\u0026gt; \u0026lt;a name=\u0026#34;down\u0026#34;\u0026gt;down\u0026lt;/a\u0026gt; 功能性链接\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--功能性链接 邮件链接：mailto: qq链接 --\u0026gt; \u0026lt;!-- 邮件链接：mailto: --\u0026gt; \u0026lt;a href=\u0026#34;mailto:2485941085@qq.com\u0026#34;\u0026gt;点击联系我\u0026lt;/a\u0026gt; \u0026lt;!-- 空链接：当前还没有确定链接目标 --\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; 首页 \u0026lt;/a\u0026gt; \u0026lt;!-- 下载链接：href里的地址是一个文件或者压缩包，会下载这个文件 --\u0026gt; \u0026lt;a href=\u0026#34;img.zip\u0026#34;\u0026gt;下载文件 \u0026lt;/a\u0026gt; ​\n3.4 网页布局 行内元素和块元素 ​ 👉4. 列表，表格，媒体元素 🔥5. 表单及表单应用 🌟6. 表单初级验证 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"1、概述 javaScript是一门世界上最流行的脚本语言\nECMAScript可以理解为是javaScript的一个标准\n最新版本已经到es6版本 但是大部分浏览器还只停留在支持es5代码上！ 开发环境 \u0026ndash; 线上环境，版本不一致 2、快速入门 2.1引入javaScript 标签内写JavaScript代码 注意：script标签必须成对出现\n1、内部标签\n1 2 3 \u0026lt;script\u0026gt; //... \u0026lt;script\u0026gt; 2、外部引入\n1 alert(\u0026#34;hello world\u0026#34;); 1 \u0026lt;script src=\u0026#34;abc.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt;--\u0026gt; \u0026lt;!-- alert(\u0026#34;hello world\u0026#34;);--\u0026gt; \u0026lt;!-- \u0026lt;/script\u0026gt;--\u0026gt; \u0026lt;!-- 注意：script标签必须成对出现--\u0026gt; \u0026lt;!-- 外部引入--\u0026gt; \u0026lt;script src=\u0026#34;js/dy.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 不用显示定义type，也默认就是javaScript--\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.3基本语法+浏览器控制台使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- javaScrip严格区分大小写--\u0026gt; \u0026lt;script\u0026gt; //1.java中定义变量 变量类型 变量名 = 变量值 let score = 0; // alert(num) // 条件控制 if (score \u0026gt; 60 \u0026amp;\u0026amp; score \u0026lt;= 80) { alert(\u0026#34;60-80\u0026#34;); } else if (score \u0026gt; 80 \u0026amp;\u0026amp; score \u0026lt;= 100) { alert(\u0026#34;80-100\u0026#34;); } else { alert(\u0026#34;other\u0026#34;); } /** *多行注释 */ // console.log(score) 在浏览器的控制台打印变量 \u0026lt;/script\u0026gt; 浏览器必备调试须知：\n2.4数据类型快速浏览 数据：数值、文本、图形、音频、视频\u0026hellip;\n变量\n可以以$ _ 还可以用中文开头\nvar默认是是全局的，let是局部的\n1 2 var $1 = 1 let 王者荣耀 = \u0026#39;倔强青铜\u0026#39;; number\njs不区分小数和整数，Number\n1 2 3 4 5 6 123 // 整数 123.1 // 浮点数 1.123e3 // 科学计数法 -99 //负数 NaN //not a number Infinity //表现无限大 字符串\n\u0026lsquo;abc\u0026rsquo; \u0026ldquo;abc\u0026rdquo;\n布尔值\ntrue , false\n逻辑运算\n1 2 3 4 5 \u0026amp;\u0026amp; 两个都为真，结果为真 || 一个为真，结果为真 ! 真变假，假变真 比较运算符\n1 2 3 = 赋值运算符 == 等于 === 绝对等于（类型一样，值一样，结果为true） 这是一个JS的缺陷，坚持不要使用 == 比较\n须知：\nNaN===NaN ，NaN和所有的数值都不相等，包括自己 只能通过isNaN(NaN)来判断这个数是否是NaN 浮点数问题：\n1 console.log((1 / 3) === (1 - 2 / 3)); 尽量避免使用浮点数进行运算，存在精度问题\n浮点数比较相等，使用绝对值来比较Math.abs( )\n1 Math.abs((1 / 3) - (1 - 2 / 3)) \u0026lt; 0.0000001 null和undefined\nnull 空 undefined 未定义 数组\njava的数值必须是相同类型的对象，JS中不需要这样\n1 2 3 4 // 保证代码的可读性，尽量使用 [] let arr = [1, 2, 3, 4, \u0026#39;hello\u0026#39;, null, true]; new Array[1, 23, 45, \u0026#39;hello\u0026#39;]; 取数组下标：如果越界了，会报undefined\n对象\n对象是大括号，数组是中括号\n每个属性之间使用逗号隔开，最后一个不需要添加\n1 2 3 4 5 6 //Person person = new Person(1, 2, 3, 4, 5, 6); let person = { name: \u0026#39;qingjiang\u0026#39;, age: 3, tags: [\u0026#39;js\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;web\u0026#39;, \u0026#39;...\u0026#39;] } 取对象的值\n1 2 3 person.name person.age person.tags 2.5严格检查模式strict 前提：IDEA需要设置支持ES6语法\n'use strict'; 严格检查模式，预防JavaScript的随意性导致产生的一些问题\n必须写在javaScript的第一行\n1 2 3 4 5 \u0026lt;script\u0026gt; \u0026#39;use strict\u0026#39;; // 全局变量 let i = 1; \u0026lt;/script\u0026gt; 3、数据类型 3.1字符串类型 1、正常字符串我们使用 单引号，或者双引号包裹\n2、注意转义字符\\\n1 2 3 4 5 \\\u0026#39; \\n \\t \\uxxxx //Unicode字符 \\x41 //ASCII码字符 3、多行字符串编写````\n1 2 3 4 5 6 //tab 上面 esc键下面 let msg = `hello world 你好呀 hello` 4、模版字符串\n拼接字符串：${变量名}\n1 2 3 4 let name = \u0026#39;qingjiang\u0026#39;; let age = 3; let msg = `你好呀，${name}` 5、字符串长度str.length\n1 2 var student = \u0026#34;student\u0026#34;; console.log(student.length); 6、字符串的可变性，不可变\n7、大小写转换\n1 2 3 //注意，这里是方法，不是属性 student.toLocaleUpperCase() student.toLocaleLowerCase() 8、获取指定下标\n1 student.indexof(\u0026#39;t\u0026#39;)// 1 9、截取字符串 substring\n1 2 3 4 5 student.substring(1) // 从第一个字符串 截取到最后一个字符串 \u0026gt; tudent student.substring(1, 3) //[1,3) \u0026gt; tu 3.2数组类型详解 Array可以包含任意的数据类型\n1 2 3 var arr = [1, 2, 3, 4, 5, 6];// 通过下标取值和赋值 arr[0] arr[0] = 1 1、长度\n1 arr.length 注意：加入给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失\n2、indexOf，通过元素获得下标索引\n1 2 arr.indexof(2) 1 字符串\u0026quot;1\u0026quot;和数字1是不同的\n3、slice ()截取Array的一部分，返回一个新数组\n( ]\n1 2 3 4 5 6 7 let arr = [1, 2, 3, 4, 5, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;] arr.slice(3) //从第三个开始截，即第三个后面所有的 \u0026gt; 4, 5, 6, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34; arr.slice(2, 6) \u0026gt; 3, 4, 5, \u0026#39;1\u0026#39; 4、push()尾部插入数据 pop()尾部删除数据\n1 2 3 4 5 6 7 let arr = [1, 2, 3, 4, 5, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;] arr.push(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) \u0026gt; 1, 2, 3, 4, 5, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39; arr.pop() \u0026gt; 1, 2, 3, 4, 5, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;a\u0026#39; 5、unshift()头部插入数据 shift()头部删除数据\n1 2 3 4 5 arr.unshift(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) \u0026gt; \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, 1, 2, 3, 4, 5, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39; arr.shift() \u0026gt; \u0026#39;a\u0026#39; 弹出 a 6、排序是sort()\n1 2 3 (3) [\u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;A\u0026#39;] arr.sort() (3) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] 7、元素反转reverse()\n1 2 3 (3) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] arr.reverse() (3) [\u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;] 8、concat()拼接，并没有修改数组，只是会返回一个新数组\n1 2 3 4 5 (3) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] arr.concat([1, 2, 3]) (6) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, 1, 2, 3] arr (3) [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] 9、连接符join()\n打印拼接数组，使用特定的字符串连接\n1 2 arr.join(\u0026#34;*\u0026#34;) \u0026#39;C*B*A\u0026#39; 10、多维数组\n1 2 3 arr = [[1, 2], [3, 4], [\u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;]]; arr[1][1] 4 数组：存储数组（如何存，如何取）\n3.3对象类型详解 若干个键值对\n1 2 3 4 5 6 7 8 9 10 11 12 13 var 对象名 = { 属性名：属性值, 属性名：属性值, 属性名：属性值 } //定义了一个person对象，他有四个属性 let person = { name: \u0026#34;jack\u0026#34;, age: 3, email: \u0026#34;123456@qq.com\u0026#34;, score: 0 } JS中的对象，{\u0026hellip;}表示一个对象，键值对描述属性 xxxx xxxx，多个属性之间使用逗号隔开，最后一个属性不加逗号\njavaScript中的所有的键都是字符串，值是任意对象\n1、对象赋值\n1 2 3 4 person.name = \u0026#34;qingjiang\u0026#34; \u0026#34;qingjiang\u0026#34; person.name \u0026#34;qingjiang\u0026#34; 2、使用一个不存在的对象属性，不会报错\n1 2 person.haha undefined 3、动态删减属性，通过delete删除对象的属性\n1 2 3 delete person.name true person的name属性就没了 4、动态的添加 ，直接给新的属性添加值即可\n1 2 person.haha = \u0026#34;haha\u0026#34; \u0026#34;haha\u0026#34; 5、判断属性值是否在这个对象中 xxx in xxx\n用in可以去找到它父类的方法\n1 2 3 4 5 \u0026#39;age\u0026#39; in person true \u0026#39;toString\u0026#39; in person true 6、判断一个属性是否是这个对象自身拥有的 hasOwnProperty()\n1 2 3 4 5 person.hasOwnProperty(\u0026#39;toString\u0026#39;) false person.hasOwnProperty(\u0026#39;age\u0026#39;) true 3.4分支循环详解 if判断\n1 2 3 4 5 6 7 8 let age = 3; if(age \u0026gt; 3) { alert(\u0026#34;haha\u0026#34;); }else if(age \u0026gt; 0){ alert(\u0026#34;kuwa~\u0026#34;); }else { alert(\u0026#34;...\u0026#34;); } 循环\n1 2 3 4 5 let age = 3; while(age \u0026lt; 100) { age += 1; console.log(age + \u0026#39; \u0026#39;); } 3.5Map和Set集合 3.6lterable迭代 3.7函数的定义和参数获取 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"1、变量的作用域、let、const详解 2、方法的定义和调用、apply 3、Date日期对象 4、面向对象原型继承 5、面向对象class继承 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"1、操作BOM对象 2、获得DOM节点 3、更新DOM节点 4、删除DOM节点 5、创建和插入DOM节点 6、获得和设置表单的值 7、表单提交验证及前端密码MD5 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n一、JavaScript 1、JS介绍 codeium.enableCodeLens\n2、ES5和ES6 3、软件配置 设置的首页\n离开软件界面时自动保存\n自动换行\n自动格式化程序\n还可以改变文件图标的主题\n4、函数 总结\n1.函数声明 1.无参无返回值\n2.有参有返回值\n2.函数表达式 函数表达式会产生一个值，赋值给一个变量\n函数声明和函数表达式的区别\n函数声明可以在定义之前使用，函数表达式必须先定义再使用\n3.箭头函数 ES6新增的，箭头函数不得到this指针\n1.函数体只有一行\n2.函数有多行\n3.多个参数\n4.从另一个函数内部调用一个函数 5、对象 1. 基本使用 我们可以写一个对象：\n1 2 3 4 5 6 7 const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, age: 2037 - 1991, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;Bob\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Steven\u0026#34;], }; 我们可以用对象.或对象[]的方式访问成员\n1 2 console.log(jonas.lastName); console.log(jonas[\u0026#34;lastName\u0026#34;]); 其中对象[]中方括号里的必须是一个字符串类型的表达式\n1 2 3 const nameKey = \u0026#34;Name\u0026#34;; console.log(jonas[\u0026#34;first\u0026#34; + nameKey]); console.log(jonas[\u0026#34;last\u0026#34; + nameKey]); 1 2 3 4 5 // prompt 返回的是字符串 const interestedIn = prompt( \u0026#34;What do you want to know about Jonas? Choose between firstName, lastName, age, job, and friends\u0026#34; ); console.log(jonas[interestedIn]); 而对象.的方式后面只能跟属性名，而不能是表达式\n创建新的成员变量只需要对象.属性名 = 属性值\n2. 练习 输出：Jonas has 3 friends, and his best friend is called Bob\n1 2 3 4 5 6 7 8 9 10 11 const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, age: 2037 - 1991, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;Bob\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Steven\u0026#34;], }; console.log( `${jonas.firstName} has ${jonas.friends.length} friends, and his best friend is called ${jonas.friends[0]}` ); 3. 成员函数 基本使用 1 2 3 4 5 6 7 8 9 10 11 12 const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, birthYear: 2004, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;Bob\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Steven\u0026#34;], hasDriverLicense: true, calcAge: function (birthYear) { return 2037 - birthYear; }, }; 如何调用？\n1 2 3 console.log(jonas.calcAge(2004)); console.log(jonas[\u0026#34;calcAge\u0026#34;](2004)); console.log(jonas[\u0026#34;calcAge\u0026#34;](jonas.birthYear)); 在成员函数中使用this 1 2 3 4 5 6 7 8 9 10 11 12 const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, birthYear: 2004, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;Bob\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Steven\u0026#34;], hasDriverLicense: true, calcAge: function () { return 2037 - this.birthYear; }, }; 调用\n1 console.log(jonas.calcAge()); 方式3：函数返回一个新建的成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 const jonas = { firstName: \u0026#34;Jonas\u0026#34;, lastName: \u0026#34;Schmedtmann\u0026#34;, birthYear: 2004, job: \u0026#34;teacher\u0026#34;, friends: [\u0026#34;Bob\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Steven\u0026#34;], hasDriverLicense: true, calcAge: function () { this.age = 2037 - this.birthYear; return this.age; }, }; 二、HTML+CSS 1、软件配置HTML+CSS 装插件 prettier 当你保存时，自动格式化代码 颜色主题 One Monokai 设置 default format 设置成prettier\nformat on save 勾上复选框\nauto save 自动保存\n每次tab的空格数\n2、基本标签 软件常用快捷键 ctrl+d\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n一、Linux初始 1、历史 1.1 计算机的历史 时代背景\n1946年2月14号 \u0026ndash; 埃尼阿克 计算机导弹的弹轨迹的（军工） \u0026mdash;\u0026gt; 民用领域 \u0026mdash; \u0026gt; 诞生大量的企业（IBM、苹果、Intel等） ​ \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;把赚的钱投入到\u0026mdash;\u0026mdash;\u0026mdash;-【硅谷模式】\n计算机发展\n硬件方面（早期计算机体积大，价格贵） 大型计算机。IBM 小型化，桌面化发展。苹果，微软，intel等 \u0026mdash;-\u0026gt;智能手机 \u0026mdash;-\u0026gt;现在 软件方面 操作系统 1.2 操作系统的历史 诞生的背景\n随着计算机越来越复杂，在上面并行跑的任务越来越多\n所以必须让操作系统可以自动化地处理各种各样的任务\n同时计算机不仅仅可以做计算任务，还可以做数据保存等更复杂的任务\n这个时候就必须要求有新的一套系统，能把文件进行保存\n计算机在发展的过程中，各种任务都在跑，都要消耗内存\n所以必须把内存管理起来\n后来也必须外接各种硬件设备，比如话筒，键盘，显示器，鼠标，摄像头，外设等\n操作系统的发展\nUnix Ken Thompson用汇编语言编写Unix Dennis Ritchie 发明了C语言 他们两使用C语言重构Unix macOS ，windows+intel 计算机+操作系统 进入校园\n1991年，Linus Torvalds参加GUN计划，贡献Linux的Kernel内核 Linux的含义：Linux Is Not Unix 2、引入Linux 2.1 Linux特点 开源\n源代码是公开的，获取Linux源码\n评价一款操作系统好：稳定的，安全的，高效的\n开源vs闭源\n开源\u0026ndash;\u0026gt;被更多人看到\u0026ndash;\u0026gt;问题就能被更多人发现\u0026ndash;\u0026gt;解决问题，并且人和人之间没有利益冲突\n因此，开源的项目 稳定性，安全性，高效性都更高一些\n闭源\n解决问题效率低，解决方案不一定优质\n命令行+图形界面\n2.2应用场景 企业\n嵌入式\n计算或存储平台\n设备手机，平板，智能电视\n车载系统\n​\n2.3版本 技术线\nLinux内核的版本 2.6.32 5.10.xx 3.10.xx\n主版本号.次版本号.修正次数\n次版本号为偶数：稳定发布版 次版本为奇数：测试版\n商业产品线\nubuntu，centos，debian，redhat，fedora等 2.4 安装问题 双系统（不推荐）\n安装虚拟机\n云服务器\n推荐 云服务器 或者 轻量级应用服务器\ncentos7.6/ 7.8/7.9\n安装云服务器的细节\n记住你的公网IP 地方：就近原则 root重置密码 3、XShell基本操作 XShell是一款可以远程登录云服务器的软件\na. 怎么登录？xshell ==ssh root@你的公网IP==，然后会弹出对话框点接受，然后输密码\n输入uname -r 能看到对应的Linux版本号，就装好了\nb. 进入全屏 alt+enter全屏，重复该快捷键退出全屏\nc. 新建用户 \u0026ndash; 云服务器的其它办法 Linux是一款多用户操作系统\n[root@bite-alicloud ~]# adduser zhangsan 新建一个用户\n[root@bite-alicloud ~]# passwd zhangsan 给新建的用户设置密码(不会显示)\n[root@bite-alicloud ~]# userdel -r zhangsan 删除用户\nd. 查看 Linux 主机 ip 在终端下敲 ifconfig 指令, 查看到 ip 地址.\ne. 使用 XShell 登陆主机 在 XShell 终端下敲 ssh [ip]\nf. XShell 下的复制粘贴 复制: ctrl + insert (有些同学的 insert 需要配合 fn 来按)\n粘贴: shift + insert\n4、(穿插)Linux用户管理，见一见Linux能干什么 LInux可以用指令完成各种任务\n查进程、文本过滤、写C/C++代码\u0026hellip;\n可以在windows当中，用我们自己写的程序，以Linux作为服务器，把我们的数据\n直接推送给Linux\n用window的cmd也可以远程登录Liunx\n输入ssh root@你的公网IP回车，要输密码\n手机下一个登录终端的软件就也可以登Linux\nlogout退出登录\n二、Linux基础指令 1、指令 1.1 快速6~7个指令 pwd 直接查看当前用户在==首次登录==时，在Linux系统，==默认所处的路径==\n​\nwhoami\n==查看当前Linux所使用的用户是谁==（账号名称）\n​\nmkdir 加目录/文件夹名称\n==mkdir 创建一个目录/文件夹==，例如：创建一个目录/文件夹名字叫114\n​\nls\n==ls 显示当前路径下，文件名称==\n​\nrm -rf 加目录/文件夹名\n==删除文件夹== rm就是remove的意思，r是递归的首字母，f是force强制的首字母\n​\ncd 目录名\n==cd 进入一个目录里面==\n​\ntouch 文件名.文件后缀名\n==touch新建一个文件==\n​\nrm 文件名.文件后缀名\n==rm 删除文件==，rm就是remove的意思\n​\n按下回车后，会问我们是否要移除文件，输入y或者n\n以输入y为例：\n​\n==mv改文件名==\nmv test.c code.c\n表示将文件名test.c改为code.c\n1.2 详细学习一个一个的指令 1. ls指令 ls 显示当前路径下，文件名称。pwd 查看当前路径\n当前路径下，默认是空的，我们可以使用touch创建一个文件\n还可以使用 mkdir 创建一个目录/文件\nls 可以理解成list的意思，默认显示当前路径下的所有普通文件和子目录\n普通文件\n目录文件\nls 查看文件的文件名，文件名不是文件的内容，是文件的属性\n​\nls -l 显示当前目录下，更详细的文件属性信息\nls -a 显示隐藏文件\n==Linux中的选项是可以组合传入的，也可以分开传入==\nls -l -a 效果和 ls -la 还有 ls -al 相同\na可以理解成all的意思\nLinux中，以点.开头的目录/文件就是隐藏文件\n默认我们直接ls 或ls -l 是无法显示隐藏文件的，但如果我们带上a也就是 ls -al 就可以显示隐藏文件了\n我们自己也可以创建隐藏目录/文件，只要文件名以点.开头就行了。\n例如 touch .readme.txt 和 mkdir .youcanseeme\nls / 查看根目录下的文件\nls /root 指定查看root目录下的文件\nls -ld /root 查root这个目录本身，而不是进入到这个目录，把这个目录里面的内容查出来\n**ls -ld ** 查看目录本身\n2. pwd指令 可以理解成 process work directory，表示当前用户所处的路径\n在windows中也是以路径的方式来标识的\nwindows中反斜杠\\ ， Linux中的斜杠/叫路径分隔符\n两个路径分隔符之间的，一定是一个目录/文件夹 末端文件也可能是一个目录或者是普通文件 最开始的/或\\叫根目录\n特定用户的家目录\nroot用户下：\n普通用户下：\nLinux是一款多用户操作系统，可以创建多个用户，我们新建的用户都在home目录下\nhome目录：保存用户私有信息的目录，默认登录的时候，所处的路径\n我们可以查看有多少普通用户ls /home\n3. cd指令 cd / 切换到根目录\ncd /root/114 切换到114目录下\ncd.. 回退到上一级\ncd ~ 直接进入指定用户的所对应的家目录\nroot用户的家目录就是/root\n普通用户的家目录就是/home/用户名\ncd - 切换到最近的一次路径\n4. touch指令 touch最常用的两个功能：更改时间，创建文件\ntouch 一个文件名后，这个文件的时间就改变了，也就是时间更新了\nstat 文件名可以查看一个文件的详细信息\nACM时间\nAccess（访问时间）、Modify（修改时间）和 Change（改变时间）。\n5. mkdir指令 mkdir可以理解成make directory\nmkdir默认只能创建一个空目录/文件夹，不支持一次创建一个路径\n创建一个路径的方法：\n方法一：mkdir创建一个文件，然后cd进去，再mkdir\n方法二：mkdir -p a/b/c/d表示创建一个路径a/b/c/d\n6. rmdir指令 \u0026amp;\u0026amp; rm指令 rmdir 指定目录 删除指定的空目录\n那我们应该如何删除不为空的目录呢？\nLinux中的目录结构是多叉树结构，并且Linux中所有的目录结构是递归式定义的\n所以我们删除的指令要带上r，r就是递归的意思 。rm -r\n但是在root用户下，我们删除目录它会一直问我们是否要删除\n如果我们希望强制删除，就还要带上f，f就是force强制的意思\nrm -rf\n如何删除指定的文件呢？\nrm 文件名\n我们发现它也要问我们是否删除，所以我们同样可以加上f选项来强制删除该文件\nrm -f 文件名\nrm -rf /\n删除整个系统，可以在云服务器上重装\nrm * -rf 删除当前目录下的所有\n7. man指令 man ls查 ls 指令的使用，q 退出\nman pwd man touch man rm man printf等\nprintf是linux的指令\nman 3 printfman指令还可以查C语言相关的接口\nq退出\n上下键翻页\n/return val 回车，定位到函数返回值的说明\nman 2 fork查系统调用的接口\nman依次按照这9个章节来查，哪一个先查的，就不往后查了\n其中1号为默认手册，查的是可执行程序或命令行的命令\n2号手册查的是系统调用（由内核提供的函数）\n3号手册是查函数调用，一般提供的程序的库\n安装man\nyum install -y man-pages\n8. cp指令-拷贝 拷贝文件 cp src dst\ncp 要拷贝的文件 拷贝到哪里\n拷贝目录cp -rf src_dir dst_dir\n==如果要拷贝目录，目录是递归的，所以要使用 r== ，同时要拷贝的目录及其子文件，有可能在目标路径下已经存在了，所以我们加上 f 强制删除\n​\n拷贝到的路径指定了新的名称cp src dst_dir/新的名称\n如果拷贝到的路径如果指定了新的名称，那么就会创建\n9. mv指令-剪切/重命名 mv src dst_dir移动文件\nmv指令可以用来移动文件，或给文件重命名。mv就是move\n指令举例 含义 将log.txt移动到上级目录 将test.c重命名为code.c 把code.c移动到上级目录，并改名为myyyycode.c 10. 查看文件的内容 cat指令-查看小文件 打印文件的内容 cat 文件名.文件后缀\ncat -n 文件名.后缀打印时带上行号\ncat -n -s 文件名.后缀名 ==-s 表示不输出多行空行==（合并空行），\n如果文件内容中有连续的多个空行，那么就会把它压缩成一行\ntac指令 tac -n 文件名.文件后缀 将文本内容反向输出\n总结\ncat正向打印，tac反向打印\n作用\n将Linux当中的一些小文件/.c/.cpp/.conf 打印出来，方便用户查看\nmore指令-查看大文件 cat指令比较适合查看较小的文件，原因是如果一个文件里的内容很多，使用cat就会刷屏。\nmore指令more 选项 文件.后缀打印满屏幕后，就不再继续往下显示，如果想看下一行就回车\n**缺点：**more命令无法上下翻页，只能回车往下翻\nless指令 - 【推荐】可以用来查日志 less 选项 文件.后缀\nless指令可以使用上下光标实现上翻和下翻\n总结\nless指令可以查看文本，上下翻，q退出，==/ 搜索==，n查看下一个匹配项\nhead指令-查看指定行数的内容 head -n 文件名.后缀名显示文件指定行数的内容，从开头开始\n默认显示前10行，可以自己指定数字来代替n\ntail指令 tail -n 文件名.后缀名显示文件尾部指定行的内容\n默认显示后10行数据\n如何查看大文件任意区间的文本内容 例如取行数在[2000,2020]之间的内容\n**方式一：**通过临时文件\n1 2 head -2020 log.txt \u0026gt; temp 拿到前2020行的内容，放到临时文件 tail -21 temp 取临时文件的后20行数据 **方式二：**利用管道\n使用管道，==前一个指令的结果通过管道给另一个指令作为输入==\n先取该文件的前2020行，把它作为输入，交给tail取后20行\n还可以将得到的内容逆向打印 ，还可以统计字符数wc(word count) ，l 是line\n表示按行统计\n1 head -2020 log.txt | tail -21 | tac | wc -l 11. 时间相关的指令 date 需求 指令 如果我们只想查看年 可以查看年和月，中间的-也可用其它符号 查看年月日 查看年月日时分秒 如果想在年月日后是==空格==然后时分秒，可以==使用反斜杠转义字符==再加空格\n除了月和日是小写，其它都是大写\n后面会学的\n时间戳 1970-1-1凌晨12:00累计到现在的秒数\nCal指令 cal显示日历\ncal -3显示前一个月，当前月和下一个月\ncal -y 年份显示指定年份的日历\ncal -j显示在当年中的第几天\n12. find命令【重要】 find查文件 find 目录 -name 文件在指定目录找名为XX的文件\nfind 目录 -name '*.c'表示找以.c结尾的文件\nfind ~ -name '*.txt'在当前目录下找以.txt结尾的文件\n-name表示按名字查\n*叫通配符\nfind也可以查指令\nfind /usr/bin/ -name ls\nfind /usr/bin/ -name pwd\nwhich和find指令的区别 find系统目录树直接查找，可以查任意文件（可以按照文件名，权限，文件大小等）\n所以可能会比较慢\nwhich只能用来查可执行程序，相当于限定在/usr/bin/路径下\nwhich命令相当于 find /usr/bin -name XXX\nwhereis指令 whereis指令不仅可以查到指令的路径，还会将普通文件的路径查出来\n13. grep指令-行文本进行过滤 grep 按照指定的模式对行文本进行过滤\ngrep '999' log.txt将log.txt中包含999的显示\ngrep \u0026quot;main\u0026quot; ./*同时grep指令也支持通配符，表示在当前路径下找\n常用的选项\n-n显示行号\ngrep -n \u0026quot;main\u0026quot; *.c将文件中包含main的，后缀为.c的显示，并带上行号\n-v反向匹配\ngrep -v \u0026quot;main\u0026quot; oper_tty.c将oper_tty.c中包含main的不显示\n-i忽略大小写\ngrep -i \u0026quot;main\u0026quot; oper_tty.c将oper_tty中包含main的无论大小写都显示（i是ignore的简写）\ngrep还可以查进程\n例如：ps ajx | grep corond查名字中含有corond的进程\n14.打包压缩 安装\nyum install -y zip\napt install -y zip\n14.1 打包压缩是什么 ​\t使用特定的算法，文件进行合并或者压缩，减少体积，\n​\t打包压缩作为一个整体\n14.2 为什么要打包压缩 ​\ta.文件体积减少，节省资源，磁盘空间，减少网络传输的成本 \u0026ndash; 压缩\n​\tb.多个文件转一个文件，可以提高文件传输的 容错性\n14.3 怎么打包压缩 zip/unzip 压缩的常用格式：.zip，.tgz\n打包压缩目录：zip -r test.zip test将test目录打包压缩为test.zip 打包压缩普通文件zip 文件名.zip 要压缩的文件 解压目录：unzip 文件名.zip 默认是解压到当前路径的，如果我们要解压到指定路径（-d）\nunzip test.zip -d ../lesson3表示将test.zip解压到上级路径的lesson3中\n14.4 实现windows和Linux机器互传 先要安装lrsz：yum install -y lrzsz\n发送到windows 指令sz test.zip表示将test.zip发送到我们的windows机器上\n会弹出叫我们选择路径，即你想把该文件放到windows哪个路径下\nLinux机器接收windows的文件，rz\n也可以直接将windows中的文件拖拽到Xshell中\n14.5实现Linux和Linux机器之间互传 scp test.tgz root@公网IP:路径\nscp远程拷贝\n15. tar指令 还有一种压缩文件.tar.gz\n打包压缩\ntar -czf 目标文件名.tgz 源文件名\nc表示create创建一个文件，z表示要进行压缩，f表示f后面紧跟的就是目标文件\n例如：tar -czf test.tgz test\n此外，-v选项会将打包压缩的过程显示：tar -cvzf test.tgz test\n解压\ntar -xzf test.tgz\nx是解压缩包的意思，z表示解压的的意思\n其它\n展现打包压缩的过程：-cvzf\n展示解包解压过程：-xvzf\n解压解包到指定路径下：tar -xvzf XXX.tgz -C 指定路径\nLinux和Linux机器之间互传\nscp test.tgz dyy@139.9.80.106:/home/dyy/114/lesson4/tar_test\nscp 远程拷贝 test.tgz 当前机器上的压缩文件 dyy@ 表示另一台机器的身份 139.9.80.106 另一台Linux机器的IP地址 :/home/dyy/114/lesson4/tar_test 表示拷贝到另一台机器上的哪个路径下 16.bc指令 bc是Linux下的一个命令行计算器，在bc命令下可以进行浮点数运算\nquit或ctrl+c退出\n应用场景：表达式是不能直接写入到显示器中的，而使用bc就可以\necho 1+2+3+4*8/9%10 | bc\n17. uname指令 uname -a查看当前Linux机器的所有详细信息\n内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称\nuname -r只查看内核版本和体系结构\nCentOS查看当前机器版本 cat /ect/redhat-release\nUbuntu的查看cat /etc/lsb*\n18. 重要热键 tab键，进行命令或路径的补齐 ctrl+c停止异常操作 上下键，可以翻阅历史命令 ctrl+r搜索历史命令，再按左右键就能得到该命令 Linux会记录历史命令\nhistory查看历史输过的指令\n19.关机 语法：shutdown 选项\n-h：将系统的服务停掉后，立即关机\n-r：在将系统的服务停掉之后就重新启动\n-t sec ：-t后面加秒数，即过XX秒后关机\n重启：reboot再回车\n2、基础知识 2.1 命令行 我们在命令行中执行命令时，可以单纯地执行一条指令，也可以指令+选项的形式\n来展示更多的功能 -+-+-+-+-+-+\n例如：\n再比如windows中的关机命令 shutdown -t -s 60 表示60秒后关机\n2.2 文件不等于文件的内容 文件不仅仅包含文件的内容。\n还包含文件名、文件的类型、文件的大小、文件的保存位置文件的修改时间，文件的修改权限等，这些都叫做文件的属性\n文件的属性也是数据。\n我们保存文件，不仅要将它文件的内容存储到内存中，也要将它文件的属性存储到计算机的磁盘中\n在新建文件时，只要是数据，就要被保存起来\n所以，即使我们新建了一个空的文件，它的大小为0，指的是文件的内容是空的，\n但是不代表它所占磁盘空间的大小为0\n对文件的操作：\n​\t**a.对文件内容的操作 **\n​\tb.对文件属性的操作\n2.3 隐藏文件 ==Linux中，以点.开头的目录/文件就是隐藏文件==\n默认我们直接ls 或ls -l 是无法显示隐藏文件的，但如果我们带上a也就是 ls -al 就可以显示隐藏文件了\n我们自己也可以创建隐藏目录/文件，只要文件名以点.开头就行了。\n例如： touch .readme.txt 和 mkdir .youcanseeme\n2.4 普通文件和目录文件 1. 目录在电脑里面相当于文件夹 windows中反斜杠\\ ， Linux中的斜杠/叫路径分隔符\n两个路径分隔符之间的，一定是一个目录/文件夹\n末端文件也可能是一个目录或者是普通文件\n​\n2.Linux中以d开头的叫目录，以-开头的叫普通文件 文本文件，二进制可执行程序，动静态库，视频，音频，图片\u0026hellip;等都叫普通文件\n==Liunx系统中，文件类型与文件后缀无关==。系统不等于gcc（软件），建议带上后缀\nfile 跟文件名 识别到准确的文件类型\n.和..都是目录 ..表示上一级路径，.表示当前路径 根目录的.和..都指向自己 cd ..表示切换到上一级\ncd 目录/文件名进入一个路径\ncd 跟一个完整的路径可以直接切换到该目录下\n例如：cd /root/114 表示切换到root路径下的114目录下\n3.根目录 我们可以使用cd ..回退到上一级，但也是不能无限回退的，但当我们一直回退到不能再回退时，发现此时我们是在/或\\路径下。\n==最开始的/或\\目录叫根目录==\nLinux的所有文件的系统结构是一个多叉树结构。\n它的非叶子结点一定是一个一个的目录，而它的叶子结点要么是空目录要么是普通文件\n访问一个文件\n前提：找到它（定位或找到任何一个文件的方式是通过路径），操作它\n==路径具有唯一性==（多叉树结构，每个子结点只有一个父节点，可以有多个子节点）\n**绝对路径：**从根目录开始定位文件的路径\n**相对路径：**以相对于我自己的当前路径为参照点，查找定位目标的路径\n如何选择？\n操作中一般使用：相对路径\n配置文件，系统级配置文件，可以采用绝对路径\n4、在任何一个目录中都有.和.. 无论是自己新建的目录还是系统自带的目录，里面都有.和..\n.和..都是目录 ..表示指向上一级的路径，.表示相当于指向自己的路径 根目录的..和.都指向自己 执行一个C程序：\n把一个程序运行起来，前提是先把文件添加到内存，而添加到内存之前要先找到它\n而我们默认，即便在当前路径下，我们也找不到它，所以我们./a.out\n因为.表示当前路径，所以./a.out意思就是执行当前路径下的 a.out\n除了这种方式外，我们还可以通过决对路径来执行程序。例如：/root/114/a.out\n2.5 tree命令 tree+指定目录，以树形结构，展示文件和目录结构\ntree 指定目录\ntree . 当前路径\ntree /从根目录开始，所有的Linux文件全部整理出来\n==命令行中，阻止非法或者刷屏操作，ctrl+c==\nLinux中tree命令默认是没有安装的，需要我们自己安装\nroot用户下\nCentOS输入：yum install -y tree\nUbuntu输入：apt install -y tree\n卸载：yum remove -y tree\n2.6 cp指令 ==Linux下，一切皆文件== \u0026mdash;\u0026ndash; 显示器就是文件\n打印到显示器-\u0026gt;显示器也是文件-\u0026gt;写入到显示器文件 从键盘读取数据-\u0026gt;键盘也是文件-\u0026gt;从键盘文件读取数据 2.6.1向文件中写入数据 ==echo指令==\necho指令可以将跟在echo后的内容当做字符串写入到显示器文件当中\n可以将echo后的内容用单引号或双引号括起来\n使用cat 文件名（包含后缀）就可以查看文件里的内容\necho 默认是向显示器文件写入，如果带上\u0026gt;就会向指定文件写入 -\u0026gt;重定向操作\n如果文件不存在，就新建。重定向操会将文件先清空再写入\n==\u0026gt;是输出重定向操作==\necho \u0026lsquo;内容\u0026rsquo; \u0026gt; 文件名.后缀名 ，那么就会向指定文件写入，如果文件不存在，就新建\n如果文件存在，就先将里面的内容清空，然后再写入\n如果直接\u0026gt;加文件名（带后缀名）\n\u0026gt;可以将文件里的内容清空 文件不存在，\u0026gt;可以新建文件 ==ls写入==\nls默认也是向显示器文件写入\n我们也可以使用\u0026gt;将其在其它文件中写入\n例如：ls -l \u0026gt; log.txt 就是把当前目录下文件的详细信息写入到log.txt文件中\n==\u0026gt;\u0026gt;追加重定向操作==\necho \u0026quot;要写入的内容\u0026quot; \u0026gt;\u0026gt; 文件名（带后缀的）就可以不清空就写入\n向指定的目标文件中，不断新增内容\n2.6.2向文件中读取数据 cat后面什么都不跟，默认从键盘中读，把从键盘中读到的内容打印到显示器上\n输入什么内容，他就打印什么内容，ctrl+c退出\ncat \u0026lt; 文件名.文件后缀 读取文件里的内容 -\u0026gt; ==\u0026lt;输入重定向==\n从log.txt里面读，把读到的内容打印到屏幕上\n2.6.3 终端文件 我们打开Linux，默认会显示一个黑框框，这个黑框框我们把它叫做终端\n==终端的本质是一个文件==\nls /dev/tty 终端文件\nls /dev/pts 远程登录对应的登录终端\n如果我们再打开一个Linux机器，此时我们在第一个Linux机器中输入ls -l /dev/pts\n就会发现多出了一个叫1的文件，也就是这代表我们新打开的Linux机器\n如果我们在第一个机器中向1中输入数据echo helloworld \u0026gt; /dev/pts/1\n就会发现在新机器中显示出来了\n第一个机器 新机器 我们再向0这个文件中输入，发现0就代表当前这个终端\n我们也可以在新打开的机器中向我们当前的这个机器写入数据\n总结\n我们的登录终端，在我们登录的时候，就会在/dev/pts这个目录下，形成一个以c开头\n文件，我们可以向该文件中写入数据（本质上就是向显示器上写）\nnano \u0026ndash; 文本编辑器\n​\tnano 文件名.文件后缀名就相当于打开了Linux下的记事本\n​\tctrl + x退出\n2.7 指令是什么 2.7.1 指令本质上就是程序 我们平时操作的指令都在 /usr/bin路径下。\nusr就是user用户的意思，bin就是binary二进制的意思\n我们可以只查其中的某个指令\n我们发现==指令本质上就是程序==\n所以我们既可以直接输入指令（比如 ls），也可以/usr/bin/ls来执行指令\n==指令就是Linux特定路径下的二进制文件==\n2.7.2 which命令 which命令可以帮我们快速找到指定的命令文件\n2.7.3 alias 对指定的命令和选项组合起别名 我们使用which命令找到 ls ，就会发现它上面多了一行\n如果我们直接执行ls 有些文件是不带颜色的\n如果我们执行/usr/bin/ls --color=auto就会发现选项带颜色了\nalias是别名的意思，我们可以把某些指令取别名，然后用别名操作\n我们既可以用ll也可以用ls的原因就是ll是ls -l的别名\n2.8 日志的介绍 什么是日志？\n在程序正常工作之前，程序员自己需要打开日志文件，在程序运行期间，\n你以前写代码调试时，在代码中所有出现printf的地方，都要让它转而向\n文件里写入，让程序的执行痕迹写到日志里。这个文件就叫日志文件\n这个行为就叫写日志\n日志的基本信息\n报错还是警告，报错的内容是什么，警告的内容是什么，时间\n查看日志\n2.9 时间戳 时间戳是指1970年1月1日凌晨12点到现在的秒数\nC语言中time返回的就是时间戳\n格式化显示时间戳\n@后面跟时间戳\n@0 时显示的是1970-1-1的8点而不是凌晨12点原因是系统里把时区转过来了\n3、shell命令以及运行原理 广义上操作系统是：内核+外壳程序\nLinux严格意义上说的是一个操作系统，我们称之为“核心（kernel）“ ，但我们一般用户，==不能直接使用kernel==。而是==通过kernel的“外壳”程序==，也就是所谓的==shell==，来与kernel沟通\n外壳程序\n外界输入指令 \u0026mdash;\u0026gt; 外壳程序解析 \u0026mdash;如果合法\u0026ndash;\u0026gt; 内核执行\n外界 \u0026lt;\u0026mdash;\u0026mdash; 外壳程序显示 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n这个外壳程序 Linux下叫：命令行解释器\n​\twindows下叫：图像化界面\nshell外壳就是包裹在操作系统外面的一层软件层\n核心工作就是命令行解析和保护内核\nshell会进行创建子进程的方式进行命令解析\n每一个用户在登录时，系统都会为这个用户专门分配一个bash\n外壳程序：ps ajx | grep bash\n三、Linux权限 1. 什么是权限 a.权限是限制人的。人 = 真实的人+身份角色\nb.目标事物的属性也会影响权限\n==权限=角色+事物属性==\n权限最终就是影响你能还是不能做一件事情\n2.认识人，人切换 2.1用户 root：超级管理员，几乎不受权限的约束\n普通用户：Linux使用者，受权限的约束\n2.2切换用户的方式 普通用户切换到管理员用户：su\n需要输入root密码，密码不会显示出来\n退回到普通用户：ctrl+d 或exit\n切换到其它普通用户su 用户名\n以root的身份重新登录su -\n**注意：**普通人之间切换，需要输入对方的密码；root可以切换成为任何人\n2.3如何在不切换身份的情况下，执行更高权限命令呢？(场景) 指令提权\n只要在要执行的指令前加上sudo，就可以以超级用户的身份来执行后续的命令\n输密码时输入普通用户的密码\nsudoers 类似一张用户白名单\n场景\n安装软件时，在Linux下安装软件只能在root身份下安\n3. 文件属性，文件的权限属性，Linux角色划分 3.1 文件属性 字符设备文件：显示器，键盘\n块设备文件：磁盘\n​\t管道文件：分为匿名管道和有名管道（用来进程间通信）\n​\t创建管道文件\n​\t管道文件\n链接文件：\n​\t3.3Linux中的角色划分 Linux中角色分三类\n文件拥有者\n一个文件是谁的，谁就是拥有者\n文件所属组\n如果没有所属组，那么一个文件要么是拥有者，要么是other，我想要让某个人看该文件，，就只能将权限放开至other，那么我不想给某些人看到该文件也不行。\n而有了所属组后，你就可以只让那个组里的人看该文件\nother\n既不是拥有者，也不是所属组\n人 = 真实身份 + 身份角色\n具体用户：root，普通账号\n角色：拥有者，所属组，other\n具体的人可以扮演某种角色\n3.2 文件权限属性 r 可读，w 可写，x 可执行\n4.操作：有权限VS无权限 如何修改权限？ 取消权限\n改为不能读\nchmode u-w 文件 文件不能写\nchmode u-x 文件改为文件不可执行\n增加权限\nchmode u+r 文件改为可读\nchmode u+w 文件改为可写\nchmode u+x 文件改为可执行\n改拥有者权限 u\n改所属组的权限，就将u换成g\n改other的权限，就将u换成o\n给所有人加上某权限，就将u换成a\n结论：\n只有文件的==拥有者==和==root==可以修改文件的权限\nLinux下能执行 = 真的是一个可执行文件 + 可执行权限\nuser,group,other和我自己进行身份对比的时候，依次只对比一次\n如果你既是拥有者又是拥有组，那么匹配到拥有者后就不再匹配，也就是就算拥有者没有读或写或可执行而拥有者有，你也是不能读或写的\n使用八进制增加权限 r/- w/- x/- 三个分别为读，写，可执行，-表示没有该权限\n我们可以用0来表示没有该权限，1表示有该权限\n那么可读可写可执行就可以表示为111也就是7\n如果我们要设置拥有者，所属组，other的权限分别为\n​\trwx rw- r\u0026ndash;\n用二进制表示 111 110 100\n也就是 7 6 4\n那么我们就可以用 chmod 764 text.txt 指令修改\n同样，如果我们希望给所有角色加上所有权限：chmod 777 text.txt\n​\t给所有角色去掉所有权限：chmod 000 text.txt\n拥有者和所属组可读可写，other只读 chmod 664 test.txt\n修改角色 修改拥有者chown 新拥有者 要修改的文件不能直接修改拥有者\n只有超级用户或者指定提权\n修改所属组chgrp 新拥有者 要修改的文件\n同时更改拥有者和所属组\n对于一个文件，如果没有r权限，用任何工具都不能查看文件的内容。权限限制的是人\n5.关于权限的三个问题 1.目录权限 如果我要==进入一个目录==，需要什么权限？==x权限==\n==r==对目录是什么意思？==有无权限查看指定目录下的文件信息==\n![73140979480](assets/1731409794803.png) ==w==对于目录？==有无权限在指定目录内部，新建文件，删除，修改文件名等修改===\n==文件操作==，都不行\n​\n2. 缺省权限 知识点\n普通文件，起始权限666；目录文件，起始权限777\numask的权限掩码\n最终权限（缺省权限）：664,775\n结论：\n==最终权限（默认）= 起始权限 \u0026amp; （~umask）==\n只看后3位，实际是000 000 010\n修改权限掩码，达到修改Linux文件缺省权限的问题\n修改成777umask 777那么此时umask按位取反结果为全0，任何数和0按位与\n结果都为0。那么默认创建的文件权限是全是-\n修改成0umask 0那么此时umask按位取反结果为全1,任何数和1按位与结果都是\n它本身。此时创建文件的默认权限就是666和777\n3.沾滞位 1. Linux多用户下，对于文件的访问，是隔离的\n2. 需求：我们想让Linux下不同的账号用户，共享文件呢？\n共享文件不能在任何一个普通账号的家目录里面，只能在其它目录下，比如根目录下\n但是根目录也是一个目录，所以新建时需要以超级用户身份来创建sudo，或者root用户来新建\n默认下other是没有创建文件的权限的，所以需要sudo添加w\n3. 问题：我们想既共享文件，同时other不能随便删除这个文件\n我们想共享文件，也就是需要让在根目录下建的目录的other的w权限放开，\n这样other就可以在这个共享目录中新建文件了，我们可以修改共享目录文件中新建的文件的属性也就是可以让拥有者和所属组的权限是可读可写可执行，other是不能读不能写不能执行\n但存在一个问题，在目录中，==创建删除修改一个文件是由目录的w权限决定的，与目标文件无关==，也就是如果我们将共享目录的w权限放开了，那么other就可以删除我们共享目录里的文件了\n添加粘滞位：sudo chmod +t /目录名/\n任何用户，在设置了粘滞位的目录下\na. 自己只能删除自己的目录，其他人无法删除\nb. root无视\nc. 粘滞位，只能给目录设置，不需要给普通文件设置\nLinux下默认给tmp目录加了粘滞位\n0.笔记 1.xshell安装和卸载 1.1安装 https://www.netsarang.com/zh/free-for-home-school/\n点击下载即可\n下载完后，双击.exe文件，一直下一步，改安装路径。\n安装好后，打开XShell，第一次打开需要输用户名和邮箱，然后xshell会往你的邮箱发\n认证链接，点击认证链接后就注册成功了\n关掉其它界面，在下面的界面中输入ssh root@你的公网IP回车后输入你的密码\n1.2卸载 在控制面板中选择卸载程序，然后将xshell卸载即可\n2.xshell免密码登录 首先添加一台机器\n然后会弹出对话框\n查看我们添加的机器\n然后可以点击连接\n第一次要求输入用户名，输入后我们点击记住用户名，然后输密码\n免密码登录\n属性中有一个身份验证，输入用户名和密码点击确定后，以后只需要双击我们的机器就\n可以直接登录我们的机器，不用输密码了\n3. 改主题 a. b.把配色方案勾上\nc.然后再点击下图中的图标就可以改主题了\n4. 新建用户及用新建的用户登录 a.新建用户及删除 [root@bite-alicloud ~]# adduser zhangsan 新建一个用户\n[root@bite-alicloud ~]# passwd zhangsan 给新建的用户设置密码(不会显示)\n[root@bite-alicloud ~]# userdel -r zhangsan 删除用户\nb.怎么登录该用户呢？ 首先，需要把xshell关闭，然后将弹出的对话框点叉\n然后如果是下面这个界面\n那么输入你的用户名@你的公网IP回车然后输入密码可以了\n如果是下面这个界面\n那么就需要输入ssh 你的用户名@你的公网IP\n5. 在xshell查看公网IP 右击我们的Linux机器，选择属性，就可以看到我们的公网IP了\n6.登录的状态下，切换Linux机器 就可以打开下面的界面\nlogout可以退出当前账号，再ssh root@你的公网IP\n7.Linux下安装应用 Linux中tree命令默认是没有安装的，需要我们自己安装\nroot用户下\nCentOS输入：yum install -y tree\nUbuntu输入：apt install -y tree\n卸载：yum remove -y tree\n8.伪造10万行代码 9.向自己新打开的另一台Linux机器中写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;/dev/pts/1\u0026#34;, \u0026#34;w\u0026#34;); if(fp == NULL) { perror(\u0026#34;fopen\u0026#34;); return 1; } char buffer[1024]; while(1) { printf(\u0026#34;Enter# \u0026#34;); scanf(\u0026#34;%s\u0026#34;, buffer); fputs(buffer, fp); fflush(fp); } fclose(fp); return 0; } 然后编译运行\n就可以写入了（ctrl+c退出）\n对应另一台机器\n10. Linux下的退出 nano text.txt后使用contrl+x退出\nvim test.txt 中使用 esc+:wq 退出\n11.xshell看Linux版本 centos下\ncat /etc/redhat-release\nubuntu下\ncat /etc/lsb*\n12.看Linux的内核版本 uname -r\n13.nano的使用 nano \u0026ndash; 文本编辑器\nnano 文件名.文件后缀名就相当于打开了Linux下的记事本\n退出：ctrl+x，y 回车\n指令 说明 shutdown -h now 立刻进行关机 shudown -h 1 “hello，1分钟后会关机了” shutdown -r now 现在重新启动计算机 halt 关机，作用和上面一样 reboot 现在重新启动计算机 sync 把内存的数据同步到磁盘 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n一、Linux环境基础开发工具使用 1. 软件包管理器 1.1什么是软件包管理器 ==软件包==相当于 app\n==软件包管理器==相当于应用商店\n我的服务器怎么知道，去哪里找软件包？\nLinux机器上，有对应的给yum/apt提供的配置文件！\n记录下来了对应软件包服务器的url或者ip地址\n是在我们的云服务器或操作系统发布的时候和操作系统一起给我们发布出来的\ncentos、ubuntu\u0026hellip;等操作系统都是国外的人做的\n1.软件包服务器在国外，\n2.配置文件里写的都是国外的云服务器\n镜像\n国内的人将国外的软件包服务器里的内容拷贝到国内的服务器上\n同时再给我们国内的用户提供能下载国内的软件包服务器的配置文件\n软件源\n在我们的云服务器上配置对应的这种配置文件\n我们再把软件源由国外的替换为国内的\n云服务器：首先需要将国外的软件包服务器里的软件拷贝，\n​\t然后将国外的配置文件替换为国内的配置文件\n​\t所以我们使用的时候，内置的配置文件已经是国内的了\n1.2 yum 查软件是否存在\n看在软件包服务器中是否存在 yum list可以罗列出我们当前centos所支持的所有软件\n就是将远端的软件包服务器里有的软件的名称和相关的信息全部拉到本地，\n形成一个清单，让我们看到\n我们利用grep查看该清单名字中包含sl的软件\n.x86_64表示该代码是在64位机器下编译的，只能在64位环境下跑\nel7就是centos7，@epel相当于苹果应用商店、小米应用商店等\n看在我们自己的云服务器上是否存在，which 软件名 sl我的云服务器上已经安装了\n​\n安装软件，需要以管理员的身份（安装软件安装到usr/bin路径下）\n​\n安装软件的本质就是将软件的二进制文件下载，然后拷贝到系统指令的目录下\n所以有权限约束，使用root/sudo yum/apt提权\n​\nLinux下安装的软件，是root安装的，其它人都能用能看\nLinux一般而言，软件只要安装一次，都能用。\n除了root外，其他人都是以other的身份进行使用软件的\n安装gcc:\n1 2 3 4 5 # Centos $ sudo yum install -y lrzsz # Ubuntu $ sudo apt install -y lrzsz 总结:\ncentos下\n以超级用户身份sudo\n查软件是否存在 yum list | grep xxx\n安装 yum install (-y) xxxx\n卸载 yum remove (-y) xxxx\n-y表示强制卸载\nubuntu下\n查看ubuntu的机器：cat /etc/lsb*\napt search sl\nsudo apt install -y sl\nsudo apt remove -y sl\nkillall yum\n1.3 安装源 yum源配置文件所在的路径\n有多个\nubuntu下在ls /etc/apt/sources.list下\nbase是标准源，epel就是扩展软件源，扩展软件源可能不止一个\n安装扩展软件源：\n如何切换软件源？\n本质就是更改配置文件，使用AI提供操作清单\nwget www.baidu.com我们就得到了一个网页，默认是index.html\n我们cat index.html就得到了百度的首页\n好玩的命令：https://blog.csdn.net/xiaoxiaosutang/article/details/141053674\n2. 编辑器vim 2.1 vim的介绍 1.vim是一个专注的编辑器\n2.多模式的编辑器\n2.1.1 见一见vim vim本质上也是一条命令，是在Linux磁盘中特定的文件系统里，/usr/bin/下的一个命令\n我们先用vim来编写一个hello world\n可以先创建一个文件，再用vim打开\n默认打开是命令模式，输入i后可以编辑\n如何退出vim？\n直接输入vim时使用 shift+冒号+q退出，\n写了代码后 shift+冒号+wq，如果是插入模式下需要先按esc 退回到命令模式\n如果你没有做任何修改，只是查看了文件并想退出： 确保你处于命令模式（按 Esc 键可以确保你处于命令模式）。 输入 :q 然后按 Enter 键。这将退出 Vim，且不会保存任何修改。 如果你做了修改并希望保存更改然后退出： 确保你处于命令模式。 输入 :wq 然后按 Enter 键。这将写入（保存）文件并退出 Vim。 或者，你可以先输入 :w 然后按 Enter 键来保存文件，之后输入 :q 再按 Enter 键来退出。 如果你做了修改但不希望保存更改并想退出： 确保你处于命令模式。 输入 :q! 然后按 Enter 键。这将强制退出 Vim，且不保存任何修改。 如果你处于插入模式（正在输入文本），并且想退出： 首先按 Esc 键回到命令模式。 然后按照上述步骤之一退出 Vim。 gcc编译，形成a.out\nb.vim多模式 5模式 3种核心 命令模式\n默认打开vim就是命令模式，在该模式下，vim会把我们从键盘上输入的都当成是命令\n目的：提高编辑效率，vim下yy复制粘贴\n插入模式\n正常的编写模式，还可以复制，粘贴，剪切等\n底行模式\n显示行号，想退出vim，保存\u0026hellip;\nset nu调出行号\nset nonu把行号去掉\nwq退出（w就是write写，q就是退出）\n命令模式切换到插入模式:i\n命令模式切换到底行模式：shift+冒号\n底行模式切换到命令模式：Esc\n插入模式切换到命令模式Esc\n总结：\n默认打开是命令模式 命令模式是vim的核心和精华 光标定位，vim下一般不使用鼠标 2.1.2 命令模式 作用 命令 光标定位到第一行 gg 光标定位到文本末尾行 shift + g = G 光标定位到任意一行 n+gg 、n+shift+g 光标定位到行尾 shift+4/$ 光标定位到行首 shift+6/^ ：h左，l右，j(jump)下，k(king)上 h、j、k、l 以单词为单位，向前或向后移动 n+ w/b 复制光标所在行 yy 复制多少行 n+yy 粘贴到当前行的下一行：p\n粘贴多少行n+p\n==撤销：u==\n==反撤销：ctrl+r==\nn+dd剪切或删除，dd+p就是剪切+粘贴\nn + x/X删除光标后/前的字符\nshift+~快速大小写转换\nn + r小范围文本替换，将n个字符替换为输入的字符\n==shift+r = R进入替换模式==，退出替换模式esc\n在命令模式下退出vimshift+zz\n2.1.3 插入模式 i ：进入插入模式\na：进入插入模式并光标向后移动一个\no：进入插入模式并另起一行\n!xxxx：可以在不退出vim的情况下执行命令\n2.1.4 底行模式 命令模式进入底行模式，shift+冒号\nwq保存并退出，w!强制保存，q!强制退出，wq!强制保存退出\nset nu设置行号，set nonu不显示行号\n/xxx 搜索 xxx ，n搜索下一个匹配项\n!+指令，比如!ls，就可以执行ls命令，然后按任意键回去\nvs xxx可以实现分屏，例如在vim code.c中输入vs code.h就可以实现下面的效果\n注意：光标在哪，编辑、保存等就在哪\nctrl+www光标移动到另一个屏幕\n要查看你的所有模式：打开 vim，底⾏模式直接输⼊ help vim-modes 2.1.5 补充 批量化注释：ctrl+v \u0026ndash;\u0026gt; hjkl选择区域\u0026ndash;\u0026gt;shift+i 输入双斜杠==（也可以插入其它的文字）==\u0026ndash;\u0026gt;Esc\nctrl+v进入视图模式\nshift+i直接切换到插入模式\n全部注释：gg定位到开头\u0026mdash;\u0026gt;ctrl+v\u0026mdash;-\u0026gt;shift+g定位到结尾\u0026mdash;\u0026gt;shift+i后输入//\u0026mdash;\u0026gt;再Esc\n批量化去注释：ctrl+v\u0026mdash;\u0026gt;hjkl选择区域（要将两个斜杠都选择）\u0026ndash;\u0026gt;d\n批量替换：%s/printf/print/g 将所有的printf替换成print，g - global的意思\n如果代码报错，指定行确定，可以使用vim查看时加上+报错的行那么打开vim光标就在指定行\n感叹号+之前执行过的命令首字母，就可以快速执行\n2.2vim的配置 如果希望对当前的用户做配置\n进入到当前用户的家目录cd ~（家目录里一般会有一些隐藏文件）\n在家目录创建一个.vimrc的文件\n打开.vimrc文件vim .vimrc\n添加配置\n设置语法⾼亮: syntax on\n显示行号: set nu\n设置缩进的空格数为4: set shiftwidth=4\n如果是从网上下vim的插件，需要在当前用户的家目录里建一个.vim的文件，将下载的插件\n放到里面并安装，然后在.vimrc文件中引用.vim里的插件\nLinux是一款多用户的操作系统，改自己用户的vim配置是在当前用户的家目录改的，别的用户\n的vim配置不会改，/etc/vimrc是全局的但是建议只改当前用户的，不改全局的\n自动化配置，在除了root用户以外的家目录下执行\ncurl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh \u0026amp;\u0026amp; bash ./install.sh\n3.编译器gcc/g++ 3.1 程序翻译 \u0026mdash; gcc/g++编译选项 gcc和g++都叫做编译器，主要工作就是将我们写的C/C++代码翻译成可执行二进制程序\ngcc只用来编译C g++编译C/C++ g++ code.cpp -std=c++11\n预处理（进行宏替换/去注释/条件编译/头文件展开等) ，还是C语言\n-E表示从现在开始，进行程序的翻译，一旦预处理做完，就停下来\n如果不带-o，会把预处理的结果打印到显示器上。\n所以code.i保存的就是code.c预处理后的结果\n-o 表明-o后面的文件名称 -E 表示从现在开始，进行程序的翻译，一旦预处理做完，就停下来 头文件展开：将要包含的头文件相关内容拷贝到源文件\n​\t因为头文件里可能还包含其它头文件，所以展开类似于递归式展开\n​\t先追到根上的头文件，然后依次拷贝，最后将需要的头文件内容\n​\t拷贝到可执行程序里，最终编译只编译源文件\nLinux中C语言标准头文件在该路径下/usr/include/\n函数的实现在库里\n​\n编译（C语言\u0026ndash;\u0026gt;汇编)\ngcc -S code.i -o code.s：-S表示开始进行程序翻译，编译做完，形成汇编，就停下来\n​\n汇编（生成机器可识别代码即汇编\u0026mdash;\u0026gt;二进制）\ngcc -c code.s -o code.o可重定位目标二进制文件，无法执行\n-c表示开始进行程序的翻译，编译做完，形成汇编，就停下来\n​\n连接（生成可执行文件或库文件)\n将我们的.o文件和库文件进行连接，形成可执行文件\n总结：\n1 2 1. -E -S -c 预处理，编译，汇编 2. .i .s .o 一些镜像文件的后缀 补充：反汇编指令\n3.2 为什么要编译，为什么汇编、编译器自举，理解条件编译 为什么要编译，汇编 早期：纸带打孔的方式编程 \u0026ndash; 二进制编程\n汇编语言 \u0026mdash; 编译器就要诞生了\n面向过程，面向对象的语言\n为什么需要把我们用其他语言写的代码转成汇编？\n**减少语言开发的成本。**因为汇编语言出现的比较早，已经有编译器可以将汇编语言翻译成\n二进制语言，所以我们只需要考虑把C/C++等语言翻译成汇编语言。\n编译器自举 先有语言，还是先有编译器？\n先有编译器，二进制的编译器，能编译汇编语言所写的软件，编译器自己是软件\n我们可以用汇编语言重构编译器，这个编译器软件先经过二进制编译器，然后形成\n用汇编写的编译器。\n此后，我们就不需要使用二进制编译器了，而是可以使用用汇编写的编译器\n条件编译 版本管理，通过条件编译形成不同版本\n3.3动静态库和静态链接\u0026mdash;操作部分 源文件经过预处理、编译、汇编后形成的二进制文件是不可执行的，\n还需要和库文件进行连接，形成可执行文件\n库分为：静态库，动态库\nLinux：动态库（libXXX.so），静态库（libXXX.a）\n去掉前缀lib，去掉后缀.so .a ，剩下的就是库的名称。\n例如：libXXX.so 那么库的名字就是XXX\n​ libc-2.17.so库的名字是c-2.17\nWindows：XXXX.dll XXXX.lib\n直接gcc -c code.c就是执行前三步然后停下来，形成同名的.o文件\ngcc链接库\nldd查看依赖哪些库\nlibc-2.17.so就是C标准库，gcc是用来编译c的，所以gcc能自动链接到c标准库\n我们最终形成的可执行程序是依赖c标准库的\n==默认形成的可执行程序采用的是C语言的.so动态库==\n如果我们希望静态链接\n先要看你的Linux系统里是否安装了静态库\n如果没有安装，需要执行下面的指令\n安装好后，我们可以尝试静态链接\n总结\ngcc默认形成的可执行程序是动态链接的 gcc-static：进行静态链接 3.4动静态库和静态链接\u0026mdash;理论部分 ==动态库是共享的，所以不能丢失==，一旦丢失，所有依赖动态库都会运行出错\n**静态链接：**把我们要的库方法实现，==直接拷贝到我们的可执行程序中==\n​\t一旦形成可执行程序，即使把静态库删了，程序照样能跑\n总结：\n动静态链接，首先系统里要有动态库，静态库，都有的情况下就可以对程序进行链接\n如果链接的是动态库，就是动态链接；如果链接的是静态库，就是静态链接\n静态链接优点：不依赖库\n缺点：浪费空间（磁盘和内存空间）\n4. 自动化构建make/Makefile 4.1make/Makefile是什么？ make是一个命令\nmakefile是一个文件\n4.2 看看make/Makefile 创建一个名为Makefile的文件 打开Makefile 写入下面的内容，保存退出 以后执行make命令就会生成mytest可执行程序，我们只用 ./mytest就可以运行 4.3 核心思想 第一行是依赖关系，第二行是依赖方法\n依赖关系和依赖方法，形成目标文件\n4.4 具体语法 4.4.1 第一部分 ==冒号左边==，比如上图中的clean和mytest都是一个==目标文件==\n==冒号右边==，比如上图中的test.c是==依赖文件==，如果依赖文件有很多个，那么叫依赖文件列表\n而clean没有依赖文件\n目标文件和依赖文件合起来叫依赖关系\nmake会自动向下扫描makefile文件，==形成第一个目标文件==\n如果想指定形成，make 指定名称\n.PHONY修饰的变为伪目标，==凡是被.PHONY修饰的方法，总是被执行==\n如果不被修饰，那么如果文件没有修改，再次执行make就不会起作用 \u0026mdash;- 提高效率\n​\nmakefile怎么决定源文件到底要不要重新编译的呢？\n先有源文件，然后gcc形成可执行程序。 之后再修改源文件，那么源文件的修改时间就比可执行程序的时间新 再次编译时，发现可执行程序的生成时间比源文件的修改时间晚，说明这是旧的可执行程序 所以这时允许重新编译源文件 结论：通过对比源文件和可执行文件的修改时间（Modify时间）\n4.1.2 文件的ACM时间 文件=内容+属性\n可以通过stat 文件名的方式查看文件的ACM时间\n文件的内容修改，Modify时间变\n文件的属性修改，Change时间变\n修改文件的内容后，Modify时间变了，同时，文件的大小也变了，所以Change时间也会变 如果只修改文件的权限，那么就只有Change时间会变 Access是文件的最新访问时间，cat一个文件后，就会变。\n但是不是每次访问后，这个时间都会变\ntouch一个文件后，这个文件的ACM时间都更新\nmakefile通过对比源文件和可执行文件的修改时间（Modify时间）来决定源文件\n到底要不要重新编译的。\n所以只要我们touch一下源文件，那么源文件的M时间一定比可执行程序的时间新\n这时再make就又可以编译了\n所以.PHONY修饰一个符号后，总是被执行的原因就是==忽略对比时间，下面这条命令总是执行==\n4.1.3 第二部分 Makefile 是#来注释\n实际依赖了下面这些文件\nmake会进行依赖关系推导（栈），直到依赖文件是存在的\n将依赖方法不断入栈，推导完毕，出栈执行方法\n所以Makefile最终会形成一个目标文件\n4.1.4 第三部分 更加通用的makefile\n我们一般喜欢先把源文件 a.c b.c d.c e.c等先变成a.o b.o d.o e.o \u0026mdash;\u0026mdash;\u0026mdash;编译\n然后再和动静态库文件（lib.so lib.a libstdc++.so llibc++.a）统一打包形成可执行程序 \u0026mdash;\u0026mdash;-链接\n优化\n使用$\n但是如果源文件多了，就不行\n创建100个源文件\n优化\n可以使用$(shell ls *.c)的方式\n优化\nMakefile自己本身包含了一个语法，给我们提供了一个基本的函数wildcard\n同样可以将我们当前目录下所有的.c文件列出来\n优化\n完整：\n不想回显就加@\n依赖方法可以跟很多个\n5.Linux第一个系统程序-进度条 5.1补充-回车与换行 \\r ：回车指从该行当前位置到该行最左侧\n\\n：换行表示到下一行\n1 printf(\u0026#34;hello world\\n\u0026#34;) 语言上的\\n实际上是回车+换行\n回车换行是先换到下一行，然后回到该行的最左侧\n新起一行需要做两步：\n​\t**1.回到当前行的开头 **\n​\t2.到第二行\n5.2 行缓冲区 5.2.1引入 当我们在进行printf打印的时候，如果带了\\n，那么默认是往显示器上打印\nLinux下一切皆文件，所以往显示器上打印就叫做往显示器上写入。\n所以带\\n的表现形式就是数据立即显示。\n带了\\n，数据也一定先放到缓冲区，只不过这个缓冲区是给显示器提供的\n不带\\n再执行时，我们发现在显示器上是先卡了两秒，然后才打印\n但是在C语言中，==代码是从上到下依次执行的==，所以也就是说，我们发现\n显示器卡了两秒（执行sleep(2)）时就已经执行prinf(\u0026ldquo;hello bit\u0026rdquo;)这段代码了\n但是为什么我们没有看到呢，原因是print这段代码里的数据被保存到缓冲区了\n5.2.2显示器的刷新策略是：行刷新 比如如果打印信息碰到的是\\n那么该信息会立即显示到显示器上\n如果不包含\\n，该字符串不做刷新，直到要么程序结束，自动刷新\n要么将来强制刷新\n如果我们希望不带\\n的字符串立即刷新\n可以使用fflush强制刷新\n在C语言中，我在进行printf打印的时候（包括C程序），\n默认会打开3个文件的输入输出流\nprintf打印消息的时候，是把消息写到了stdout标准输出里面\n所以如果消息没有刷出来，我们就fflush刷新一下标准输出,就可以把这个\n字符串立即刷新出来\n5.3练手-倒计时程序 预备知识1：行缓冲区\n预备知识2：往显示器什么位置写入，由光标决定（类比笔尖）\n​\t写一个字符后，光标就会向后移动一位\n倒计时程序的原理\n我们写一个字符后，光标就会向后移动一位。但是我们现在想写一个\n字符后，想办法将光标再移动到开头。过1秒后，再在里面写另一个字符\nprintf打印的时候要做格式化，就是将整数..转字符\n5.4进度条 版本1：显示功能 功能1 首先，在内容中预留出100个字符的空位置，进度条每走一个，就多一个#，右侧中括号的位置不变。 功能2 右侧还有一个中括号，用来显示百分比。 功能3 最右侧还有一个中括号做旋转光标，来证明我们的进度条一直在推进 准备3个文件\n实现功能\nusleep：以微秒的时间来休眠\n1秒=1000毫秒，1毫秒=1000微秒，1秒=1000*1000微秒\nprocess.h中：\nmain.c中：\nprocess.c中：\n版本2：根据进度，动态刷新一次进度条 ==process.h==\n==process.c==\n==main.c==\n6.版本控制器Git 6.1如何理解版本控制 git是一个版本控制器软件，既是一个client也是一个server\ngitee||github是基于git的网站或平台\n仓库\u0026ndash;本质上就是一个文件夹\n1.数据安全\n我们每一次做git操作的时候，在当前目录下我们可以新建很多仓库，\n新建好仓库后，我们可以把自己的仓库推送到远端。\n2.协作开发\ngit是去中心化、分布式的版本控制\n两台装了git的机器相互之间可以互相拉取\n6.2Git的历史 git是开源的\n6.3Git的操作 1.新建仓库\n2.将远端仓库拉取到本地\n在本地先新建一个目录，然后在目录里执行git clone 加刚刚复制的HTTPS地址\n我们就拉取到了远端的文件\n我们把.git称为隐藏的仓库\n我们可以tree .git，.git里面是历史上我们每次修改的记录\n==git提交的时候，只会提交变化的部分==\n3. 将我们的文件添加到.git里的暂存区\n.git所在的目录：当前工作区\ngit add .默认把当前工作路径下所有的陌生文件全部添加到.git仓库中\n或者如果确定了要添加的文件，也可以git add 文件名\n还可以git add *\n但是执行了这个操作，实际上并不算完全添加到仓库里了，而是先添加到.git里的暂存区\n有了暂存区，git就让我们可以在本地多次add，一次提交到git仓库里\n4.将暂存区里的文件提交到git本地仓库\n先查看当前的状态：git status\n如果不想要提交某个文件了，可以使用git reset HEAD 文件名来将它删掉\n使用git commit -m \u0026quot;日志信息\u0026quot;才能真正将文件添加到本地仓库\ngit log可以查看提交记录\n5.将本地仓库和远端仓库同步\n1 git push 如果将本地目录全删掉了，但是想获得我历史上的提交信息，\n复制链接，然后执行以下命令就可以将之前的记录重新拉取下来\n1 git clone 复制的链接 总结：\ngit add git commit git push git log 查看日志 git status 查看状态 6.4 Git操作\u0026ndash;细节 1.git命令行安装\n1 2 sudo yum install git sudo apt install -y git 如果git已经装了\n2.首次使用：git输入username，email\n3.git版本管理，只进行管理源文件\n.gitignore进行本地文件后缀过滤的，如果某些特定后缀的文件在这个配置信息里，\n那么在add，commit，push时就不会被提交\n4..gitignore：需要忽略的特定后缀的文件列表\n5.windows上和liux上的人都对该仓库的文件做了修改，此时需要先重新拉取一下\n远端仓库，相比较于任何人，都是最新的\n为什么要冲突？提醒本地用户，你要和远端仓库进行同步了\nUbuntu下安装vimplus\n1 2 3 git clone https://github.com/chxuan/vimplus.git ~/.vimplus cd ~/.vimplus ./install.sh 补充：sudo无法执行 切换到超级用户\n添加配置，yy+p\n切换到底行模式执行wq!保存并退出\n再切回普通账号ctrl+d就可以执行sudo了\n二、调试器 - gdb/cgdb使用 2.1 准备知识 软件发布的模式\ndebug\nrelease模式 \u0026ndash; 发布模式\n软件测试工程师，测试就是对release版本进行测试 \u0026ndash; 上线\nLinux下我们编译好的代码无法直接调试\n如何调试？\ngcc/g++默认的工作模式是release模式\n如何改到debug模式？在编译的时候要加上-g选项\n==-g选项==，让最后形成的可执行程序，添加调试信息 \u0026ndash; debug模式\ngdb [可执行程序]\n==程序要调试，必须是debug模式 ，gdb携带调试信息的exe==\n2.2 快速认识gdb gdb的安装\n1 2 3 4 5 6 -- CentOS下 sudo yum install gdb -- Debian 或 Ubuntu下 sudo apt-get update sudo apt-get install gdb gdb如何进行打开，退出，中间如何让程序跑起来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; int Sum(int s, int e) { int result = 0; for(int i = s; i \u0026lt;= e; i++) { result += i; } return result; } int main() { int start = 1; int end = 100; printf(\u0026#34;I will begin\\n\u0026#34;); int n = Sum(start, end);//[start, end] printf(\u0026#34;running done, result is: [%d-%d]=%d\\n\u0026#34;,start, end, n); return 0; } 这段代码直接编译会提示不支持在循环体中定义变量，所以要带上-std=c99\n这时如果我们直接gdb mycode会发现找不到该命令，原因是默认是release发布模式\n需要带上-g选项\n在调试模式下，我们可能会用到如下的操作\n查看源代码 list（可以简写成l） l 1，代码从第一行开始显示 打断点 b 行号 r让程序运行起来 c让程序直接跑完 quit退出 l 1 后一直按回车，就可以将代码显示完\n2.3 gdb命令的学习 2.4 解决gdb难用的问题，三个debug技巧 安装cgdb\n1 2 3 4 5 Ubuntu: sudo apt-get install -y cgdb Centos: sudo yum install -y cgdb 使用cgdb进行调试，cgdb 可执行程序\n调试界面就会变成：上面是代码界面，下面是debug界面\nl 文件名:行号可以根据文件名==看代码== l表示从第一行开始显示\nb 文件名：行号针对某个文件来打断点（b是break的简写）\n也可以b 文件名:函数名来打断点，例如：b mycode.c:main 也可以b 行号来打断点 info b==查看==当前打的所有的断点\nd 断点编号==删除==断点\nr==运行==程序，如果没有断点，则直接跑完\nn/next：逐过程\n在调试的过程中再次输入r就可以重新从断点处开始调试\ns/step：逐语句\ngdb会自动记录最新的一条输入指令\n例如如果我们调试进入到循环里了，不想一直在循环里面，那么我们就\n可以回车\nreadelf指令会在可执行程序与elf以及动静态库加载的时候讲\ngrep -i debug 表示忽略大小写查debug\nbt可以查看栈帧\nmain先入栈，Sum函数先出栈\nfinish可以结束函数调用，回到函数调用处\np 变量名可以临时查看变量的值\n断点可以被使能（开关）\n默认断点是 Enb y表示Enable yes\n只有打断点的时候需要行号，其它时候都使用断点编号\n想让断点不起作用：disable 断点编号\n恢复断点的作用：enable 断点编号\nc 运行到下一个断点处\nuntil 行号跳出循环，到下一个断点\n调试的本质\n找到问题\n断点的本质，是把代码进行块级别划分，以块为单位进行快速定位区域\nfinish-\u0026gt;确认问题是否在函数内\nuntil-\u0026gt;局部区域快速执行\n查看代码上下文\ndispaly 变量名/\u0026amp;变量名可以让变量一直显示\n如果不想让变量一直显示undisplay 编号\ninfo locals 查看整个函数内定义的临时变量\nwatch 变量可以查看变量的变化，不用了就d 编号\n可以在调试的时候手动将变量的值改了，然后再调试set val 变量=值\ncgdb分屏操作，ESC进入代码屏幕，i回退到命令行\n条件断点\n需求：我们希望在for循环中，只有i=10的时候该断点才会被触发\n可以像下面这样打断点\n表示在第10行打断点，当i=10的时候\n在断点已经存在的情况下新增条件\n给4号断点新增条件：当i=20时\n查看源代码：ESC然后可以通过上下键查看\n回退回来的话输入i\n三、知识点 1.操作系统的生态问题！\n2.什么OS是好的OS？生态好\n3.软件包的依赖问题\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n一、进程 创建进程时，要有对应的task_struct来描述进程\n而每一个task_struct最终都要对应一个虚拟地址空间\n6.1进程的概念 6.1.1冯诺依曼体系结构 输入设备：键盘，鼠标，话筒，摄像头\u0026hellip;网卡，磁盘\n输出设备：显示器，磁盘，网卡，打印机\u0026hellip;\n在冯诺依曼体系中，统一把输入输出设备称为外设\n输入设备：将外设的数据读到内存里\n输出设备：把内存的数据输出到外设中\n==磁盘和网卡== 既是输入设备也是输出设备：\n读取文件就是把磁盘中的数据读到内存里；\n1 2 3 写文件就是把内存里的数据写到磁盘上 Input/Output ---\u0026gt;IO 站在内存的角度，外设把数据交给我（内存）\u0026mdash;\u0026gt;Input\n我(内存)把数据交给输出设备\u0026mdash;\u0026ndash;\u0026gt;Output\nCPU=运算器+控制器\n算术运算（+-*/等），逻辑运算（真假）\n控制器主要是控制CPU去取指令，分析指令，执行指令\n我们把CPU也叫做中央处理器\n存储器：内存\n磁盘：外存\n6.1.2软件运行，必须先加载到内存 软件运行，必须先加载到内存。程序运行之前，在哪里？\n磁盘。程序就是一个文件，是编译好的在磁盘特定路径下的二进制文件\n​\n为什么程序运行的时候要==先将程序加载到内存==？ \u0026mdash;\u0026ndash;\u0026gt; 体系结构规定\nCPU获取，写入，只能从内存中来进行\n​\n==软件运行 实际上是CPU执行我们的代码，访问我们的数据==\nCPU无法直接从外设读取数据，所以必须先将数据加载到内存\n这时，我们的程序才能被CPU访问到\n执行printf的时候是先从CPU处理完后，放到内存的缓冲区里，然后需要的时候再把数据刷新到外设\n​\n数据是从一个设备”拷贝“到另一个数据\n体系结构的效率：由设备的拷贝效率决定\n==结论：在数据层面，CPU只和内存打交道，外设只和内存打交道==\n存储分级：离CPU越近，效率越高，容量越小\n为什么不按照下面的方式设计计算机呢？\n由于CPU处理数据非常快，外设的处理数据比较慢，如果采用这种结构\n那么整个体系结构的效率就完全由外设的效率决定了\n所以引入内存\n内存和CPU，外设都能比较好地适配\n操作系统能提前将输入设备里的数据搬到内存里\n有了内存，使当代计算机，是性价比的产物\n后来，芯片技术+摩尔定律\n6.1.3 理解数据流动 数据流动的本质就是在冯诺依曼体系结构中进行流动\n举例：\n1.QQ聊天\n****\n用户从键盘输入，首先要打开QQ这个软件，需要将QQ这个软件加载到内存，把键盘\n数据搬到内存，你的消息需要经过运算器控制（加密、封包\u0026hellip;），然后由CPU写回内存\n再通过QQ将数据送到自己的体系结构的输出设备（网卡）\n网卡将数据交到网络里，一定会交到朋友的那台机器，由朋友的输入设备（网卡）\n来接收，朋友的QQ也一定得启动起来加载到内存，把数据从外设搬到内存，在QQ\n内部执行所有的代码（将读到的数据交给CPU，比如做解密，然后再交给内存），由\n存储器刷新到输出设备（显示器）\n2.发送文件\n文件是在磁盘上的，当我们将文件拖拽到QQ中，本质上是将磁盘文件拷贝到QQ，即\n搬到内存里，经过CPU的加密封装\u0026hellip;等，然后再写回到存储器（内存），再将我们的\n文件数据刷新到网卡，经过网卡，对方网卡接收，读到内存，经过CPU解包解密，写回\n到内存，打开对应目标文件，然后把数据写入到输出设备（磁盘）\n6.1.4 操作系统 一个基本的程序集合，称为操作系统（OS）\n操作系统是一款进行软硬件管理的==软件==\n操作系统包括：\n内核（进程管理，内存管理，文件管理，驱动管理）\n其它程序（例如函数库，shell程序）\n6.1.4.1设计OS的目的 为用户程序提供一个良好的执行环境\n硬件部分\n最底层是硬件，而硬件在逻辑上是按照冯诺依曼结构组织的\n每一种硬件都有对应的驱动程序\n驱动程序\n在硬件层面，不同的硬件都有自己个性化的读取方式，所以我们访问各种不同的硬件都要配上驱动程序\n操作系统\n对下，与软硬件交互，管理所有软硬件资源（不是目的，是手段）\n对上，为用户程序（应用程序）提供一个良好的执行环境\n1.软硬件体系结构层状结构 \u0026ndash; 从硬件一直到用户\n硬件是一层，驱动程序是一层，操作系统是一层\n软件的层状结构：在软件功能上体现高内聚，低耦合\n高内聚：将相同功能相同逻辑的代码数据放到同一层的内部 低耦合：层跟层之间只使用接口来调用 目的：提高代码的可维护性 \u0026ndash;一个模块修改了，不影响另一个模块\n2.访问操作系统，必须使用系统调用\u0026ndash;其实就是函数，只不过是系统提供的\nprinf的本质：把数据写到了硬件!显示器!\n底层封装了系统调用，然后通过操作系统，对驱动进行访问，访问对应驱动\n然后才能把数据交到硬件上\n3.我们的程序，只要你判断出它访问了硬件，那么它必须贯穿整个软硬件体系结构\n4.库可能在底层封装了系统调用\n理解操作系统\n核心功能\n在整个计算机软硬件架构中，操作系统是一款进行软硬件管理的软件 如何理解管理？\n事情：1.决策 2.执行\n操作系统拥有决策权，驱动程序来执行，硬件被管理\n1.要管理，管理者和被管理者，可以不需要见面\n2.管理者和被管理者，怎么管理呢？根据数据进行管理\n3.不需要见面，如何得到数据？由中间层获取\n操作系统如何管理硬件？\n每一个硬件都有硬件名，操作系统在内部，==先描述，再组织==。\n把网卡、硬盘、显卡、键盘、显示器等统一使用struct device定义一个结构\n类里面可以包含每一种硬件的各种属性（硬件名称、状态、相关链接信息..）\n每一个硬件都对应一个struct device对象，把对象管理起来。\n操作系统管理硬件 \u0026mdash;\u0026gt; 对硬件的增删查改\n操作系统怎么对进程进行管理？\n操作系统要对每个进程定义struct结构体结构，然后将进程相关的属性放到\n结构体里，用链接结点全部连起来，转换成对进程管理，转换成对链表的\n增删查改\nC++中：类+STL\n类解决了先描述 STL解决了再组织 理解系统调用\n操作系统要向上提供对应的服务 操作系统，不相信任何用户或者人 我们未来访问操作系统、获取操作系统内的数据、设置自己的信息等都要\n通过系统调用来完成\nLinux/windows/macos的操作系统都是C语言写的\u0026ndash;\u0026gt;C函数\u0026ndash;\u0026gt;输入参数和返回值\n输入参数：用户给操作系统 返回值：操作系统给用户 ==系统调用的本质：用户和操作系统之间，进行某种数据交互==\n库函数如果访问了硬件，那么底层一定访问了系统调用\n6.2 进程 6.2.1 概念 ==进程 = 内核数据结构对象 + 自己的代码和数据==\n==进程 = PCB(task_struct) + 自己的代码和数据==\n操作系统必然要对多个被加载到内存中的程序进行管理\n对进程的管理，就变成了对链表的增删查改\n我们把这个结构体叫PCB（process control block ）进程控制块\n在Linux中，这个PCB叫task_struct，\n进程的所有属性，都可以直接或者间接通过task_struct找到\n6.2.2 task_struct 标志符：描述本进程的唯一标志符，用来区别其它进程 状态：任务状态、退出代码、退出信号 优先级：相对于其它进程的优先级 程序计数器：程序中即将被执行的下一条指令的地址 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针，能真正找到代码和数据 上下文数据：进程执行时处理器的寄存器中的数据 6.2.3 查看进程 sleep需要包含头文件unistd\n我们历史上执行的所有==指令，工具，自己的程序==，运行起来，全部都是进程\n查看进程：方式1 getpid获得标志符，返回值为 谁调用的就获得谁的进程ID\n调getpid本质是让操作系统从PCB里把我的pid拷贝出来，让用户看到我的ID是什么\nman3号手册是库调用，2号手册是系统调用 task_stuct结构体里有个属性叫pid ==getpid是系统调用，为了获得进程自己的pid==，pid在当前进程task_struct里对应的标志符里 只要是一个进程，就有自己的ID信息\nps axj查看以特定形式显示的所有进程（a表示所有）\nps axj | head -l先将第一行显示（属性列的名字） ps axj | grep myprocess再查我们的进程 在Linux中，如果想==同时执行两条命令==，==可以使用分号或者\u0026amp;\u0026amp;==\n因为grep也是一个命令，它过滤的关键字中包含process，所以也会被查出来，如果不想把grep也查出来，可以带-v反向匹配，也就是包含grep的不查出来\nps ajx | head -1;ps axj | grep myprocess | grep -v grep\n杀掉进程：kill -9 对应PID，-9表示信号\nctrl+c是杀掉进程\n方式2 可以通过文件的方式去查看进程\nproc目录（process的简写）\nproc里的数据都是内存里的数据\n例如：\n先将程序运行起来 查proc目录里的pid文件 当我们杀掉这个进程后再查 更改一个进程的当前路径chdir\n查看父进程 getppid()\n代码创建子进程的方式 fork创建一个子进程\nfork会返回两个返回值\n现在我们想让父子未来执行不同的代码逻辑\n为什么fork给父子返回各自的不同返回值？\n父：子 = 1：n\n任何一个父进程都可以有多个子进程\n任何一个子进程都只会有一个父进程\n为什么一个函数会返回两次？\n为什么一个变量，既==0，又大于0？导致if else 同时成立?\n进程具有独立性\n6.3进程的状态 6.3.1Linux内核源代码怎么说？ 一个进程可以有几个状态（在Linux内核里，进程有时候也叫做任务）\n进程状态就是task_struct内的一个整数\n课本上的说法\u0026ndash;名词提炼\n运行\u0026amp;\u0026amp;阻塞\u0026amp;\u0026amp;挂起\nLinux的进程状态\n6.3.2进程状态查看 6.3.3僵尸进程 6.3.4孤儿进程 6.4进程的优先级 6.5进程切换 二、环境变量 1. 概念介绍 1.1命令行参数 main函数是有参数的，\nargc是指有多少子串，argv指针数组\nmain函数的命令行参数，是实现程序不同子功能的方法（指令带选项）\n2. 一个例子，认识环境变量 要执行一个程序，必须先找到它 \u0026mdash; bash找，通过PATH(环境变量)找 为什么执行系统指令不需要./呢？ 系统中存在环境变量，来帮助系统找到目标二进制文件 系统中存在环境变量PATH，告诉系统去哪查目标二进制文件 环境变量：名字+内容\nenv查看系统中所有环境变量 ==echo $PATH根据环境名字来获得一个环境变量== 直接覆盖添加环境变量：PATH=路径\n不覆盖添加环境变量：PATH=$PATH:路径\n1.如何理解环境变量呢？存储的角度\n​\tbash，形成一张表，环境变量表 \u0026mdash;\u0026gt; 从配置文件拷贝来\nbash内部有两张表，命令行参数表和环境变量表\n2.环境变量，最开始从哪里来的呢？\n==环境变量是从系统的相关配置文件中来的==\n系统登录，bash拷贝配置文件，形成一张表\n3.认识更多的环境变量 echo $SHELL\necho $USER\nuser\nlogname\nctrl+r历史命令搜索\n4.获取环境变量的方法 查所有环境变量\nenv\n查看单个环境变量\necho $环境变量名\n我们自己可以导环境变量\nexport 环境变量名\n取消环境变量\nunset 环境变量名\n方式1：main函数获取\n父进程（bash）\n环境变量可以被子进程继承\n方法2：getenv\n根据环境变量的名字获取环境变量的内容\n设置一个程序只能我自己跑\n方法3：\nenviron\n5.理解环境变量的特性 5.1 环境变量具有全局特性 5.2 补充两个概念 a.\n定义本地变量\n查看本地变量：set，可以查看环境变量和本地变量\n本地变量不会被子进程继承，只在bash内部被使用\nb.\n我们的环境变量\n内建命令在执行时不需要创建子进程\n6. 程序地址空间 程序地址空间不是内存。\n实际叫：进程地址空间（虚拟地址空间），是一个系统概念，不是语言层的概念\n三、进程地址空间 虚拟地址空间\n1.引入新概念 1.1 一个进程，一个虚拟地址空间 创建进程时，要有对应的task_struct来描述进程\n而每一个task_struct最终都要对应一个虚拟地址空间\n虚拟地址 虚拟地址空间对应的宽度单位是1字节 在32位机器下，虚拟地址空间的范围是2^32^个地址 * 1字节 = 能表示的总的地址空间的容量是4GB 在64位机器下，虚拟地址空间的范围是2^64^个地址 2.虚拟地址与进程地址空间 3.是什么？例子 4.怎么办？ 5.为什么 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n一、进程控制 1.进程创建 2.进程终止 2.1进程退出的场景 代码运行完毕，结果正确 代码运行完毕，结果不正确 代码异常终止 子进程也是进程 \u0026ndash;\u0026gt; 父进程创建 \u0026ndash;\u0026gt; 子进程执行结果\n子进程执行的结果要让父进程知道\n2.2退出码 int main()\n==main函数的返回值，通常表明你的程序的执行情况==\n一般都是代码运行完毕的情况，结果正确返回0，结果错误返回非0\n因为非0有1 2 3 \u0026hellip;等不同的值，表明不同的出错原因 ​ ./proc进程的父进程是bash，父进程需要得到子进程运行的结果，通过得到退出码\necho $?打印==最近一个程序==(进程)退出时的退出码 （指令也是程序）\n退出码写到你的进程的task_struct内部\n==代码运行完毕后的结果由进程的退出码决定==\n==一旦代码出现异常，退出码无意义==\n一旦进程出现异常，一般是进程收到了信号\n2.3 exit和_exit函数 main函数结束，进程结束，其它函数，只表示\n任何地方调用exit，表示进程结束，并返回给父进程bash，子进程的退出码\nexit是C语言提供的，_exit是系统提供的\n进程如果exit退出，exit()，进程退出时，会进行缓冲区的刷新\n进程如果exit退出，_exit()，进程退出时，不会进行缓冲区的刷新\nexit最后也会调用_exit, 但在调用_exit之前，还做了其他⼯作\nexit封装了_exit\n只有操作系统能决定是否退出进程\n缓冲区一定不是操作系统内部，而在库缓冲区，C语言提供的\n3.进程等待 3.1为什么？ 解决内存泄漏的问题 父进程派给子进程任务，需要知道子进程运行完成的结果对还是不对 父进程通过进程等待的方式回收子进程资源（重要），获取子进程退出信息(可选) 3.2是什么？ 接口 wait和waitpid\nwaitpid\n3.3怎么做到的？ wait等待任意一个退出的子进程\n成功时返回目标进程的pid\n如果等待子进程，子进程没有退出，父进程会阻塞在wait处\nkill -l 查看Linux中的信号，信号本质是宏\n3.4阻塞与非阻塞等待 非阻塞调用\n非阻塞轮询，轮询：循环完成\n非阻塞调用可以让等待方，做自己的事，所以效率高\n返回值大于0：等待结束\n等于0：调用结束，但子进程没有退出\n小于0：失败\n阻塞调用\n如何让父进程做其他事情呢？\n4.进程程序替换 4.1快速见一见效果 4.2进程替换原理 - fork 进程=内核数据结构+代码和数据\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;不变\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n在程序替换的过程中，并没有创建新的进程\n4.3认识全部接口 ==接口1==\n1 int execl(const char* path, const char* arg, ...); // ...是可变参数 要执行谁 要怎么执行它 为什么没有影响父进程呢？\n进程具有独立性 数据和代码都要发生写实拷贝 程序要跑，就是进程，只要是进程，就能进行程序替换\n==接口2==\n1 int execlp(const char * file, const char* arg, ...); p \u0026mdash; PATH，只能执行系统指令\nfile 只需要告诉需要执行的文件名，因为execlp会自动在环境变量中查找指定的命令\n==接口3==\n1 int execv(const char* path, char* const ) ==接口4==\n1 2 int execvpe(const char* file, char* const argv[], char* const envp[]); // 环境变量 ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\n文件系统 1. ","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""},{"content":"[TOC]\nLinux作业 01 基础指令 题目1：\nA 全称Linux extended file system, extfs,即Linux扩展文件系统，ext2为第二代\nD XFS一种高性能的日志文件系统，2000年5月，Silicon Graphics以GNU通用公共许可证发布这套系统的源代码，之后被移植到Linux 内核上。XFS 特别擅长处理大文件，同时提供平滑的数据传输\nE UFS是UNIX文件系统的简称，它来源于4.3Tahoe发行版中提供的BSD Fat Fast File System（FFS）系统，属于FFS的演化版本\n==ABCD==\n题目2:\nuname -r 查看linux内核版本信息\nvmstat 报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息\nsar\t主要帮助我们掌握系统资源的使用情况，特别是内存和CPU的使用情况\nstat\t用于显示文件的状态信息\n==A uname -f==\n题目3:\n​ A\tcat 打印文件内容到终端显示\n​ B\tmore\t分页显示文件内容，但是通常向上翻页不好使\n​ C\tless\t分页显示文件内容，可以灵活上下移动光标和翻页\n​ D\tmenu\t没有这个指令（至少centos7上默认没有这个命令）\n==C==\n题目4:\n​ A\t-m\t在创建目录的同时设置权限\n​ B\t-d\t没有这个选项\n​ C\t-f\t没有这个选项\n​ D\t-p\t在创建多层级目录的时候若上级目录不存在则创建\n==D==\n题目5:\ngrep:Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，\n并把匹配的行打印出来。grep全称是Global Regular Expr ession Print，表示全局正则表达式版本，它的使用权限是所有用户。\ngrep选项中，-E选项可以用来扩展选项为正则表达式；\n\\$表示匹配文件末尾，字符需要在$之前表示以字符结尾 a$表示以a结尾 ​\t^表示匹配文件起始，字符需要在 ^之后表示以字符起始 ^a表示以a起始\n==D==\n题目6:\n​ A\ttop 查看cpu资源使用状态\n​ B\tnetstat\t查看网络连接状态\n​ C\tfree\t查看内存资源状态\n​ D\tdf\t查看磁盘分区资源状态\n==A==\n题目7:\nA\trm *.c *通配符，表示匹配任意字符任意次\nB\tfind . -name \u0026ldquo;*.c\u0026rdquo; -maxdepth 1 | xargs rm\n​ find . -name \u0026ldquo;*.c\u0026rdquo; -maxdepth 1 找到当前目录下.*结尾的文件，目录深度为1\n​ xargs是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令，用于很多不支持|管道来传递参数的命令\n​\t相当于将前边命令的执行结果，也就是查找到的文件名，传递给后边的rm指令进行删除\nC\tfind . -name \u0026ldquo;*.c\u0026rdquo; | xargs rm 没有进行深度控制，删除的不仅是当前目录下的文件，会将子目录下的文件也删除\nD\t以上都不正确\n==AB==\n02Linux权限 C\nC\n03yum理解 ABC\n04make/makefile C\nA\nA\nABC\nBD\n","date":"0001-01-01T00:00:00Z","permalink":"https://Amarantos-Arrebol.github.io/p/","title":""}]