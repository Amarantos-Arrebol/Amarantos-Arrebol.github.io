[{"content":"1.异常的基本介绍 1.1 异常的概念 C语言主要通过错误码的形式处理错误，拿到错误码以后还要去查询错误信息，比较麻烦。\n异常是返回一个对象，这个对象包含相关的所有错误信息\n异常处理机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理\n异常使得我们能够将问题的检测与解决问题的过程分开，程序的一部分负责检测问题的出现，然后解决问题的任务传递给程序的另一部分，检测环节无须知道问题的处理模块的所有细节\n1.2 异常的抛出和捕获 程序出现问题时，我们通过抛出(throw)一个对象来引发一个异常，该对象的类型以及当前的调用链决定了应该由哪个catch的处理代码来处理该异常。\n被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。根据抛出对象的类型和内容，程序的抛出异常部分告知异常处理部分到底发生了什么错误。\n当throw执行时，throw后面的语句将不再被执行。程序的执行从throw位置跳到与之匹配的catch模块，catch可能是同一函数中的一个局部的catch，也可能是调用链中另一个函数中的catch，控制权从throw位置转移到了catch位置。这里还有两个重要的含义：1、沿着调用链的函数可能提早退出。2、一旦程序开始执行异常处理程序，沿着调用链创建的对象都将销毁。\n抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个局部对象，所以会生成一个拷贝对象，这个拷贝的对象会在catch子句后销毁。（这里的处理类似于函数的传值返回)\n1.3 栈展开 抛出异常后，程序暂停当前函数的执行，开始寻找与之匹配的catch子句，首先检查throw本身是否在try块内部，如果在则查找匹配的catch语句，如果有匹配的，则跳到catch的地方进行处理。 如果当前函数中没有try/catch子句，或者有try/catch子句但是类型不匹配，则退出当前函数，继续在外层调用函数链中查找，上述查找的catch过程被称为栈展开。 如果到达main函数，依旧没有找到匹配的catch子句，程序会调用标准库的 terminate 函数终止程序。 如果找到匹配的catch子句处理后，catch子句代码会继续执行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;iostream\u0026gt; using namespace std; double Divide(int a, int b) { try { if (b == 0) { string s(\u0026#34;Divide by zero condition!\u0026#34;); throw s; } else { return (double)a / (double)b; } } catch (int errid) { cout \u0026lt;\u0026lt; errid \u0026lt;\u0026lt; endl; } return 0; } void Func() { int len, time; cin \u0026gt;\u0026gt; len \u0026gt;\u0026gt; time; try { cout \u0026lt;\u0026lt; Divide(len, time) \u0026lt;\u0026lt; endl; } catch (const char* errmsg) { cout \u0026lt;\u0026lt; errmsg \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; __FUNCTION__ \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt; \u0026#34;行执行\u0026#34; \u0026lt;\u0026lt; endl; } int main() { while (1) { try { Func(); } catch (const string\u0026amp; errmsg) { cout \u0026lt;\u0026lt; errmsg \u0026lt;\u0026lt; endl; } catch (...) { cout \u0026lt;\u0026lt; \u0026#34;未知异常\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 1.4 查找匹配的处理代码 一般情况下抛出对象和catch是类型完全匹配的，如果有多个类型匹配的，就选择离他位置更近的那个。\n但是也有一些例外：\n允许从非常量向常量的类型转换，也就是权限缩小 允许数组转换成指向数组元素类型的指针，函数被转换成指向函数的指针 允许从派生类向基类类型的转换（这个点非常实用，实际中继承体系基本都是用这个方式设计的） 如果到main函数，异常仍旧没有被匹配就会终止程序，不是发生严重错误的情况下，我们是不期望程序终止的，所以一般main函数中最后都会使用catch(...)，它可以捕获任意类型的异常，但是是不知道异常错误是什么\n例子：\n异常的基类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Exception { public: Exception(const string\u0026amp; errmsg, int id) :_errmsg(errmsg) ,_id(id) {} virtual string what() const { return _errmsg; } int getid() const { return _id; } protected: string _errmsg; int _id; }; 捕获SQL的异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class SqlException : public Exception { public: SqlException(const string\u0026amp; errmsg, int id, const string\u0026amp; sql) :Exception(errmsg, id) ,_sql(sql) {} virtual string what() const { string str = \u0026#34;SqlException:\u0026#34;; str += _errmsg; str += \u0026#34;-\u0026gt;\u0026#34;; str += \u0026#34;sql\u0026#34;; return str; } private: const string _sql; }; 捕获缓存的异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CacheException : public Exception { public: CacheException(const string\u0026amp; errmsg, int id) :Exception(errmsg, id) { } virtual string what() const { string str = \u0026#34;CacheExcetion:\u0026#34;; str += _errmsg; return str; } }; 捕获http的异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class HttpException : public Exception { public: HttpException(const string\u0026amp; errmsg, int id, const char* type) :Exception(errmsg, id) ,_type(type) { } virtual string what() const { string str = \u0026#34;HttpException:\u0026#34;; str += _type; str += \u0026#34;:\u0026#34;; str += _errmsg; return str; } private: const string _type; }; 模拟程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;thread\u0026gt; void SQLMgr() { if (rand() % 7 == 0) { throw SqlException(\u0026#34;权限不足\u0026#34;, 100, \u0026#34;select * from stu where name=\u0026#39;张三\u0026#39;;\u0026#34;); } else { cout \u0026lt;\u0026lt; \u0026#34;SQLMgr 调用成功\u0026#34; \u0026lt;\u0026lt; endl; } } void CacheMgr() { if (rand() % 5 == 0) { throw CacheException(\u0026#34;权限不足\u0026#34;, 100); } else if (rand() % 4 == 0) { throw CacheException(\u0026#34;数据不存在\u0026#34;, 101); } else { cout \u0026lt;\u0026lt; \u0026#34;CacheMgr 调用成功\u0026#34; \u0026lt;\u0026lt; endl; } SQLMgr(); } void HttpServer() { if (rand() % 3 == 0) { throw HttpException(\u0026#34;请求资源不存在\u0026#34;, 100, \u0026#34;get\u0026#34;); } else if (rand() % 4 == 0) { throw HttpException(\u0026#34;权限不足\u0026#34;, 101, \u0026#34;post\u0026#34;); } else { cout \u0026lt;\u0026lt; \u0026#34;HttpServer调用成功\u0026#34; \u0026lt;\u0026lt; endl; } CacheMgr(); } int main() { srand(time(0)); while (1) { this_thread::sleep_for(chrono::seconds(1)); try { HttpServer(); } catch (const Exception\u0026amp; e) // 基类对象，派生类对象都可以捕获 { //多态 cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } catch (...) { cout \u0026lt;\u0026lt; \u0026#34;Unkonw Exception\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 1.5 异常重新抛出 有时catch到一个异常对象后，需要对错误进行分类，其中的某种异常错误需要进行特殊的处理，其他错误则重新抛出异常给外层调用链处理。\n捕获异常后需要重新抛出，直接throw;就可以把捕获的对象直接抛出\nthrow; 就是捕获到什么就抛出什么\n例子1：\n模拟发送消息的时候，可能因为网络的原因，发送失败，但是要求再尝试3次，如果3次后还是失败，就抛出异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026lt;thread\u0026gt; class Exception { public: Exception(const string\u0026amp; errmsg, int id) :_errmsg(errmsg) ,_id(id) {} virtual string what() const { return _errmsg; } int getid() const { return _id; } protected: string _errmsg; int _id; }; class HttpException : public Exception { public: HttpException(const string\u0026amp; errmsg, int id, const char* type) :Exception(errmsg, id) ,_type(type) { } virtual string what() const { string str = \u0026#34;HttpException:\u0026#34;; str += _type; str += \u0026#34;:\u0026#34;; str += _errmsg; return str; } private: const string _type; }; // 下⾯程序模拟展⽰了聊天时发送消息，发送失败补货异常，但是可能在 // 电梯地下室等场景⼿机信号不好，则需要多次尝试，如果多次尝试都发 // 送不出去，则就需要捕获异常再重新抛出，其次如果不是⽹络差导致的 // 错误，捕获后也要重新抛出。 void _SeedMsg(const string\u0026amp; s) { if (rand() % 2 == 0) { throw HttpException(\u0026#34;网络不稳定，发送失败\u0026#34;, 102, \u0026#34;put\u0026#34;); } else if (rand() % 7 == 0) { throw HttpException(\u0026#34;你已经不是对方好友，发送失败\u0026#34;, 103, \u0026#34;put\u0026#34;); } else { cout \u0026lt;\u0026lt; \u0026#34;发送成功\u0026#34; \u0026lt;\u0026lt; endl; } } void SendMsg(const string\u0026amp; s) { //发送消息失败，则再重试次 for (size_t i = 0; i \u0026lt; 4; i++) { try { _SeedMsg(s); break; } catch (const Exception\u0026amp; e) { if (e.getid() == 102) { if (i == 3) throw; cout \u0026lt;\u0026lt; \u0026#34;开始第\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34;次重试\u0026#34; \u0026lt;\u0026lt; endl; } else { throw; } } } } int main() { srand(time(0)); string str; while (cin \u0026gt;\u0026gt; str) { try { SendMsg(str); } catch (const Exception\u0026amp; e) { cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } catch (...) { cout \u0026lt;\u0026lt; \u0026#34;Unkonw Exception\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 例子2：\n可能前面申请了资源，需要 catch(...) 先将资源释放，再把异常重新抛出去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; using namespace std; double Divide(int a, int b) { try { if (b == 0) { string s(\u0026#34;Divide by zero condition!\u0026#34;); throw s; } else { return (double)a / (double)b; } } catch (int errid) { cout \u0026lt;\u0026lt; errid \u0026lt;\u0026lt; endl; } return 0; } void Func() { int* ptr = new int[10]; int len, time; cin \u0026gt;\u0026gt; len \u0026gt;\u0026gt; time; try { cout \u0026lt;\u0026lt; Divide(len, time) \u0026lt;\u0026lt; endl; } catch (const char* errmsg) { cout \u0026lt;\u0026lt; errmsg \u0026lt;\u0026lt; endl; } catch (...) { delete[] ptr; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr \u0026lt;\u0026lt; endl; //重新抛出 throw; } delete[] ptr; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr \u0026lt;\u0026lt; endl; } int main() { while (1) { try { Func(); } catch (const string\u0026amp; errmsg) { cout \u0026lt;\u0026lt; errmsg \u0026lt;\u0026lt; endl; } catch (...) { cout \u0026lt;\u0026lt; \u0026#34;未知异常\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 1.6 异常安全问题 异常抛出后，后面的代码就不再执行，前面申请了资源（内存、锁等），后面进行释放，但是中间可能会抛异常就会导致资源没有释放，这里由于异常就引发了资源泄漏，产生安全性的问题**。中间我们需要捕获异常，释放资源后面再重新抛出**，当然后面智能指针章节讲的RAII方式解决这种问题是更好的。\n其次析构函数中，如果抛出异常也要谨慎处理，比如析构函数要释放10个资源，释放到第5个时抛出异常，则也需要捕获处理，否则后面的5个资源就没释放，也资源泄漏了。《EffctiveC++》第8个条款也专门讲了这个问题，别让异常逃离析构函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 double Divide(int a, int b) { try { if (b == 0) { string s(\u0026#34;Divide by zero condition!\u0026#34;); throw s; } else { return (double)a / (double)b; } } catch (int errid) { cout \u0026lt;\u0026lt; errid \u0026lt;\u0026lt; endl; } return 0; } void Func() { int* ptr1 = new int[10]; int* ptr2 = new int[10]; // ptr2也可能抛异常 int len, time; cin \u0026gt;\u0026gt; len \u0026gt;\u0026gt; time; try { cout \u0026lt;\u0026lt; Divide(len, time) \u0026lt;\u0026lt; endl; } catch (const char* errmsg) { cout \u0026lt;\u0026lt; errmsg \u0026lt;\u0026lt; endl; } catch (...) { delete[] ptr1; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr1 \u0026lt;\u0026lt; endl; delete[] ptr2; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr2 \u0026lt;\u0026lt; endl; //重新抛出 throw; } delete[] ptr1; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr1 \u0026lt;\u0026lt; endl; delete[] ptr2; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr2 \u0026lt;\u0026lt; endl; } 1.7 异常规范 对于用户和编译器而言，预先知道某个程序会不会抛出异常大有益，知道某个函数是否会抛出异常有助于简化调用函数的代码。 C++98中函数参数列表的后面接throw()，表示函数不抛异常，函数参数列表的后面接throw(类型1,类型2...)表示可能会抛出多种类型的异常，可能会抛出的类型用逗号分割。 C++98的方式这种方式过于复杂，实践中并不好用，C++11中进行了简化，函数参数列表后面加noexcept表示不会抛出异常，啥都不加表示可能会抛出异常 ​\t编译器并不会在编译时检查noexcept，也就是说如果一个函数用noexcept修饰了，但是同时又包含了throw语句或者调用的函数可能会抛出异常，编译器还是会顺利编译通过的（有些编译器可能会报个警告)。但是一个声明了noexcept的函数抛出了异常，程序会调用terminate 终止程序。 noexcept(expression)还可以作为一个运算符去检测一个表达式是否会抛出异常 可能会抛异常就返回false 不会抛异常就返回true 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;iostream\u0026gt; using namespace std; double Divide(int a, int b) { try { if (b == 0) { string s(\u0026#34;Divide by zero condition!\u0026#34;); throw s; } else { return (double)a / (double)b; } } catch (int errid) { cout \u0026lt;\u0026lt; errid \u0026lt;\u0026lt; endl; } return 0; } void Func() { int* ptr1 = new int[10]; int len, time; cin \u0026gt;\u0026gt; len \u0026gt;\u0026gt; time; try { cout \u0026lt;\u0026lt; Divide(len, time) \u0026lt;\u0026lt; endl; } catch (const char* errmsg) { cout \u0026lt;\u0026lt; errmsg \u0026lt;\u0026lt; endl; } catch (...) { delete[] ptr1; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr1 \u0026lt;\u0026lt; endl; //重新抛出 throw; } delete[] ptr1; cout \u0026lt;\u0026lt; \u0026#34;delete:\u0026#34; \u0026lt;\u0026lt; ptr1 \u0026lt;\u0026lt; endl; } int main() { int i = 0; cout \u0026lt;\u0026lt; noexcept(Divide(1, 2)) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; noexcept(Divide(1, 0)) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; noexcept(++i) \u0026lt;\u0026lt; endl; // 1 return 0; } 2.标准库的异常 标准库的异常\nC++标准库也定义了一套自己的一套异常继承体系库，基类是exception\n我们日常写程序，需要在主函数捕获exception即可，要获取异常信息，调用what函数\nwhat是一个虚函数，派生类可以重写\nbad_alloc：new或者stl里面的容器push或者insert等内存申请失败时会抛出的异常\nout_of_range：越界时可能会抛出的异常\noverflow_error：溢出时可能会抛出的异常\ninvalid_argument：有非法参数时可能会抛出的异常\nbad_cast：类型转换失败时可能会抛出的异常\n","date":"2025-11-09T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/abnormal/11_hu_69e95f637eb7df8.png","permalink":"https://Amarantos-Arrebol.github.io/p/abnormal/","title":"【C++进阶】05AVL树实现"},{"content":"1.序列容器和关联式容器 序列式容器\n逻辑结构为线性序列的数据结构，两个位置存储的值之间一般没有紧密的关联关系\n比如交换一下，他依旧是序列式容器\n顺序容器中的元素是按他们在容器中的存储位置来顺序保存和访问的\n序列式容器有 string、vector、list、deque、array、forward_list 等\n关联式容器\n关联式容器逻辑结构通常是非线性结构，两个位置有紧密的关联关系\n比如交换一下，他的存储结构就被破坏了\n顺序容器中的元素是按关键字来保存和访问的\n关联式容器有 map/set(底层红黑树)系列和 unordered_map/unordered_set(底层哈希表) 系列\nmap 和 set 底层是红黑树，红黑树是一颗平衡二叉搜索树\nset 里面存的是一个单独的关键字\nmap 里面存的是一个 pair\u0026lt;key, value\u0026gt;（k-v 模型），不仅有一个关键字，还会有一个与关键字绑定的值，比较方式是按照 key 的值来比较（排序是按照第一个关键字来比较的）\nset 和 map 不能存重复的元素，multiset 和 multimap 可以存重复的元素\n2.set / multiset 2.1 基本介绍 set 底层是用红黑树实现，增删查效率是 O(logN）\n迭代器遍历是走的搜索树的中序，因此是一个有序序列\nset 不能存重复元素，multiset 可以存重复元素，所以可以用 set 来去重\n文档\n\u0026lt;set 底层关键字的类型，仿函数，空间配置器\u0026gt;\n（1）一般情况下，我们只需要传第一个模版参数\n（2）需要传仿函数的场景：\nT 不支持比较大小，需要自己写仿函数来支持\nT 支持比较大小，但不符合我们的需求\n（3）set 底层存储数据的内存是从空间配置器申请的，如果需要，可以自己实现内存池传给 set 的第三个参数\n2.2 set 的构造和迭代器 （1）set 支持默认构造、拷贝构造、迭代器区间构造，initializer_list 构造等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { //默认升序排序(如果存的是字符串，按照ASCII码大小顺序比较) set\u0026lt;int\u0026gt; mp1; set\u0026lt;int\u0026gt; mp2(mp1); // 拷贝构造 set\u0026lt;int\u0026gt; mp3 = { 10, 6, 12, 1, 10}; // initializer_list构造 vector\u0026lt;int\u0026gt; nums = {1, 3, 5, 2, 4}; set\u0026lt;int\u0026gt; mp4(nums.begin(), nums.end()); // 迭代器区间构造 //指定降序 set\u0026lt;int, greater\u0026lt;int\u0026gt;\u0026gt; mp5; return 0; } （2）set 的支持正向和反向迭代遍历，遍历默认按升序顺序。因为底层是二叉搜索树，迭代器遍历走的中序\n（3）set 的 iterator 和 const_iterator 都不支持迭代器修改数据。因为修改关键字数据，会破坏底层搜索树的结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; s = {10, 6, 12, 1, 10}; // 默认升序+去重 //set\u0026lt;int\u0026gt;::iterator it = s.begin(); auto it = s.begin(); while (it != s.end()) { //*it = 1; // err，不支持修改数据 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it; } cout \u0026lt;\u0026lt; endl; return 0; } 2.3 set 的增删查 insert 可以插入一个值、一段迭代器区间，initializer_list 等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; mp; mp.insert(5); mp.insert(2); mp.insert({ 2, 8, 3, 9 }); for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } pair\u0026lt;iterator,bool\u0026gt; insert (const value_type\u0026 val);\ninsert 插入一个pair\u0026lt;key, T\u0026gt;对象\n如果key已经在map中，那么插入失败，返回一个pair\u0026lt;iterator, bool\u0026gt;对象，该对象的 first 是 key 所在结点的迭代器，该对象的second为false 如果key在map中不存在，那么插入成功，返回一个pair\u0026lt;iterator, bool\u0026gt;对象，该对象的 first 是新插入key所在结点的迭代器，该对象的second为true erase （1）可以删除 pos 位置的值，传迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; mp = { 4, 2, 7, 2, 8, 5, 9 }; for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //删除最小值 mp.erase(mp.begin()); for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 一般和 find 配合使用，find 返回的是迭代器，先用 find 查，查到了再删\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; mp = { 4, 2, 7, 2, 8, 5, 9 }; for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //先用find查找，找到了再删 int x; while (cin \u0026gt;\u0026gt; x) { auto pos = mp.find(x); if (pos != mp.end()) { mp.erase(pos); } else { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;不存在!\u0026#34; \u0026lt;\u0026lt; endl; } for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } （2）还可以直接给一个值进行删除，返回删除元素的个数，如果为 0 表示没有删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; mp = { 4, 2, 7, 2, 8, 5, 9 }; for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //直接删除x int x; while(cin \u0026gt;\u0026gt; x) { int num = mp.erase(x); if (num == 0) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;不存在\u0026#34; \u0026lt;\u0026lt; endl; } for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } （3）也可以删除一段迭代器区间的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; mp = { 4, 2, 7, 2, 8, 5, 9 }; for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; mp.erase(mp.find(7), mp.end()); for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } find 和 count **find：**查找一个元素，返回的是迭代器\n算法库中的 find 查找 O(N)，set 自己实现的 find 查找 O(logN)\n**count：**查询元素出现的次数，一般用来判断元素是否存在红黑树中\n如果想查找元素是否在 set 中，我们一般不使用 find，而是 count。因为 find 的返回值是一个迭代器，判断起来不方便\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; mp = { 4, 2, 7, 2, 8, 5, 9 }; for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; int x = 7; //算法库中的find，O(N) auto pos1 = find(mp.begin(), mp.end(), x); //set自己实现的查找，O(logN) auto pos2 = mp.find(x); //使用count快速判断元素是否存在红黑树中 if(mp.count(2)) cout \u0026lt;\u0026lt; \u0026#34;2\u0026#34; \u0026lt;\u0026lt; endl; if(mp.count(1)) cout \u0026lt;\u0026lt; \u0026#34;1\u0026#34; \u0026lt;\u0026lt; endl; if(mp.count(9)) cout \u0026lt;\u0026lt; \u0026#34;9\u0026#34; \u0026lt;\u0026lt; endl; return 0; } lower_bound 和 upper_bound **lower_bound：**大于等于 x 的最小元素，返回的是迭代器。时间复杂度：O（logN）\n**upper_bound：**大于 x 的最小元素，返回的是迭代器。时间复杂度：O(logN)\n使用场景：删掉某个迭代器区间\n由于迭代器区间一般要求左闭右开，所以 lower_bound 的返回值可以作为\u0026quot;左闭\u0026quot;，upperbound 的返回值可以作为\u0026quot;右开\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; myset = { 10, 20, 30, 40, 50, 60, 70, 80, 90}; for (auto e : myset) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //删掉[30, 60]这段区间 auto itlow = myset.lower_bound(30); // 大于等于30的最小元素，返回迭代器 auto itup = myset.upper_bound(60); // 大于60的最小元素，返回迭代器 myset.erase(itlow, itup); for (auto e : myset) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 2.4 multiset 的使用 multiset 和 set 的使用基本完全一致。\nmultiset 和 set 的区别：\nmultiset 里面可以存重复的元素，所以元素放到 multiset 里面相当于只排序了，没有去重。\nmultiset 中 erase 删除时如果传的是某个元素，那么会将 multiset 中所有等于该元素的值都删掉\nmultiset 中 find 查找的值 x 可能有多个，返回的是中序的第一个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { //multiset会排序，但不去重 multiset\u0026lt;int\u0026gt; mp = { 4, 2, 7, 4, 8, 4, 5, 4, 9 }; for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //multiset中x可能存在多个，find找的是中序的第一个 int x; cin \u0026gt;\u0026gt; x; auto pos = mp.find(x); while (pos != mp.end() \u0026amp;\u0026amp; *pos == x) { cout \u0026lt;\u0026lt; *pos \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++pos; } cout \u0026lt;\u0026lt; endl; //multiset中x可能存在多个，erase会删除所有的x mp.erase(x); for (auto e : mp) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } multiset 中 count 返回元素实际出现的次数，而 set 中不会存相同的元素，所以 set 中 count 的结果只会是 1 或 0 2.5 算法题 1.两个数组的交集 题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { //排序+去重 set\u0026lt;int\u0026gt; mp1(nums1.begin(), nums1.end()); set\u0026lt;int\u0026gt; mp2(nums2.begin(), nums2.end()); //依次比较，小的++，相等的就是交集 vector\u0026lt;int\u0026gt; ret; auto it1 = mp1.begin(), it2 = mp2.begin(); while(it1 != mp1.end() \u0026amp;\u0026amp; it2 != mp2.end()) { if(*it1 \u0026lt; *it2) it1++; else if(*it1 \u0026gt; *it2) it2++; else { ret.push_back(*it1); it1++; it2++; } } return ret; } }; 补充：算法库中提供了求并集、交集、差值等集合运算的方法\n求并集、交集，差集的思路\n求并集：放到 set 中，最后留下来的就是并集\n求交集：\n依次比较\n(1）小的++\n(2）相等的就是交集，同时++\n(3）其中一个结束就结束了\n求差集：\n依次比较\n(1）小的就是差集，小的++\n(2）相等就同时++\n(3）其中一个结束就结束了\n应用场景：本地和云端的同步\n2.环形链表 lI 题目\n思路：遍历链表的同时把结点的指针存到 set 中，如果发现该指针已经在 set 中了，说明该指针就是入环的第一个结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { set\u0026lt;ListNode*\u0026gt; mp; ListNode* cur = head; while(cur) { auto ret = mp.insert(cur); if(ret.second == false) return cur; cur = cur-\u0026gt;next; } return nullptr; } }; 3.map / multimap 3.1 基本介绍 文档\nKey：map 底层关键字的类型\nT：map 底层 value 的类型\nCompare：仿函数，默认是按 Key 小于比较\n如果 Key 不支持小于比较或者有别的需求的话，可以自己实现仿函数并传给第二个模版参数\nmap 底层存储数据的内存是从空间配置器申请的\n一般情况下，我们都不需要传后两个模版参数\nmap 底层是用红黑树实现，增删查改效率是 O(logN)\nmap 里面存的是一个 pair\u0026lt;key, value\u0026gt;（k-v 模型），不仅有一个关键字，还会有一个与关键字绑定的值，比较方式是按照 key 的值来比较（排序是按照第一个关键字来比较的）\n3.2 pair 类型介绍 pair 是 C++标准库中的一个模版类，用于将两个值组合成一个单一对象\n通常用于存储键值对或返回多个值\n它有两个公有成员 first 和 second ，分别表示第一个值和第二个值\n我们可以把 pair 理解成 C++为我们提供的一个结构体，里面有两个变量\n1 2 3 4 5 struct pair { type first; type second; }; 使用的时候，可以指定 first 和 second 为我们想要的任意类型\npair\u0026lt;第一个关键字的类型， 第二个关键字的类型\u0026gt;\n1 2 3 4 5 pair\u0026lt;int, int\u0026gt; p1; pair\u0026lt;long long, int\u0026gt; p2; pair\u0026lt;string, int\u0026gt; p3; 解读：\n变量 p1 里面相当于是一个结构体，它里面有两个成员，分别是 first 和 second\n如果我想拿出第一个的值的话，只需要 p1.first\n如果我想拿出第二个的值的话，只需要 p1.second\n但是一般在使用 pair 时会使用 typedef 将类型简化\n1 2 3 4 5 typedef pair\u0026lt;int, int\u0026gt; PII; // 意思是pair的一个参数和第二个参数都是int类型的 PII p1; typedef pair\u0026lt;long long, long long\u0026gt; PLL; PLL p2; 如果一个函数的返回类型是 pair 类型，那么函数的返回值书写形式为 {值 1，值 2}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 typedef pair\u0026lt;int, int\u0026gt; PII; PII find(int x) { for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; p[i].size(); j++) { if(p[i][j] == x) { return {i, j}; } } } } 3.3 map 的构造 map支持拷贝构造、迭代器区间构造、initializer_list构造等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int main() { map\u0026lt;int, int\u0026gt; mp1; map\u0026lt;int, string\u0026gt; mp2; map\u0026lt;string, int\u0026gt; mp3; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; mp4; // 甚至可以挂一个vector pair\u0026lt;string, string\u0026gt; kv1 = { \u0026#34;left\u0026#34;, \u0026#34;左边\u0026#34; }; //initializer_list构造 map\u0026lt;string, string\u0026gt; dict = { kv1, {\u0026#34;right\u0026#34;, \u0026#34;右边\u0026#34;}, {\u0026#34;insert\u0026#34;, \u0026#34;插入\u0026#34;} }; return 0; } （1) map 的支持正向和反向迭代遍历\n遍历默认按 key 的升序顺序，因为底层是二叉搜索树，迭代器遍历走的中序\n支持迭代器就意味着支持范围 for\n（2）map 支持修改 value 数据，不支持修改 key 数据\n因为修改关键字数据，会破坏底层搜索树的结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; int main() { map\u0026lt;string, string\u0026gt; dict = {{ \u0026#34;left\u0026#34;, \u0026#34;左边\u0026#34; }, {\u0026#34;right\u0026#34;, \u0026#34;右边\u0026#34;}, {\u0026#34;insert\u0026#34;, \u0026#34;插入\u0026#34;}}; auto it = dict.begin(); while (it != dict.end()) { //cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; it.operator-\u0026gt;()-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it.operator-\u0026gt;()-\u0026gt;second \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; ++it; } cout \u0026lt;\u0026lt; endl; //范围for遍历 for (const auto\u0026amp; e : dict) { cout \u0026lt;\u0026lt; e.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; return 0; } C++17以后还支持下面这种方式遍历\n1 2 3 4 5 6 7 map\u0026lt;string, string\u0026gt; dict = {{\u0026#34;right\u0026#34;, \u0026#34;右边\u0026#34;}, {\u0026#34;insert\u0026#34;, \u0026#34;插入\u0026#34;}}; for (const auto\u0026amp; [k, v] : dict) { cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; 3.4 map 的增删查 map 增接口，插入的 pair 键值对数据，跟 set 所有不同，但是查和删的接口只用关键字 key 跟 set 是完全类似的，不过 find 返回 iterator，不仅仅可以确认 key 在不在，还找到 key 映射的 value，同时通过迭代还可以修改 value\ninsert insert 向红黑树中插入一个元素，这里需要插入一个pair键值对数据。\n有以下几种插入的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; int main() { map\u0026lt;string, string\u0026gt; dict; //方式一：定义一个pair的有名对象进行插入 pair\u0026lt;string, string\u0026gt; kv1 = { \u0026#34;first\u0026#34;, \u0026#34;第一个\u0026#34; }; dict.insert(kv1); //方式二：插入pair匿名对象 dict.insert(pair\u0026lt;string, string\u0026gt;{\u0026#34;second\u0026#34;, \u0026#34;第二个\u0026#34;}); //方式三：插入 函数模版 make_pair 返回的匿名pair对象 dict.insert(make_pair(\u0026#34;sort\u0026#34;, \u0026#34;排序\u0026#34;)); //方式四：C++11以后，多参数的构造也支持隐式类型转换，写法是使用{} dict.insert(\u0026#34;auto\u0026#34;, \u0026#34;自动的\u0026#34;); return 0; } 使用{}的方式最方便\nmake_pair底层是一个函数模版，传两个参数给它，会自动推导类型，构造并返回匿名的pair对象\n1 2 3 4 5 template \u0026lt;class T1,class T2\u0026gt; inline pair\u0026lt;T1,T2\u0026gt; make_pair (T1 x, T2 y) { return ( pair\u0026lt;T1,T2\u0026gt;(x,y) ); } erase erase 可以删除pos位置（迭代器）的一个元素，可以直接给一个值进行删除，可以删除一段迭代器区间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int main() { map\u0026lt;string, int\u0026gt; mp; //插入 mp.insert({\u0026#34;张三\u0026#34;, 1}); mp.insert({\u0026#34;李四\u0026#34;, 2}); mp.insert({\u0026#34;王五\u0026#34;, 3}); for(auto\u0026amp; p : mp) { cout \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; endl; } //删除 mp.erase(\u0026#34;张三\u0026#34;); // 只用传一个关键字 return 0; } find 和 count find 查找一个元素，返回的是迭代器\ncount 查询元素出现的次数，一般用来判断当前元素是否在map中\n给find一个key，既能判断key是否存在map中，如果存在，还能取key对应的value\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; int main() { map\u0026lt;string, string\u0026gt; dict = { {\u0026#34;first\u0026#34;, \u0026#34;第一个\u0026#34;}, {\u0026#34;second\u0026#34;, \u0026#34;第二个\u0026#34;}, {\u0026#34;auto\u0026#34;, \u0026#34;自动的\u0026#34;} }; for (const auto\u0026amp; e : dict) { cout \u0026lt;\u0026lt; e.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; string str; while (cin \u0026gt;\u0026gt; str) { auto ret = dict.find(str); if (ret != dict.end()) // 判断key在不在 { cout \u0026lt;\u0026lt; \u0026#34;-\u0026gt;\u0026#34; \u0026lt;\u0026lt; ret-\u0026gt;second \u0026lt;\u0026lt; endl; // 找到value } else { cout \u0026lt;\u0026lt; \u0026#34;无此单词，请重新输入\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 3.5 operator[] map重载了operator[]，使得 map 可以像数组一样使用，下标是第一个关键字。\n底层是调用了 insert 函数，并返回 val 的引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Member typeskey_type key_type -\u0026gt; The first template parameter (Key) mapped_type -\u0026gt; The second template parameter (T)value_type value_type -\u0026gt; pair\u0026lt;const key_type,mapped_type\u0026gt; //查找k，返回k所在的迭代器，没有找到返回end（），如果找到了通过iterator可以修改key对应的mapped_type值 iterator find (const key_type\u0026amp; k); pair\u0026lt;iterator,bool\u0026gt; insert (const value_type\u0026amp; val); mapped_type\u0026amp; operator[] (const key_type\u0026amp; k) ; //operator的内部实现 mapped_type\u0026amp; operator[] (const key_type\u0026amp; k) { //1、如果k不在map中，insert会插入k和mapped_type默认值，同时[]返回结点中存储mapped_type值的引用，那么我们可以通过引用修改返映射值。所以[]具备了插入+修改功能 //2、如果k在map中，insert会插入失败，但是insert返回pair对象的first是指向key结迭代器，返回值同时[]返回结点中存储mapped_type值的引用，所以[]具备了查找+修改的功能 pair\u0026lt;iterator, bool\u0026gt; ret = insert({ k, mapped_type() ); iterator it = ret.first; return it-\u0026gt;second; } 例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; int main() { map\u0026lt;string, int\u0026gt; mp = {{\u0026#34;张三\u0026#34;, 1}, {\u0026#34;李四\u0026#34;, 2}, {\u0026#34;王五\u0026#34;, 3}}; //查找 cout \u0026lt;\u0026lt; mp[\u0026#34;张三\u0026#34;] \u0026lt;\u0026lt; endl; // 1 //修改 mp[\u0026#34;张三\u0026#34;] = 110; cout \u0026lt;\u0026lt; mp[\u0026#34;张三\u0026#34;] \u0026lt;\u0026lt; endl; // 110 return 0; } 注意：operator[]有可能会向 map 中插入不想插入的元素\n[]里面的内容如果不存在 map 中，会先插入，然后再拿值\n插入的时候，第一个关键字就是[]里面的内容，第二个关键字是一个默认值 1 2 3 4 5 6 7 8 9 10 // 这里虽然只是判断key对应的value是否等于4， // 但是如果key不存在，那么会插入key，key对应的value为默认值 if(mp[\u0026#34;赵六\u0026#34;] == 4) { cout \u0026lt;\u0026lt; \u0026#34;yes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; } 所以我们调用 operator[]的时候，一定要先判断这个值存不存在 mp 里面(先调用 count)\n正确写法如下：\n1 2 3 4 5 6 7 8 if(mp.count(\u0026#34;赵六\u0026#34;) \u0026amp;\u0026amp; mp[\u0026#34;赵六\u0026#34;] == 4) { cout \u0026lt;\u0026lt; \u0026#34;yes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; } 3.6 multimap 和 map 的差异 multimap支持存入key相同的键值对\nmultimap不支持[]\nmultimap 中 erase 删除时如果传的是某个元素，那么会将 multimap 中所有等于该元素的值都删掉\nfind时，如果有多个key，返回中序第一个\n3.7 算法题 随机链表的复制 题目\n解法一：将结点链入原链表，再把结点剥离出来成一个新链表\n解法二：利用map存储原链表结点和拷贝结点的关系\nmap\u0026lt;Node*, node*\u0026gt; nodeCopyMap;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: Node* copyRandomList(Node* head) { map\u0026lt;Node*, Node*\u0026gt; nodeMap; Node* copyhead = nullptr, *copytail = nullptr; Node* cur = head; while(cur) { if(copytail == nullptr) { copyhead = copytail = new Node(cur-\u0026gt;val); } else { copytail-\u0026gt;next = new Node(cur-\u0026gt;val); copytail = copytail-\u0026gt;next; } //原结点和拷贝结点map kv存储 nodeMap[cur] = copytail; cur = cur-\u0026gt;next; } //处理random cur = head; Node* copy = copyhead; while(cur) { if(cur-\u0026gt;random == nullptr) { copy-\u0026gt;random = nullptr; } else { copy-\u0026gt;random = nodeMap[cur-\u0026gt;random]; } cur = cur-\u0026gt;next; copy = copy-\u0026gt;next; } return copyhead; } }; 前 K 个高频单词 题目\n思路：\n用排序找前k个单词，因为map中已经对key单词排序过，也就意味着遍历map时，次数相同的单词，字典序小的在前面，字典序大的在后面。那么我们将数据放到vector中用一个稳定的排序就可以实现上面特殊要求，但是sort底层是快排，是不稳定的，所以我们要用stable_sort，他是稳定的。\n1.map支持的是双向迭代器，sort要求参数支持随机迭代器\n只有 string，vector，deque，array 这几个才可以用 sort进行排序\n2.稳定性指的是相同的值它们的相对位置不变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: struct Compare { bool operator()(const pair\u0026lt;string, int\u0026gt;\u0026amp; kv1, const pair\u0026lt;string, int\u0026gt;\u0026amp; kv2) { return kv1.second \u0026gt; kv2.second; } }; vector\u0026lt;string\u0026gt; topKFrequent(vector\u0026lt;string\u0026gt;\u0026amp; words, int k) { map\u0026lt;string, int\u0026gt; countMap; for(auto\u0026amp; e : words) { countMap[e]++; } vector\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt; v(countMap.begin(), countMap.end()); stable_sort(v.begin(), v.end(), Compare()); vector\u0026lt;string\u0026gt; retv; for(size_t i = 0; i \u0026lt; k; i++) { retv.push_back(v[i].first); } return retv; } }; 思路2： 将map统计出的次数的数据放到vector中排序，或者放到priority_queue中来选出前k个。利用仿函数强行控制次数相等的，字典序小的在前面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: struct Compare { bool operator()(const pair\u0026lt;string, int\u0026gt;\u0026amp; kv1, const pair\u0026lt;string, int\u0026gt;\u0026amp; kv2) { return kv1.second \u0026gt; kv2.second || (kv1.second == kv2.second \u0026amp;\u0026amp; kv1.first \u0026lt; kv2.first); } }; vector\u0026lt;string\u0026gt; topKFrequent(vector\u0026lt;string\u0026gt;\u0026amp; words, int k) { map\u0026lt;string, int\u0026gt; countMap; for(auto\u0026amp; e : words) { countMap[e]++; } vector\u0026lt;pair\u0026lt;string, int\u0026gt;\u0026gt; v(countMap.begin(), countMap.end()); sort(v.begin(), v.end(), Compare()); vector\u0026lt;string\u0026gt; retv; for(size_t i = 0; i \u0026lt; k; i++) { retv.push_back(v[i].first); } return retv; } }; ","date":"2025-11-04T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/map-and-set/10_hu_24c61040dbfd2f01.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/map-and-set/","title":"【C++进阶】04map和set的使用"},{"content":"前言 C++兼容C语言，C++中文件的后缀为.cpp，VS编译器看到是.cpp就会调用C++编译器编译 Linux下要用g++编译，不再是gcc C++版本更新：革命性的版本更新 C++98 C++11 C++20 第一个C++程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout\u0026lt;\u0026lt; \u0026#34;hello world\\n\u0026#34; \u0026lt;\u0026lt; endl; return0; } 01命名空间 1.1namespace的定义 1）语法：namespace 空间名字{ }\n2）命名空间中可以定义变量、函数、创建结构体、类型等\n​ 要访问这些成员，需要使用域作用限定符::来指定命名空间里的成员\n​ 访问的语法：\n空间名::变量名\n结构体 struct bit::Node node\n函数 返回类型 命名空间名::Add(1, 2);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; namespace dyy { //命名空间中可以定义变量/函数/类型 int rand = 10; int Add(int left, int right) { return left + right; } struct Node { struct Node* next; int val; }; } int main() { printf(\u0026#34;%p\\n\u0026#34;, rand); // ::域作用限定符 printf(\u0026#34;%d\\n\u0026#34;, dyy::rand); // 访问命名空间里的变量 dyy::Add(10, 20); // 访问命名空间里的函数 struct dyy::Node node; // 访问命名空间里的结构体 return 0; } 访问全局变量 : :全局变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int x = 0; namespace dyy { int x = 1; } void func() { int x = 2; } int main() { int x = 3; printf(\u0026#34;%d\\n\u0026#34;, x); // 3，局部优先 printf(\u0026#34;%d\\n\u0026#34;, dyy::x); //1，访问命名空间里的变量 printf(\u0026#34;%d\\n\u0026#34;, ::x); // 0，访问全局的变量 return 0; } 3）本质是定义一个域，做隔离，解决命名冲突的问题，默认不会去里面查找，不同的域可以定义同名的\n4）不会影响生命周期，命名空间里成员的生命周期是全局的，也就是在各个地方都可以用\n5）命名空间只能定义在全局，本质是将全局的进行隔离\n6）namespace可以嵌套，访问时 命名空间1::命名空间2::变量名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; //命名空间可以嵌套 namespace dyy { namespace zhangsan { int rand = 1; int Add(int left, int right) { return left + right; } } namespace lisi { int rand = 2; int Add(int left, int right) { return (left + right) * 10; } } } int main() { printf(\u0026#34;%d\\n\u0026#34;, dyy::zhangsan::rand); // 1 printf(\u0026#34;%d\\n\u0026#34;, dyy::lisi::rand); // 2 printf(\u0026#34;%d\\n\u0026#34;, dyy::zhangsan::Add(1, 2)); // 3 printf(\u0026#34;%d\\n\u0026#34;, dyy::lisi::Add(1, 2)); // 30 return 0; } 1.2C++中的域 1）C++中的域有函数局部域，全局域，命名空间域，类域\n2）C++规定，同一个域不能定义同名变量，不同域可以定义同名变量\n3）默认先在局部域查找，局部域找不到就在全局域查找\n4）命名空间域和类域可以解决命名冲突的问题\n5）局部域，全局域会影响生命周期\n1.3注意 1）默认先在局部域查找，找不到就在全局域查找，要找命名空间里的成员需要指定\n2）局部域的只能在局部访问\n3）项目工程中多文件中定义的同名namespace会认为是一个namespace，不会冲突，会自动合并\n4）C++标准库都放在一个叫std(standard)的命名空间中\n5）查找不到变量/定义，就编译报错：error C2065:\u0026ldquo;a\u0026rdquo;:未声明的标志符\n1.4命名空间的使用 语法1：空间名::变量名\n指定命名空间访问，项目中推荐这种方式\n默认先在局部找，局部找不到，再在全局找，全局找不到，最后还会在命名空间找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; namespace dyy { int a = 0; int b = 1; } int main() { printf(\u0026#34;%d\\n\u0026#34;, dyy::a); // 0 return 0; } 语法2：using namespace 空间名\n展开命名空间，将该域里的东西全部暴露到全局域里面去，同时也就有命名冲突问题的风险\n展开命名空间的全部成员，不推荐，日常小练习中为了方便推荐使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; namespace dyy { int a = 0; int b = 1; } using namespace dyy; //int a = 1; // 命名冲突 int main() { printf(\u0026#34;%d\\n\u0026#34;, a); // 0 return 0; } 语法3： using 空间名::某个变量名等\n展开某个经常访问，且不存在冲突的成员\n使用using将命名空间中某个成员展开，用于项目中经常访问，且不存在冲突\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; //b有命名冲突的风险，且a需要经常访问 namespace dyy { int a = 0; int b = 1; } using dyy::a; // 将命名空间dyy中的a暴露到全局 int b = 2; int main() { printf(\u0026#34;%d\\n\u0026#34;, a); printf(\u0026#34;%d\\n\u0026#34;, a); printf(\u0026#34;%d\\n\u0026#34;, a); printf(\u0026#34;%d\\n\u0026#34;, a); printf(\u0026#34;%d\\n\u0026#34;, a); dyy::b++; printf(\u0026#34;%d\\n\u0026#34;, dyy::b); return 0; } 02输入输出IO流 C++有一套自己的输入输出流\n\u0026lt;iostream\u0026gt;是 lntput Output Stream的缩写，是输入输出流的头文件\n\u0026lt;iostream\u0026gt;包含stdio.h，但在Linux下要包stdio.h\n2.1基本介绍 使用c++输入输出不需要像printf，scanf 那样需要手动指定格式 （只有内存中才有整型，字符，浮点数等），如果需要控制小数点精度就使用printf\n标准库中放在std的命名空间，c表示字符\nstd::cin标准输入流，是istream类的对象\n将字符串拿过来，再进行解析 std::cout标准输出流，是ostream类的对象\n访问cout的第一种方式就是要指定命名空间 无论是什么类型，都把它转换成字符串再进行输出 （cout是console output的简写） std::endl 是一个函数，end line的缩写\n流插入输出时，相当于插入一个换行字符加刷新缓冲区 为什么我们更倾向于使用std::endl而不是C语言中的换行符 \\n ？不同平台下换行符是不一样的 \u0026laquo; 流插入，也可以叫输出，可以自动识别任意类型，让右边流向左边，支持连续的流插入，可以不同的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; int main() { // \u0026lt;\u0026lt;流插入 std::cout \u0026lt;\u0026lt; \u0026#34;hello\\n\u0026#34;; int i = 10; std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; double d = 1.1; std::cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl; return 0; } \u0026gt;\u0026gt; 流提取，std::cin \u0026raquo; i \u0026raquo; d;//从流里面提取字符，再将字符转成整型，转成浮点数\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; int main() { int i = 10; double d = 1.1; std::cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; d; std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl; return 0; } 可以修改输出的精度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { double value = 12.3456789; cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; // 12.3457 //修改输出精度 cout.precision(3); cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; // 12.3 //如果想要这个精度，用来表示小数点后面的位数 cout.flags(cout.fixed); cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; // 12.346 cout.unsetf(cout.fixed); // 取消定点法 cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; // 12.3 return 0; } 2.2 例子 转成字符串\n1 2 3 4 5 std::cout \u0026lt;\u0026lt; \u0026#34;hello world\\n\u0026#34;; std::cout\u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl; //std::endl 换行 注意：\n1、展开全部：日常练习可以使用 using namespace std; 就可以直接使用cout cin endl\n2、展开局部： 或者只展开cout ,endl 例如 using std::cout; using std:: endl\n2.3 提高C++IO效率 1）cin cout的效率会低一些，printf ,scanf,cin,cout都是各自的一套输入输出，底层带缓冲区\nstd::cout \u0026laquo; i \u0026laquo; endl 先将右边的转成字符串，放到缓冲区，遇到一些刷新标志或主动刷新接口才会出去\n典型的刷新标志：换行 主动刷新的接口（比如：flush）\n2）C++的IO流互相有一些绑定关系，比如cin的时候外面有一个cout，cout外面遇到刷新标志，也会把它刷出去\n在io需求比较高的地方，如部分大量输入的竞赛题中，加上以下3行代码，可以提高C++IO效率\n1 2 3 4 5 ios_base::sync_with_stdio(false);//让C/C++不兼容，同步关系关掉 cin.tie(nullptr);//不再跟其他流进行绑定 cout.tie(nullptr); 03缺省参数（默认参数） 3.1基本介绍 声明或定义函数时为函数的形参指定一个值（缺省值）\n在调用该函数时，如果不传参，就调用参数的默认值（缺省值）；如果传了参，那就使用指定的实参\n也就是如果不指定实参，就采用形参的缺省值，否则就使用指定的实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; void Func(int a = 0) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } int main() { Func(); // 没有传参时，使用参数的默认值 Func(10); // 传参时，使用指定的实参 return 0; } 3.2 全缺省 函数有多个参数，我们把每个参数都给一个默认值，就叫全缺省\n例如：void Func1(int a = 10, int b = 20, int c = 30){}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;assert.h\u0026gt; using namespace std; void Func(int a = 0) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } //全缺省 void Func1(int a = 10, int b = 20, int c = 30) { cout \u0026lt;\u0026lt; \u0026#34;a= \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b= \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;c= \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } int main() { Func1(); Func1(1); Func1(1, 2); Func1(1, 2, 3); return 0; } 全缺省函数的调用，更灵活\n注意：不能跳着传参，比如这样 Func1(, 2, ) 的写法是错的\n3.3 半缺省 函数有多个参数，我们只给部分形参给默认值\n注意：规定必须从右往左依次连续缺省，至少传一个\n1 void Func2(int a, int b = 10, int c = 20){} 类似下面的写法是错误的：\n1 void Func2(int a = 10, int b, int c = 20){} 3.4 缺省参数在实践中的意义 在设计栈的时候，可以在栈初始化的时候给栈的空间一个默认值\nStack.h中\n1 void STInit(ST* ps, int n = 4); // 避免了扩容 test.c中\n1 2 3 4 5 6 dyy::ST st; //如果不知道开多大，就使用缺省值 dyy::STInit(\u0026amp;st); //如果知道开多大的空间，就显示地给一个实参 dyy::STInit(\u0026amp;st, 100); 3.5 注意 缺省参数不能在函数声明和定义中同时出现，规定只能在函数声明给缺省值\n原因：编译的时候只包了.h，定义只有在链接的时候才会去找\n04函数重载 C++支持在同一作用域中出现同名函数，\n但要求这些同名函数的 形参的个数、类型，顺序 至少一个不同\n与返回类型无关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; using namespace std; //1.参数类型不同 int Add(int left, int right) { cout \u0026lt;\u0026lt; \u0026#34;int Add(int left, int right)\u0026#34; \u0026lt;\u0026lt; endl; return left + right; } double Add(double left, double right) { cout \u0026lt;\u0026lt; \u0026#34;double Add(double left, double right)\u0026#34; \u0026lt;\u0026lt; endl; return left + right; } //2.参数个数不同 void f() { cout \u0026lt;\u0026lt; \u0026#34;f()\u0026#34; \u0026lt;\u0026lt; endl; } void f(int a) { cout \u0026lt;\u0026lt; \u0026#34;f(int a)\u0026#34; \u0026lt;\u0026lt; endl; } //3.参数类型顺序不同(本质还是类型不同) void f(int a, char b) { cout \u0026lt;\u0026lt; \u0026#34;f(int a, char b)\u0026#34; \u0026lt;\u0026lt; endl; } void f(char b, int a) { cout \u0026lt;\u0026lt; \u0026#34;f(char b, int a)\u0026#34; \u0026lt;\u0026lt; endl; } int main() { Add(10, 20); Add(10.1, 20.1); f(); f(1); f(10, \u0026#39;a\u0026#39;); f(\u0026#39;a\u0026#39;, 10); return 0; } 为什么返回类型不同，不能算作函数重载呢？\n如果函数名和参数列表都相同，但返回值类型不同，编译器无法确定该调用哪个函数。这种情况下会发生编译错误。\n上面这一段代码，语法上能通过，但是存在歧义，编译器不知道调用谁\n一道题\n05引用 5.1基本介绍 引用是给已经存在的变量取别名，相当于一块空间有多个名字，编译器不会为引用变量开辟内存空间\n它和它的引用变量共用同一块内存空间\n语法：==类型\u0026amp; 引用别名= 引用对象;== 例子1： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; //引用就是取别名 int main() { int a = 0; int\u0026amp; b = a; int\u0026amp; c = a; //也可以给别名 b 取别名，d相当于还是 a 的别名 int\u0026amp; d = b; ++d; // a,b,c,d的值都发生变化 return 0; } 例子2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; int main() { int a = 0; int* p1 = \u0026amp;a; int*\u0026amp; p2 = p1; // p2是p1的别名 int e = 10; p2 = \u0026amp;e; // 改变p2就是改变p1 std::cout \u0026lt;\u0026lt; *p1 \u0026lt;\u0026lt; std::endl; // 10 return 0; } 注意：\n引用是给已经存在的变量取别名\ntypedef是给类型取别名，例如：typedef unsigned int unit;\ndefine是定义一个宏的常量，例如：#define N 10; 本质是在预处理的时候把N替换成10\n5.2 引用的特性 1）引用在定义时必须初始化\n2）一个变量可以有多个别名（引用），不能再变成其它变量的别名\n3）引用一旦引用一个实体，就不能再引用其它的实体\n4）引用不能替代指针，引用不能改变指向（在链表中，删除该结点，需要让上一个结点指向下一个结点），java的引用可以改变指向\n5.3 引用的使用 可以给指针变量取别名\n1）引用的第一个作用就是做参数减少拷贝，改变引用对象的同时改变被引用对象\n函数传参时可以不传地址或者拷贝实参，而是将函数的形参写成实参的别名\n例如：\n2）引用的第二个作用 做返回值中减少拷贝，提高效率，减少临时拷贝\n传值返回也会生成拷贝，会将要返回的值拷贝给生成的一个临时对象，再用这个临时对象做函数调用的返回值\n使用指针返回，也可以修改，不过比较麻烦\n**注意：**不是任何场景都能用引用返回\n比如返回局部变量的引用，由于出函数，局部变量就销毁了，所以拿到引用（别名）也没用\n越界不一定会报错\n数组空间在堆上，没有free就不会销毁\nvs中，数组越界是不一定会报错的，越界读不报错，越界写不一定报错，\n一般是抽查，如果没报错，就是没有修改到抽查位\n程序结束时，看是否被修改，修改了就一定越界\n（读一般是获取值，然后打印；写是一种修改行为）\n3）引用和指针不可相互替代，C++引用定义后不能改变指向，java的引用可以改变指向\n5.4 const引用 在有些情况下，我们可能会给被const修饰的变量取别名\n可以引用一个const对象，但必须用const引用。const引用也可以引用普通对象，临时对象\n1）\n1 2 3 4 const int a = 10; //对同一块空间，权限不能放大 //int\u0026amp; ra = a; const int\u0026amp; ra = a; 2）\n1 2 3 4 5 6 //对同一块空间，权限可以缩小 int b = 1; const int\u0026amp; rb = b; //变成别名，不影响原变量的权限 //rb++;//err b++; 3）不是对同一块空间进行权限的修改\n1 2 3 //不是权限的放大，而是把x这块空间拷贝给y，即拷贝赋值 const int x = 0; int y = x;//ok 只有引用和指针存在权限的放大和缩小\n5.5 const与临时对象 传值传参返回的是临时对象\n注意：像int\u0026amp; rb = a * 3; double d = 12.34; int\u0026amp; rb = d;这样一些场景下 ，\n表达式a*3的结果保存在一个临时对象中\nint rd = d也类似，在类型转换中会产生临时对象存储中间值，也就是rb和rd引用的都是临时对象\n而C++规定临时对象具有常性（相当于const修饰），所以这里就触发了权限放大，必须要用常引用才可以。\n5）\n所谓临时对象就是编译器需要⼀个空间 暂存表达式的求值结果 时临时创建的⼀个未命名的对象，C++中把这个未命名对象叫做临时对象。\n使用场景：\n如果函数的形参用const引用修饰，那么可以传的实参就很宽泛，可以传表达式、const对象，普通对象等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void f1(const int\u0026amp; rx) { } int main() { const int x = 20; int a = 10; double d = 3.14; f1(x); f1(a); f1(a * 3); f1(d); return 0; } 5.6 指针与权限 限定的是指向的内容，得引用同一个对象，才有权限的放大和缩小\n1）\n1 2 3 4 5 6 7 const int a = 10;//a的值不能被修改 const int* p1 = \u0026amp;a; //权限不能放大 //int* p2 = p1;//p2可以修改指针指向对象的内容 2）\n1 2 3 4 5 6 7 //权限可以缩小 int b = 20; int* p3 = \u0026amp;b; const int* p4 = p3; 3）\n1 2 3 4 5 6 7 8 9 int b = 20; int* const p4 = \u0026amp;b;//p4的权限是可读可写的 //不存在权限的放大，const修饰的p4本身不是指向的内容，p4本身不能修改， 但将p4拷贝给p5，p5可以修改可以 int* p5 = p4;//p5的权限也是可读可写的 5.7 指针和引用的关系 C++中指针和引用各有特点，互相不可替代，功能有重叠性\n1）语法概念上，引用本质是给一个变量取别名，不开空间；指针是存储一个变量的地址，要开空间；\n2）引用在定义的时候必须初始化，指针建议初始化\n3）引用在初始化时引用一个对象后，就不能再引用其它对象；而指针可以不断地改变指向对象\n4）引用可以直接访问指向的对象，指针需要解引用才能访问\n5）sizeof的含义不同，引用结果为引用类型的大小，但指针始终是地址空间所站的字节个数\n6）指针很容易出现空指针和野指针的问题，引用很少出现，引用使用起来相对安全一些\n野引用的情况：引用做返回值\n底层汇编的角度看，引用要开空间，引用也是用指针的实现的\n6、inline C++中的inline就是要替换C语言的宏\n6.1宏函数 宏可以定义宏的常量，还可以定义宏函数\ndefine 宏可以定义，宏本质是一种替换，ADD(a, b)会替换成((a) + (b))\n#define ADD(a, b) a + b;\n#define ADD(a, b) (a + b);\n正确写法：#define ADD(a, b) ((a) + (b))不能加分号\nint ret = ADD(1,2) ;//int ret = ((1) + (2));\n不能加分号的原因：cout \u0026laquo; ADD(1,2) \u0026laquo; endl;\n必须加外面的括号原因：cout \u0026laquo; ADD(3, 5) * 2 \u0026laquo; endl; //(3)+(5)*2\n本来应该先算3+5，但是如果不加外面的括号就会先算5*2\n必须加里面的括号原因：cout \u0026laquo; ADD(x\u0026y, x|y) \u0026laquo; endl; //x\u0026amp;y+x|y\n由于运算符优先级，所以会先计算y+x\n缺点：复杂很容易出错，且不方便调试\n**优点：**宏本质是一种替换，调用时不用建立栈帧（函数调用是要建立栈帧的）\n6.2 inline 内联函数 C++中可以用inline修饰函数，放在函数返回值的前面，叫内联函数，\n编译时C++编译器会在调用的地方展开内联函数，\n这样调用内联函数就不需要建立栈帧，可以提高效率\ninline对于编译器而言只是一个建议，也就是你加了inline，编译器也可以选择在调用的地方不展开\ninline适用于频繁使用的短小函数，对于递归函数，代码相对多一些的函数，加上inline也会被编译器忽略\n如果函数内部包括循环，递归，代码量大且复杂，则不建议使用内联函数\n1）\n函数的调用本质是，call一个地址，这个地址是一个jmp指令，jmp指令再jmp一下就跳到函数的指令了\n函数编译以后是一段指令，需要存储起来执行，第一句指令的地址就是函数的地址\n内联函数没有地址\n如果在汇编下函数走的是call，就没有建立栈帧，没有展开，内联没有起作用\n2）\ninline对于编译器而言只是一个建议，长的不展开，短的会展开（编译器的防御策略）\n程序是一个个文件，通过编译会生成可执行程序\n可执行程序会以一个进程的角度来进行运行，进程才会给它分配内存\n内联函数缺点：代码膨胀 \u0026mdash;\u0026gt;导致可执行程序变大，加载到进程也会变大\nvs编译器在debug下面默认是不展开inline的，这样方便调试，短小函数在release下默认会展开\ndebug版本想展开需要设置两个地方\n​\t1、项目右键-\u0026gt;属性-\u0026gt;C/C++-\u0026gt;常规-\u0026gt;调试信息格式改为程序数据库\n​\t2、C/C++-\u0026gt;优化-\u0026gt;内联函数扩展改为只适用于inline\ninline不建议声明和定义分离到两个文件，因为内联函数没有地址，分离会导致链接错误。\n因为inline被展开，就没有函数地址，链接时就会出现报错\n在类里的函数，默认是内联\n应该将内联函数的声明和定义直接放到.h文件中\n链接就是只有声明的函数去其它文件找他的地址\n7、nullptr NULL实际是一个宏，在C++里面被定义成0，在C语言中被定义成((void*)0)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void f(int x) { cout \u0026lt;\u0026lt; \u0026#34;f(int x)\u0026#34; \u0026lt;\u0026lt; endl; } void f(int* ptr) { cout \u0026lt;\u0026lt; \u0026#34;f(int* ptr)\u0026#34; \u0026lt;\u0026lt; endl; } int main() { f(0); //f(NULL); //f((void*)0); f(nullptr); return 0; } 上面这段代码中，f(NULL) 和 f(0)都是调用的第一个函数，因为C++中，NULL被定义成0\nnullptr是一个特殊的关键字（值为0），可以转换成任意类型的指针类型\nnullptr只能隐式转换为任意类型的指针，而不能被转换成整数类型\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/start-c-/mountains-1412683_1920_hu_69e95f637eb7df8.png","permalink":"https://Amarantos-Arrebol.github.io/p/start-c-/","title":"【C++初阶】01入门知识"},{"content":"1、类的定义 1.1类的定义格式 语法：\n1 2 3 4 5 6 7 class Stack { //类的成员 }; 1）\ncalss为定义类的关键字，Stack是类的名字{ }中是类的主体，类定义结束时后面的分号不能省略\n2）\n类的成员：类中的变量称为成员变量或类的属性；类中的函数称为类的方法或成员函数\n类里面可以定义函数，类名就是类型\n成员变量一般以 _ 或 m_ 开头\n3）\n定义在类里面的成员函数默认为inline。短小的函数就在类里定义，默认是内联\n4）\nC++中struct也可以定义类，类名就是类型\n访问类里的成员，对象.方法或属性，类型的指针-\u0026gt;方法或属性\n1.2访问限定符 访问修饰符是C++实现封装的方式，用类将对象的属性和方法结合在一块，让对象更加完善\n通过访问权限选择性的将其接口提供给外部的用户使用\n访问限定符限定的是在外部进行的访问，内部都可以访问\n1）\npublic修饰的成员在类外可以直接访问\nprotected和private修饰的成员在类外不能直接被访问（相当于一把锁，锁的是外面的人，自家人不锁）\n在继承章节protected和private才能体现它们的区别\n2）\n访问权限的作用域从该访问限定符出现的位置开始，直到下一个访问限定符出现为止\n如果后面没有访问限定符，作用域就到该类的结束\n规定：成员变量一般都被限定为private/protected，成员函数大多是公有的\n3）\nC++中struct也可以定义类，C++兼容C中struct的用法，同时struct升级成了类（类名就是类型，有访问修饰符），明显的变化是 struct中可以定义函数，但一般情况下，我们还是推荐用class定义类\nclass定义成员没有被访问限定符修饰时默认为private，struct默认为public。\n​\t惯例：一个类如果全部是公有，一般用struct\n2、类域 类定义了一个新的作用域，类的所有成员都在类的作用域中\n在类体外定义成员时，需要使用 :: 作用域操作符指明成员属于哪个类域。\n.h文件放成员变量，成员函数的声明\n.cpp文件放类的定义，要指定类域\n3、类的实例化 变量的声明和定义区分，分配空间的地方才是变量的定义\n用类类型在物理内存中创建对象的过程，称为类的实例化出的对象\n一个类可以实例化n个对象\n类只是声明，实例化出的对象才会开辟空间。类相当于房子的设计图，实例化的对象才是房子实体，可以住人（才能存储有效数据）\n4、类的大小 1、只存成员变量，遵循内存对齐规则，不存成员函数的指针\n2、调用的都是同一个成员函数，成员函数存放在一个公共的区域\n3、函数被编译完后是一段指令，需要存储起来执行，第一句指令的地址就是函数的地址\n4、成员函数的指针/地址是在编译时就确定的，没有存在对象中\n4.1内存对齐 对齐规则：\n1、结构体的第一个成员对齐到结构体变量偏移量为0的地址处\n2、==其它成员变量要对齐到某个数字（对齐数）的整数倍的地址处==\n==对齐数 = 编译器默认的对齐数与该成员大小的较小值==\nVS中对齐数的默认值为8，Linux gcc 没有默认对齐数\n3、==结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍==\n4、如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体\n大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class A { public: void Print() { cout \u0026lt;\u0026lt; _ch \u0026lt;\u0026lt; endl; } private: char _ch; int _i; }; //没有成员变量的类对象，开1byte，占位，不存储有效数据 //标识对象的存在 class B { public: void Print() { //... } }; class C {}; int main() { A a; B b; C c; cout \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(c) \u0026lt;\u0026lt; endl; return 0; } C++中新增：\n1、没有成员变量的类对象，开1Byte，占位，只是为了标识对象的存在，但不存储有效数据。\n​\t开了空间才能证明该对象定义出来了，可以取地址\n2、仿函数类没有成员变量\n4.2为什么要内存对齐？ 1、平台原因（移植原因）\n不是所有硬件平台都能访问任意地址上的任意数据的；\n某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出异常\n（例如：关于整型类型的数据，只能在地址为4的倍数的地址处访问）\n2、性能原因\n数据结构（尤其是栈）应该尽可能地在自然边界上对齐。\n原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要一次访问\n例如：假设32位平台下，未对齐的情况下读int a可能需要读两次，但在对齐的情况下只用读一次\n为了既满足对齐，又要节省空间\n在设计结构体的时候：让占用空间小的成员尽量集中在一起（不一定放前面，尽量集中在一起就行）\n5、this指针 Data类中有Init与Print两个成员函数，函数中没有关于不同对象的区分，也就是几个对象都调用的是同一个函数，那么当d1调用Init和Print函数时，该函数是怎么知道是d1对象的年月日还是d2对象的年月日呢？\nC++给了一个隐含的this指针解决这里的问题\n5.1 this指针介绍 编译器编译后，类的成员函数默认都会在形参的第一个位置，增加一个当前类类型的指针，\n即this指针，this是一个隐含的形参。【形参是在栈区】\n调用的时候，相当于在实参的第一个位置隐含传了一个当前对象的地址/指针\n类的成员函数中访问成员变量，本质都是通过this指针访问的\n5.2 this指针的注意事项 1、this指针由const修饰，是不能修改的\n2、C++规定，不能在实参和形参的位置显示的写this指针，但可以在函数体内显示使用this指针\n3、==成员函数调用的本质就是传递this指针==\n4、this指针存在内存的哪个区域的？栈\nthis指针在非静态的成员函数里面，成员函数没有存储在对象里面，对象不存在\nvs系列编译器，this通过寄存器ecx传递\n5.3练习题 注意：编译错误是语法错误，编译器检查的是语法\n要在p指向的那块空间上访问_a，但p是空指针，解引用会运行崩溃\n成员函数的调用本质是传递this指针\nthis指针是一个隐含的形参\nthis指针在非静态的成员函数里面，成员函数没有存储在对象里面，对象不存在\n函数调用要建立栈帧，函数里要用到的局部变量就要存在栈帧里\n函数参数也是存在栈帧里的\n栈：局部变量，函数参数\n堆：动态内存管理\n静态区：全局变量，静态变量\n6、C++和C语言实现Stack对比 面向对象三大特性：封装，继承，多态\n封装\nC++中数据和方法都放到类里面，可以通过访问限定符进行了限制，不能再随意通过对象直接修改数据\n封装本质是一种更严格规范的管理，避免出现乱访问修改的问题\nC语言中，数据和方法是分离的，通过方法访问数据\n方便的语法\nC++中有一些相对方便的语法，比如 Init 给的缺省参数会方便很多，成员函数每次不需要传对象地址，因为this指针隐含的传递了；使用类型 不再需要typedef 用类名就很方便\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/class-with-object-01/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI-AI%E9%A3%8E%E6%99%AF_hu_ac1979ee0e614df0.png","permalink":"https://Amarantos-Arrebol.github.io/p/class-with-object-01/","title":"【C++初阶】02类和对象（上）"},{"content":"1、类的默认成员函数 默认成员函数就是用户没有显式实现，编译器会自动生成的成员函数\n但有时候编译器默认生成的函数不满足我们的需求，就需要我们自己实现\n一个类，我们不写的情况下，编译器会默认生成以下6个默认成员的函数\nC++11以后还会增加两个默认成员函数，移动构造和移动赋值\n1）初始化和清理\n构造函数：主要完成初始化工作（相当于Init函数）\n析构函数：主要完成清理工作\n2）拷贝赋值\n拷贝构造：使用同类对象初始化创建对象\n赋值重载：把一个对象赋值给另一个对象\n3）取地址重载\n主要是普通对象和const对象取地址，这两个很少会自己实现\n1.1构造函数 是特殊的成员函数，构造函数的主要任务不是开空间创建对象，而是对象实例化时初始化对象\n（我们常使用的局部对象是栈帧创建时，空间就开好了）\n构造函数入门\n1、函数名与类名相同\n1、函数名与类名相同\n2、无返回值（不需要写void）\n3、对象实例化时系统会自动调用对应的构造函数\n4、构造函数可以重载（我们可以写多个构造函数，只要参数不同）\n注意/细节\n1、调用无参构造时，后面不要加( )，加了( )有歧义\n2、构造函数可以缺省参数，但是在下面这种情况，如果全缺省的话，调用会存在歧义\n3、全缺省时调用更方便\n构造函数进阶\n5、如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，\n一旦用户显式定义编译器将不再自动生成一个无参的默认构造函数\n6、下面的三种都叫默认构造\n（1）我们不写构造时，编译器默认生成的构造函数\n（2）我们显示写的无参构造\n（3）全缺省构造函数\n这三个函数有且只能存在一个，不能同时存在\n我们显示写的无参构造和全缺省构造函数，虽然构成重载，但是调用的时候会存在歧义\n**总结：**不传实参就可以调用的构造就叫默认构造\n7、\n编译器默认自动生成的构造，对内置类型成员变量的初始化没有要求，也就是说是否初始化是不确定的，看编译器\n对于自定义类型成员变量，要求调用这个成员变量的默认构造函数初始化\n如果这个成员变量没有默认构造函数，那么就会报错，我们要初始化这个成员变量，需要用初始化列表才能解决\n说明：C++中把类型分为内置类型（基本类型）和自定义类型。\n内置类型就是语言提供的原生数据类型，比如int/char/double/指针等\n自定义类型就是我们使用class/struct等关键字自己定义的类型\n1.2 析构函数 析构函数不是完成对对象本身的销毁，比如局部对象是存在栈帧的，函数结束栈帧销毁，他就释放了，不需要我们管\nC++规定对象在销毁时会自动调用析构函数，完成对象中资源的清理释放工作\n类比我们之前在Stack实现的Destroy功能\n而像Date没有Destroy，其实就是没有资源需要释放，所以严格说Date是不需要析构函数的。\n析构函数特点\n1、析构函数名是在类名前加上字符~\n2、无参数无返回值。（不需要加void）\n3、一个类只能有一个析构函数。若未显示定义，系统会自动生成默认的析构函数\n4、对象生命周期结束时，系统会自动调用析构函数\n5、我们不写，编译器会自动生成析构函数，==对内置类型成员不做处理，自定义类型成员会调用它的析构函数==\n6、对于自定义类型成员也会调用它的析构，也就是自定义类型成员无论什么情况都会自动调用它的析构函数\n7、如果类没有申请资源，析构函数可以不写，直接使用编译器生成的默认析构函数，如Date\n如果默认生成的析构就可以用，也就不需要显示写析构，如MyQueue里的成员stack是自定义类型，默认会自动调用它自己的析构\n但有资源申请时，一定要自己写析构，否则会造成资源泄露，如Stack\n8、一个局部域的多个对象，C++规定后定义的会先析构。\n使用场景：\n1、malloc动态开辟的空间，需要我们手动地去销毁，我们就可以在析构函数中实现\n2、在构造函数fopen了一个文件，那么在析构里我们就可以fclose\n…\n总结：\n一般情况下显示申请了资源（比如栈），才需要自己实现析构，其它情况基本都不需要显示写析构\n1.3拷贝构造 拷贝构造函数：构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值\n拷贝构造是一个特殊的构造函数，完成当前自己类类型的拷贝\n拷贝构造就是用已经存在的对象拷贝给要初始化的对象·\n拷贝构造的特点：\n1、拷贝构造函数是构造函数的一个重载\n注意：\n2、拷贝构造函数的第一个参数必须是自身类类型对象的引用。\n使用传值的方式编译器直接报错，因为语法逻辑上会引发无穷递归调用\n【使用引用/指针就不会调用拷贝构造】\n自定义类型才会调用拷贝构造，而指针是内置类型\n拷贝构造函数也可以多个参数，除了第一个参数，其它额外的参数必须有缺省值\n拷贝构造要用引用传参，最好把const加上\n3、C++规定自定义类型对象进行拷贝行为必须调用拷贝构造，所以这里自定义类型传值传参和传值\n返回都会调用拷贝构造完成\nC++规定：类类型的传值传参必须调用拷贝构造\n4、如果没有显示定义拷贝构造函数，编译器会自动生成拷贝构造函数。\n自动生成的拷贝构造，对内置类型成员变量会完成值拷贝/浅拷贝（一个字节一个字节地拷贝），对自定义类型成员变量会调用它的拷贝构造\n**为什么自定义类型要调用拷贝构造？**原因：C语言传值传参是值/浅拷贝，对于指针可能会析构两次等问题\n浅拷贝和深拷贝，栈使用默认生成的拷贝构造会有问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 typedef int STDataType; class Stack { public: Stack(int n = 4) { _a = (STDataType*)malloc(sizeof(STDataType) * n); if (nullptr == _a) { perror(\u0026#34;malloc 申请空间失败\u0026#34;); return; } _capacity = n; _top = 0; } Stack(const Stack\u0026amp; st) { _a = (STDataType*)malloc(sizeof(STDataType) * st._capacity); if (nullptr == _a) { perror(\u0026#34;malloc 申请空间失败\u0026#34;); return; } memcpy(_a, st._a, sizeof(STDataType) * st._top); _capacity = st._capacity; _top = st._top; } ~Stack() { free(_a); _a = nullptr; _top = _capacity = 0; } private: STDataType* _a; int _capacity; int _top; }; int main() { Stack st(6); Stack st1(st); return 0; } **深拷贝：**不仅拷贝值，还会把指针和指向的资源拷贝\n5、像Date这样的类，成员变量全是内置类型且没有指向什么资源，编译器自动生成的拷贝构造就可以完成需要的拷贝，所以不需要我们显示实现拷贝构造\n像Stack这样的类，虽然也是内置类型，但是_a指向了资源，编译器自动生成的拷贝构造完成的值拷贝/浅拷贝，不符合我们的需求，所以我们自己实现深拷贝（对指向的资源也进行拷贝）\n像MyQueue这样的类型内部主要是自定义类型Stack成员，编译器自动生成的拷贝构造会调用Stack的拷贝构造，也不需要我们显示1实现MyQueue的拷贝构造\n**总结：**如果一个类显示实现了析构并释放资源，那么他就需要显示写拷贝构造\n6、传值返回产生一个临时对象调用拷贝构造，传引用返回，返回的是返回对象的别名（引用），没有产生拷贝\n但是如果返回对象是一个当前函数局部域的局部对象，函数结束就销毁了，那么使用引用返回是有问题的这时的引用相当于一个野引用，类似一个野指针一样。\n传引用返回可以减少拷贝，但是一定要确保返回对象，在当前函数结束后还在，才能引用返回\n2、运算符重载 2.1运算符重载基本介绍 运算符重载是为了让自定义类型能够使用运算符\n1） 当运算符被用于类类型的对象（比如日期类）时，C++语言允许我们通过运算符重载的形式指定新的含义。\n​\tC++规定，类类型对象使用运算符时，必须转换成调用对应运算符重载，若没有对应的运算符重载则会编译报错\n2）运算符重载是具有特殊名字的函数，它的名字由operator和后面要定义的运算符共同构成\n​ 例如等号的运算符重载为operator=。\n​\t和其他函数一样，它也具有其返回类型和参数列表以及函数体\n3）重载运算符函数的参数个数和该运算符作用的运算对象数量?样多。\n⼀元运算符（* ++ \u0026ndash;等）有⼀个参数，⼆元运算符（+ - /等）有两个参数，\n⼆元运算符的左侧运算对象传给第⼀个参数，右侧运算对象传给第⼆个参数。\n4）如果⼀个重载运算符函数是成员函数，则它的第一个运算对象默认传给隐式的this指针，\n因此运算符重载 作为成员函数时，参数比运算对象少?个。\n5）运算符重载以后，其优先级和结合性与对应的内置类型运算符保持⼀致\n6）不能通过连接语法中没有的符号来创建新的操作符：比如operator@。\n7）*. :: sizeof ? : . 注意以上5个运算符不能重载。(选择题里面常考)\n（*可以重载，乘【二元】或解引用【一元】，所以不存在区分问题）\n.*主要是用来调用成员函数的指针\n成员函数有一个隐含的this指针，所以需要加一个类域进行限制：void(A::*pf)()\n8）重载操作符至少有一个类类型参数，不能通过运算符重载改变内置类型对象的含义，\n如：\n9）⼀个类需要重载哪些运算符，是看哪些运算符重载后有意义，\n比如Date类重载operator-就有意义，但是重载operator*就没有意义。\n日期-日期有意义，日期+天数有意义，日期+日期没有意义\n10）重载++运算符时，有前置++和后置++，运算符重载函数名都是operator++，无法很好的分。\nC++规定，后置++重载时，增加一个int形参，跟前置++构成函数重载，方便区分。\n11）重载\u0026laquo;和\u0026raquo;时，需要重载为全局函数。\n如果重载为成员函数，this指针默认抢占了第一个形参位置，第⼀个形参位置是左侧运算对象，调用时就变成了 对象\u0026laquo;cout，不符合使使习惯和可读性。\n重载为全局函数时，把 ostream/istream 的对象放到形参的第一个位置，把当前类类型的对象放形参的第二个位置\n重载\u0026laquo;时，为了支持连续赋值，函数需要返回ostream类型的对象\n例子：\n先在类里声明为友元函数\u0026mdash;\u0026gt;可以调用类的成员\n类外声明\n类外定义\n解决在类外定义的函数不能访问类里私有的成员变量的问题\n1、提供getxxx函数\n2、友元\n3、重载为成员函数（将该函数放到类里面）\n2.2 赋值运算符重载 **赋值运算符重载：**是一个默认成员函数，用于完成两个已经存在的对象直接的拷贝赋值\n**拷贝构造：**用于一个已经存在的对象拷贝初始化给另一个要创建的对象\n赋值运算符重载的特点：\n1、赋值运算符重载是一个运算符重载，规定必须重载为成员函数。\n赋值运算重载的参数建议写成const当前类类型引用，否则传值传参会有拷贝\n2、有返回值，且建议写成当前类类型引用，引用返回可以提高效率(因为传值返回会调用拷贝构造)，\n有返回值目的是为了支持连续赋值场景\n例子：\n细节：自己给自己赋值的情况\n3、没有显示实现时，编译器会自动生成一个默认赋值运算符重载，默认赋值运算符重载\n行为跟默认拷贝构造函数类似，对内置类型成员变量会完成值拷贝/浅拷贝（一个字节\n一个字节地拷贝），对自定义类型成员变量会调用他的赋值重载函数\n栈需要自己实现深拷贝的operator=，因为浅拷贝会导致两个栈指向同一块空间\n4、\n像Date这样的类成员变量全是内置类型且没有指向什么资源，编译器自动生成的赋值运算符重载就\n可以完成需要的拷贝，所以不需要我们显示实现赋值运算符重载。\n像Stack这样的类，虽然也都是内置类型，但是_a指向了资源，编译器自动生成的赋值运算符重载完成的值拷贝/浅拷贝不符合我们的需求，所以需要我们自己实现深拷贝(对指向的资源也进行拷贝)。\n像MyQueue这样的类型内部主要是自定义类型Stack成员，编译器自动生成的赋值运算符重载会调用Stack的赋值运算符重载，也不需要我们显示实现MyQueue的赋值运算符重载。\n**小技巧：**如果⼀个类显示实现了析构并释放资源，那么他就需要显示写赋值运算符重载、拷贝构造，否则就不需要。\n2.5 流插入流提取运算符重载 [4、日期类：4.4流插入流提取重载](##4.4 流插入流提取重载)\n2.4取地址运算符重载 2.4.1const成员函数 被const修饰的成员函数称之为const成员函数，const修饰成员函数参数列表后面\nconst实际修饰该成员函数隐含的this指针（修饰的是指针所指向的内容），\n表明在该函数中不能对类的任何成员进行修改。\n注意：声明和定义中都要修改\n把默认的this指针从Date* const this 改为 const Date* const this\n总结：一个类的成员函数，不修改成员变量的都建议在函数参数列表后面加上const\n2.4.2取地址运算符重载 分为普通取地址重载和const取地址运算符重载\n这两个函数编译器自动生成的就够我们用了，不需要我们去显示实现\n特殊情况：我们不想让别人取到当前类对象的地址，就可以自己实现一份，胡乱返回一个地址\nconst修饰的权限问题\n拷贝的是地址\nd2被const修饰，d2指向的那块空间的内容不能被修改\n但this指针被const修饰后，是指针的指向不能变，也就是那块空间的内容可以修改\n把地址拷贝给this指针后，原本d2指向的那块不能修改的空间可以修改了\n显然不能这么做\n总结：const修饰指向内容的时候才涉及权限放大和缩小问题\n3、构造析构的总结 1、构造一般都需要自己写，自己传参定义初始化\n2、析构，构造时有资源申请（如malloc或者fopen）等，就需要显示写析构函数\n3、拷贝构造和赋值重载，显示写了析构，内部管理资源，就需要显示实现深拷贝\n4、日期类 所有类只要要重载大小，就可以复用\n4.1日期+天数（进位） 先直接将天数相加，然后总天数不断地减去当前月应有的天数，月份不断往上进位\n月满了，年往上进位\n要用进位的方法实现进位的逻辑，首先需要获得每个月的天数\n注意：+不会改变当前日期，+=才会改变当前日期\n4.2日期-天数（借位） 先直接天数相减，如果为负数，那么就向前一个月借天数（当前天数加上上一个月的天数）\n如果上一个月是12月，那么年份要减1\n4.3日期-日期 方式一：\n先算各自年份从1月1日开始到当前月份和日期 有多少天\n再两者相减 \u0026mdash; 结果保存到ret1\n再将两个当年1月1日相减，得到年份，再*365 得到之间天数\n最后统计当中有多少年是闰年，闰年要+1天 \u0026mdash;结果保存到ret2\n最后，ret1+ret2得到日期-日期的天数\n方式二：\n让小的那个日期不断++，看当他的日期和大的日期相等的时候加了多少次，\n就是相差多少天\n4.4 流插入流提取重载 cout是ostream类型的对象\n1 2 3 4 5 6 7 void Date::operator\u0026lt;\u0026lt;(ostream\u0026amp; out) { out \u0026lt;\u0026lt; _year \u0026lt;\u0026lt; \u0026#34;年\u0026#34; \u0026lt;\u0026lt; _month \u0026lt;\u0026lt; \u0026#34;月\u0026#34; \u0026lt;\u0026lt; _day; } 由于如果流提取写在类里面作为成员函数的话，函数的第一个参数默认是this，\n调用的时候就只能 d\u0026laquo;cout不符合我们的使用习惯\n所以，我们把流提取重载写到类外面，将第一个参数设置为ostream\u0026amp; out 第二个\n参数设置为 Date\u0026amp; d\n1 2 3 4 5 6 7 void operator\u0026lt;\u0026lt;(ostream\u0026amp; out, const Date\u0026amp; d) { out \u0026lt;\u0026lt; d._year \u0026lt;\u0026lt; \u0026#34;年\u0026#34; \u0026lt;\u0026lt; d._month \u0026lt;\u0026lt; \u0026#34;月\u0026#34; \u0026lt;\u0026lt; d._day; } 但是在类外面我们是无法访问类里面私有的成员变量的，所以我们需要将该函数在类里\n声明为友元函数\n但是有时候，会遇到这种情况cout \u0026laquo; d1 \u0026laquo; d2 \u0026laquo; endl; 所以我们需要让\u0026laquo;支持连续赋值\n\u0026laquo;是从左往右运算的，也就是先运算cout \u0026laquo; d1，返回的结果是cout；然后再cout \u0026laquo; d2\n所以，我们需要让函数返回ostream类型的引用\nostream类型的对象是不支持拷贝的，out就是cout的别名，出了作用域，out还在，因为cout是全局的\n1 2 3 4 5 6 7 8 9 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, const Date\u0026amp; d) { out \u0026lt;\u0026lt; d._year \u0026lt;\u0026lt; \u0026#34;年\u0026#34; \u0026lt;\u0026lt; d._month \u0026lt;\u0026lt; \u0026#34;月\u0026#34; \u0026lt;\u0026lt; d._day; return out; } \u0026raquo;流提取\ncin是istream类型的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; in, Date\u0026amp; d) { cout \u0026lt;\u0026lt; \u0026#34;请依次输入年月日:\u0026gt;\u0026#34;; in \u0026gt;\u0026gt; d._year \u0026gt;\u0026gt; d._month \u0026gt;\u0026gt; d._day; return in; } 需要注意的是，第二个参数Date\u0026amp; d不能用const修饰，因为提取出来的数据要写入到d中\n4.5检查日期的合法性 可以直接写在类里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 bool CheckDate() { if(_month \u0026lt; 1 || _month \u0026gt; 12 || _day \u0026lt; 1 || _day \u0026gt; GetMonthDay(_year, _month)) { return false; } else { return true; } } 在构造的时候，判断日期是否合法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Date::Date(int year, int month, int day) { _year = year; _month = month; _day = day; if (!CheckDate()) { cout \u0026lt;\u0026lt; \u0026#34;日期非法-\u0026gt;\u0026#34; \u0026lt;\u0026lt; *this \u0026lt;\u0026lt; endl;; } } 在流提取的时候，判断是否合法\n完整代码 Date.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;cassert\u0026gt; using namespace std; class Date { //右元函数声明 friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, const Date\u0026amp; d); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; in, Date\u0026amp; d); public: //缺省值只能在声明时给，不能声明和定义同时给 Date(int year = 1, int month = 1, int day = 1); void Print() const; bool CheckDate() const { if (_month \u0026lt; 1 || _month \u0026gt; 12 || _day \u0026lt; 1 || _day \u0026gt; GetMonthDay(_year, _month)) { return false; } else { return true; } } int GetMonthDay(int year, int month) const { assert(month \u0026gt;= 1 \u0026amp;\u0026amp; month \u0026lt;= 12); //由于该函数会被高频调用，所以这个数组做成静态的 static int monthDayArray[13] = { -1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; //先判断是不是2月，再判断是不是闰年 if (month \u0026lt;mark\u0026gt; 2 \u0026amp;\u0026amp; (year % 4 \u0026lt;/mark\u0026gt; 0 \u0026amp;\u0026amp; year % 100 != 0) || (year % 400 == 0)) { return 29; } return monthDayArray[month]; } //运算符重载 //比较大小 bool operator\u0026lt;(const Date\u0026amp; d) const; bool operator\u0026gt;(const Date\u0026amp; d) const; bool operator\u0026lt;=(const Date\u0026amp; d) const; bool operator\u0026gt;=(const Date\u0026amp; d) const; bool operator==(const Date\u0026amp; d) const; bool operator!=(const Date\u0026amp; d) const; //运算 Date operator+(int day) const; Date\u0026amp; operator+=(int day); Date operator-(int day) const; Date\u0026amp; operator-=(int day); //++-- // 前置++/--，返回++/--以后的值，用引用返回 Date\u0026amp; operator++(); Date operator++(int); Date\u0026amp; operator--(); Date operator--(int); //日期-日期 int operator-(const Date\u0026amp; d) const; //重载流插入、流提取 //void operator\u0026lt;\u0026lt;(ostream\u0026amp; out); private: int _year; int _month; int _day; }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, const Date\u0026amp; d); istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; in, Date\u0026amp; d); Date.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026#34;Date.h\u0026#34; Date::Date(int year, int month, int day) { _year = year; _month = month; _day = day; if (!CheckDate()) { cout \u0026lt;\u0026lt; \u0026#34;日期非法：\u0026#34; \u0026lt;\u0026lt; *this \u0026lt;\u0026lt; endl; } } void Date::Print() const { cout \u0026lt;\u0026lt; _year \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; _month \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; _day \u0026lt;\u0026lt; endl; } bool Date::operator\u0026lt;(const Date\u0026amp; d) const { //年小就小；年相等，月小则小；年月相等，天小则小 if (_year \u0026lt; d._year) return true; else if (_year == d._year \u0026amp;\u0026amp; _month \u0026lt; d._month) return true; else if (_year \u0026lt;mark\u0026gt; d._year \u0026amp;\u0026amp; _month \u0026lt;/mark\u0026gt; d._month \u0026amp;\u0026amp; _day \u0026lt; d._day) return true; return false; } bool Date::operator\u0026gt;(const Date\u0026amp; d) const { return !(*this \u0026lt;= d); } bool Date::operator\u0026lt;=(const Date\u0026amp; d) const { return *this \u0026lt; d || *this == d; } bool Date::operator\u0026gt;=(const Date\u0026amp; d) const { return !(*this \u0026lt; d); } bool Date::operator==(const Date\u0026amp; d) const { return _year == d._year \u0026amp;\u0026amp; _month == d._month \u0026amp;\u0026amp; _day == d._day; } bool Date::operator!=(const Date\u0026amp; d) const { return !(*this == d); } Date Date::operator+(int day) const { Date ret(*this); //ret._day += day; //while (ret._day \u0026gt; GetMonthDay(ret._year, ret._month)) //{ //\tret._day -= GetMonthDay(ret._year, ret._month); //\t++ret._month; //\tif (ret._month == 13) //\t{ //\tret._month = 1; //\tret._year++; //\t} //} //return ret; return ret += day; } Date\u0026amp; Date::operator+=(int day) { if (day \u0026lt; 0) return *this -= -day; _day += day; while (_day \u0026gt; GetMonthDay(_year, _month)) { _day -= GetMonthDay(_year, _month); ++_month; if (_month == 13) { _month = 1; _year++; } } return *this; } //Date\u0026amp; Date::operator+=(int day) //{ //\t*this = *this + day; // //\treturn *this; //} Date\u0026amp; Date::operator-=(int day) { if (day \u0026lt; 0) return *this += -day; _day -= day; while (_day \u0026lt;= 0) { //借上个月的天数 --_month; if (_month == 0) { _month = 12; --_year; } _day += GetMonthDay(_year, _month); } return *this; } Date Date::operator-(int day) const { Date tmp(*this); return tmp -= day; } //前置++ Date\u0026amp; Date::operator++() { return *this += 1; } //后置++ Date Date::operator++(int) { Date ret(*this); *this += 1; return ret; } Date\u0026amp; Date::operator--() { return *this -= 1; } Date Date::operator--(int) { Date ret(*this); *this -= 1; return ret; } //日期-日期 //方法一： //计算 2024 8 10 到 2003 10 20 之间的天数 //2024 8 10 - 2024 1 1 = x1 //2003 10 20 - 2003 1 1 = x2 //(2024-2003)*365 + 闰年的年数 + (x1-x2) //方法二： // 让较小的日期一直++，直到等于较大的日期 //\t期间一共加了多少次，两个日期之间的天数就是多少 int Date::operator-(const Date\u0026amp; d) const { Date max = *this; Date min = d; int flag = 1; if (*this \u0026lt; d) { max = d; min = *this; flag = -1; } int n = 0; while (min \u0026lt; max) { ++min; ++n; } return n * flag; } //// d1 \u0026lt;\u0026lt; cout; ////d1.operator\u0026lt;\u0026lt;(cout); //void Date::operator\u0026lt;\u0026lt;(ostream\u0026amp; out) //{ //\tout \u0026lt;\u0026lt; _year \u0026lt;\u0026lt; \u0026#34;年\u0026#34; \u0026lt;\u0026lt; _month \u0026lt;\u0026lt; \u0026#34;月\u0026#34; \u0026lt;\u0026lt; _day \u0026lt;\u0026lt; \u0026#34;日\u0026#34; \u0026lt;\u0026lt; endl; // //} ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, const Date\u0026amp; d) { out \u0026lt;\u0026lt; d._year \u0026lt;\u0026lt; \u0026#34;年\u0026#34; \u0026lt;\u0026lt; d._month \u0026lt;\u0026lt; \u0026#34;月\u0026#34; \u0026lt;\u0026lt; d._day \u0026lt;\u0026lt; \u0026#34;日\u0026#34; \u0026lt;\u0026lt; endl; return out; } istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; in, Date\u0026amp; d) { while (1) { cout \u0026lt;\u0026lt; \u0026#34;请依次输入年月日:\u0026gt;\u0026#34;; in \u0026gt;\u0026gt; d._year \u0026gt;\u0026gt; d._month \u0026gt;\u0026gt; d._day; if (d.CheckDate()) { break; } else { cout \u0026lt;\u0026lt; \u0026#34;日期非法，请重新输入\u0026#34; \u0026lt;\u0026lt; endl; } } return in; } ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/class-with-object-02/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI-AI%E9%A3%8E%E6%99%AF_hu_ac1979ee0e614df0.png","permalink":"https://Amarantos-Arrebol.github.io/p/class-with-object-02/","title":"【C++初阶】03类和对象（中）"},{"content":"1、再谈构造函数 1.1初始化列表 在讲构造函数的时候，我们提到过编译器默认自动生成的构造，对于自定义类型的成员变量，会调用\n它的默认构造，如果没有默认构造，编译器就会报错，\n所以我们必须初始化这个成员变量，需要用初始化列表才能解决\n语法上可以理解为初始化列表是每个成员变量定义初始化的地方\n1）语法：\n初始化列表的使用是以一个冒号开始，接着是一个以逗号分隔的数据成员列表，\n每个”成员变量“后面跟一个放在括号中的初始值或表达式（可以malloc）\n2）注意/细节：\n每个成员变量在初始化列表中只能出现一次\n（语法上可以理解为初始化列表是每个成员变量定义初始化的地方）\n引用成员变量，const成员变量，没有默认构造的类类型成员变量，（const变量也只能在定义的时候初始化）必须放在初始化列表位置进行初始化，否则会编译报错\n引用只能在定义的时候初始化，const修饰的是不能被修改的，也只能在初始化的时候修改\n没有默认构造，意味着要调用它的构造就只能传参，那么我们就必须初始化 C11支持在成员变量声明的位置给缺省值，这个缺省值主要是给\n没有显示在初始化列表初始化的成员使用的\n尽量使用初始化列表初始化，因为那些你不在初始化列表初始化的成员也会走初始化列表\n对于自定义类型的成员变量：\nC++并没有规定。对于没有显示在初始化列表初始化的自定义类型成员会调用这个成员类型的默认构造函数，如果没有默认构造会编译错误\n对于内置类型的成员：\n如果这个成员在初始化列表没有显示地给值，但是在声明位置给了缺省值，那么，初始化列表会用这个缺省值初始化。【缺省就是备用的意思】\n如果在声明的时候没有给缺省值，那么初始化列表初始化的内置类型成员是否初始化取决于编译器\n1.2 初始化列表总结 每个成员变量都要走初始化列表\n如果在初始化列表中，已经显示地初始化了，那么就用显示初始化的值\n如果在初始化列表中没有显示初始化，那么就用缺省值\n如果没有缺省值，那么内置类型初始化为随机值，自定义类型就调默认构造（如果没有，就编译报错）\n构造函数初始化成员，尽量使用初始化列表\n初始化列表中按照成员变量在类中声明的顺序进行初始化，不是按照成员在初始化列表出现的先后顺序来初始化的。【建议声明顺序和初始化列表顺序保持一致】 2、隐式类型转换 两个类型之间有一定的关联才能互相转换。算术类型之间能互相转，因为它们都表数据大小\n指针和整型之间，指针本质是一个地址的编号，也是表数据的大小\n一个类型，如果支持单参数的构造函数，那这个参数的类型支持隐式类型转换\n单参数的构造函数支持隐式类型转换\n2.1内置类型和自定义类型之间的转换 C++支持内置类型隐式转换为类类型对象，需要有相关内置类型为参数的构造函数\n注意：\n1）类型转换之间会产生临时对象，临时对象具有常性（要加const）\n类型不同的两个变量之间的赋值，是把类型转换之间产生的临时对象拷贝给目标变量\n​\n2）编译器遇到连续构造+拷贝构造-\u0026gt;优化为直接构造\n3）不能通过使用( , )的方式调用多参数的构造\n实际调用的还是单参数的构造\n如果我们希望调用多参数的构造，C++11支持的写法是使用{ }\n在构造函数前面加 explicit 就不再支持隐式类型转换\n2.2类型转换的应用场景 2.3自定义类型和自定义类型之间的转换 类类型的对象之间也可以隐式转换，需要相应的构造函数支持\naa3会构造生成一个临时对象，临时对象再拷贝构造给b，实际上编译器做了优化\n直接构造\n3、static成员 3.1静态成员变量 变量静态成员变量就是被static修饰的成员变量\n静态成员变量遵循 类里声明，类外初始化\n静态成员变量为类的所有对象所共享，不属于某个具体的对象，不存放在对象中，存放在静态区 3.2静态成员函数 普通成员函数有this指针，必须用对象调用\n静态成员函数被static修饰，静态成员函数没有this指针，可以不用对象调用（对象调用也可以）\n它指定类域就可以调用（如果是公有的情况下）\n静态成员函数中可以访问其它静态成员，但是不能访问非静态的，因为没有this指针\n非静态的成员函数，可以访问任意的静态成员变量和静态成员函数\n不用成员函数的类，就可以考虑做成静态成员函数，这样对象可以调，通过类域也可以调\n3.3静态成员的访问和细节 可以通过类名::静态成员 或者对象.静态成员 来访问静态成员变量和静态成员函数\n静态成员也是类的成员，受pubic、protected、private 访问限定符的限制\n访问限定符限制的是类外面去直接访问，在类里面不受限制\n如果想在类外面访问静态成员，可以在类里面提供Get函数，返回静态成员的值\n静态成员变量不能在声明位置给缺省值初始化，因为缺省值是给构造函数初始化列表的，静态成员变量不属于某个对象，不走构造函数初始化列表 4、友元 友元提供了⼀种突破类访问限定符封装的方式\n（想在类外面访问类私有的的成员）\n友元分为：友元函数和友元类，在函数声明或者类声明的前面加friend，\n并且把友元声明放到⼀个类的里面。\n• 外部友元函数可访问类的私有和保护成员，友元函数仅仅是⼀种声明，他不是类的成员函数。\n• 友元函数可以在类定义的任何地方声明，不受类访问限定符限制。\n• ⼀个函数可以是多个类的友元函数。\n友元类\n友元类中的成员函数都可以是另⼀个类的友元函数，都可以访问另⼀个类中的私有和保护成员。 友元类的关系是单向的，不具有交换性，比如A类是B类的友元，但是B类不是A类的友元。\n友元类关系不能传递，如果A是B的友元， B是C的友元，但是A不是C的友元。\n有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。\n耦合度指两个函数的关系，关系越紧密，耦合度就越高\n一般要求：低耦合，高内聚\n5、内部类 如果⼀个类定义在另⼀个类的内部，这个定义在另一个类内部的类就叫做内部类。\n内部类是一个独立的类，不会变为外面类的一部分，sizeof（外部类）不会计算内部类\n内部类会受到外面的类的类域的限制。也就是访问时要带上外面的类域\n还会受到外面类的访问限定符的限制，如果外部类给内部类的访问限定符为private，则在类外访问内部类会报错\n内部类本质是一种封装，当A类跟B类紧密关联，A类实现出来主要就是给B类使用，那么可以考虑把A类设计为B的内部类，如果放到private/protected位置，那么A类就是B类的专属类，其它地方都用不了\n内部类默认是外部类的友元\n6、匿名对象 用类型(实参)定义出来的对象叫匿名对象\n匿名对象调用无参构造时要带上括号，有名对象不用带\n匿名对象的生命周期只在当前行\n匿名对象还可以给函数的自定义类型参数做缺省值\n匿名对象可以被引用，但是匿名对象和临时对象一样，具有常性，需要加const\nconst会延长匿名对象的生命周期\n7、对象拷贝时的编译器优化 现代编译器会为了尽可能提高程序的效率，在不影响正确性的情况下会尽可能减少\n⼀些传参和传返\n赋值时隐式类型转换的优化\n从语法上1先构造一个临时对象，临时对象再拷贝构造给aa0\n编译器优化为直接构造\n传值传参\n不会优化，先aa1构造一个对象，然后aa1拷贝构造一个临时对象作为函数f1的参数\n该临时对象在函数中，属于局部变量，出函数对象就销毁\n传参时，隐式类型，连续构造+拷贝构造-\u0026gt;直接优化为构造\n先用1构造一个A的临时对象，然后用它再去拷贝构造aa\n一个表达式中，连续构造+拷贝构造-\u0026gt;优化为一个构造\n本应该A(2)构造一个匿名对象，再用匿名对象拷贝构造给f1的参数\n传值返回也会优化\n语法上：\n优化为：\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI-AI%E9%A3%8E%E6%99%AF_hu_ac1979ee0e614df0.png","permalink":"https://Amarantos-Arrebol.github.io/p/class-with-object-03/","title":"【C++初阶】04类和对象（下）"},{"content":"1、C/C++内存分布 栈、堆、静态区(数据段)、常量区(代码段) \u0026mdash;虚拟进程地址空间\n程序 \u0026mdash;\u0026ndash; \u0026gt;编译（）\u0026mdash;-\u0026gt;可执行程序，运行起来叫进程\n代码 二进制的机器\n多线程\u0026ndash;每个线程都有一个栈\n一个进程里可能有多个线程\n2、C语言中动态内存管理方式 malloc/calloc/realloc/free\n3、C++内存管理方式 C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理。\n3.1new/delete操作内置类型 new是C++中动态申请空间的关键字，申请的空间在堆中，需要程序员自己释放。\n释放堆区的数据使用关键字delete\n1.new的基本语法\nnew返回的是该数据类型的指针\n动态申请int类型的空间new 数据类型\n1 2 //动态申请int类型的空间 int* ptr4 = new int; 动态申请int类型的空间并初始化new 数据类型()\n1 2 //动态申请int类型的空间并初始化为10 int* ptr5 = new int(10); 动态申请int类型的数组空间new 数据类型[]\n1 2 //动态申请10个int类型的空间 int* ptr6 = new int[3]; 动态申请数组空间并初始化 new 数据类型[]{}\n1 2 3 //动态申请一个数组并初始化 int* ptr7 = new int[3]{1,2,3}; int* ptr8 = new int[5]{1,2,3};//可以不完全初始化 delete的基本语法 释放动态申请的基本数据类型的空间 delete 变量名\n1 2 delete pr4; delete ptr5; 释放动态申请的数组空间 delete[] 数组名\n1 2 delete[] ptr7; delete[] ptr8; 3.2new/delete操作自定义类型 使用malloc只会申请空间，不会调用构造函数来初始化这块空间\n使用new不仅会申请空间，还会调用构造函数初始化这块空间\n使用free只会释放空间，不会调用析构函数来清理资源\n使用delete不仅会释放空间，还会调用析构函数清理资源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { // 只申请空间 A* p1 = (A*)malloc(sizeof(A)); // 申请空间+构造函数 A* p2 = new A;//有默认构造 //没有默认构造，可以传参 A* p3 = new A(1); //只释放空间 free(p1); //析构函数+释放空间 delete p2; delete p3; return 0; } 使用new创建对象数组，会调用多次构造函数\ndelete[] 时会调用多次析构函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { //申请空间+10次构造 A* p6 = new A[10]; delete[] p6; //使用有名对象初始化 A aa1(1); A aa2(2); A* p7 = new A[10]{ aa1, aa2 }; delete[] p6; //使用隐式类型转换初始化对象 A* p8 = new A[10]{ 1, 2, 3 }; delete[] p8; return 0; } 使用new和delete创建单链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct ListNode { int _val; ListNode* _next; ListNode(int val) :_val(val) ,_next(nullptr) {} }; int main() { ListNode* n1 = new ListNode(1); ListNode* n2 = new ListNode(2); ListNode* n3 = new ListNode(3); ListNode* n4 = new ListNode(4); n1-\u0026gt;_next = n2; n2-\u0026gt;_next = n3; n3-\u0026gt;_next = n4; delete n1; delete n2; delete n3; delete n4; return 0; } 4、operator new 与 operator delete函数 operator new 与 operator delete不是运算符重载，就是库里面的一个函数\noperator new本质是对malloc的封装。成功就返回对应指针，失败就抛异常 malloc是失败就返回空 operator new和operator delete 都是库里面全局的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。 */ void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) { // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) { // report no memory // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); } return (p); } operator delete是为了跟operator进行配对\n封装了一个free_dbg的函数，该函数就是free\n因为库里面的free就是一个宏函数，free的底层就是调free_dbg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* operator delete: 该函数最终是通过free来释放空间的 */ void operator delete(void *pUserData) { _CrtMemBlockHeader * pHead; RTCCALLBACK(_RTC_Free_hook, (pUserData, 0)); if (pUserData == NULL) return; _mlock(_HEAP_LOCK); /* block other threads */ __TRY /* get a pointer to memory block header */ pHead = pHdr(pUserData); /* verify block type */ _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-\u0026gt;nBlockUse)); _free_dbg( pUserData, pHead-\u0026gt;nBlockUse ); __FINALLY _munlock(_HEAP_LOCK); /* release other threads */ __END_TRY_FINALLY return; } /* free的实现 */ #define free(p) _free_dbg(p, _NORMAL_BLOCK) 总结：\n通过上述两个全局函数的实现知道，operator new 实际也是通过malloc来申请空间，\n如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，\n如果用户提供该措施就继续申请，否则就抛异常。operator delete 最终是通过free来释放空间的。\n5、new和delete的实现原理 一切代码编译后都是对应的指令\n5.1内置类型 如果申请的是内置类型的空间，new和malloc，delete和free基本类似\n不同的地方是：\nnew/delete申请和释放的是单个元素的空间，new[] 和delete[]申请的是连续空间，\n而且new在申请空间失败时会抛异常，malloc会返回NULL\n5.2自定义类型 new的原理\n调用operator new函数申请空间 在申请的空间上执行构造函数，完成对象的构造 我们也可以直接使用operator new ，operator new 是库里面全局的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class A { public: A(int a = 0) { cout \u0026lt;\u0026lt; \u0026#34;A(int a)\u0026#34; \u0026lt;\u0026lt; endl; } A(const A\u0026amp; aa) :_a1(aa._a1) { cout \u0026lt;\u0026lt; \u0026#34;A(const A\u0026amp; aa)\u0026#34; \u0026lt;\u0026lt; endl; } A\u0026amp; operator=(const A\u0026amp; aa) { cout \u0026lt;\u0026lt; \u0026#34;A\u0026amp; operator=(const A\u0026amp; aa)\u0026#34; \u0026lt;\u0026lt; endl; if (this != \u0026amp;aa) { _a1 = aa._a1; } return *this; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\u0026#34; \u0026lt;\u0026lt; endl; } private: int _a1 = 1; }; int main() { A* p1 = (A*)operator new(sizeof(A)); // 失败会抛异常 return 0; } delete的原理\n在空间上执行析构函数，完成对象中资源的清理工作 调用operator delete函数释放对象的空间 new T[N]的原理\noprator new 是 malloc的封装，operator new[] 是operator new 的封装\n调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请 在申请的空间上执行N次构造函数 delete[]的原理\n在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间 6、定位new表达式(placement-new) 定位new表达式是在已分配的原始内存空间中调用构造函数初始化一个对象。\n使用格式：\nnew (place_address) type即：new (地址/要初始化的那块空间) 类型(初始化的参数) place_address必须是一个指针，initializer-list是类型的初始化列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 //new是库里面的一个全局的函数，返回值是void* //失败了会抛异常，所以不用检查返回值 A* p1 = (A*)operator new(sizeof(A));//不会调构造 //构造函数不支持显示调用 //p1-\u0026gt;A(1); //会对p1指向的那块空间当成A对象调用构造函数初始化 new(p1)A(10);//如果没有参数，new(p1)A; //析构函数支持显示调用 p1-\u0026gt;~A(); operator delete(p1); 构造函数不支持显示调用，要使用定位new\n析构函数支持显示调用，完成资源清理，之后还需要调用operator delete 完成空间的释放\n定位new和显示调用析构是为了支持有的地方为了提高效率，\n申请内存的时候，如果直接使用new，new的底层是operator new 调 malloc，效率比较低。\n自己会去写一个内存池，如果我的空间是从我自己定制的内存池出来的，那就开好空间了\n**注意：**不要交叉申请释放\n比如：new和delete是一对的，operator new和operator delete是一对的，\n而不要让new和opertaor delete一对等\n1 2 3 4 5 6 //对 A* p2 = (A*)operator new(sizeof(A)); new(p2)A(10); p2-\u0026gt;~A(); operator delete(p2); 1 2 3 4 5 6 7 8 int main() { //operator new不会初始化，所以指针是随机值 A* p1 = (A*)operator new(sizeof(A)); delete p1;//~A()释放了一块随机地址的空间 return 0; } 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A { public: A(int a = 0) : _a(a) { cout \u0026lt;\u0026lt; \u0026#34;A():\u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A():\u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; endl; delete _p; } private: int _a; int* _p = new int; }; 下面这段代码运行时，程序会崩溃，因为operator new 只开空间，不调用构造初始化，_p也就没有在指向堆上的一块空间，是野指针。因此，当delete调用析构函数时，清理的是野指针 1 2 3 4 5 6 7 int main() { A* p1 = (A*)operator new(sizeof(A));//只开了空间，没有初始化 delete p1; // 清理了野指针 return 0; } 下面这段代码运行时，程序不会崩溃，因为new会开空间并调用构造完成初始化。虽然我们的A类中没有写_p指针的初始化，但是在类的声明位置给了缺省参数，所以__p指向堆中的一块空间 1 2 3 4 5 6 7 8 9 int main() { A* p1 = new A; //如果只使用free()，会内存泄露 //free(p1);//只会把p1这块空间释放，但是_P指向的那块空间没有释放 delete p1; return 0; } 总结：\n不要忘记释放 不要交错使用 7、malloc/free和new/delete的区别 从用法和功能\nmalloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。\n不同的地方是：\nmalloc和free是函数，new和delete是操作符\nmalloc申请的空间不会初始化，new可以初始化\nmalloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可，如果是多个对象，[]中指定对象个数即可\nmalloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型\nmalloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常\n申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理释放\n总结：\nmalloc和free是函数，new和delete是操作符\nnew申请空间后会初始化\nnew申请空间不需要手动计算字节数，如果有多个对象，[]指定对象个数\nnew申请空间失败，需要捕获异常\nnew在申请空间时会调用构造函数完成对象的初始化\ndelete在释放空间前会调用析构函数完成空间中资源的清理释放\nmalloc返回值是void*，需要强转，new不需要，new后面跟的是空间类型\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-memory-management/05_hu_746d77e70aad2823.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/c-memory-management/","title":"【C++初阶】05内存管理"},{"content":"1.泛型编程 假设我们需要交换两个数，那么就需要写一个交换函数。但是我们可能这次想交换两个整型数据，下次想交换两个浮点型数据等，那么就要求函数参数的类型不同。如果是在C语言中，我们可能需要写不同函数名，不同函数参数，但是需要想很多函数名。而在C++中，我们可以使用函数重载这一特性，也就是函数名相同，函数参数不同。\n使用函数重载，我们就可以写出下面这段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void Swap(int\u0026amp; left, int\u0026amp; right) { int temp = left; left = right; right = temp; } void Swap(double\u0026amp; left, double\u0026amp; right) { double temp = left; left = right; right = temp; } void Swap(char\u0026amp; left, char\u0026amp; right) { char temp = left; left = right; right = temp; } 我们可以发现，在上面这段代码中，我们函数实现的逻辑是完全相同的，只是传给函数的形参类型不同，也就是我们写了大量重复的代码。那有没有办法能解决呢？\n答案是有的，在C++中，我们可以给编译器一个函数模版，然后让编译器随着我们函数参数类型的变化自动生成对应的函数实例。\n我们原先是根据具体的类型来编程的，而现在我们只需要写一个通用的函数模版出来就可以处理不同类型的数据。我们把这种根据广泛数据类型的编程就叫做泛型编程。\n泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础\n2. 函数模版 2.1 函数模版概念 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。\n2.2 函数模版格式 函数模版格式：\n1 2 template\u0026lt;typname T1, typename T2...,typename Tn\u0026gt; 返回类型 函数名（函数参数） 其中typename可以换成class\n函数模版中函数里面的类型一般都用T代替（T是Type的缩写）\n可以定义多个模版参数\n我们现在来写一个交换函数的模版\n1 2 3 4 5 6 7 template\u0026lt;class T1, class T2\u0026gt; //类型 void Swap(T1\u0026amp; left, T2\u0026amp; right) //对象 { T1 tmp = left; left = right; right = temp; } 我们可以测试一下\n1 2 3 4 5 6 7 8 9 10 11 int main() { int x = 0, y = 1; double m = 1.1, n = 2.2; Swap(x, y); Swap(m, n); Swap(x, n); return 0; } 在上面的代码中，我们分别传了（整型，整型），（浮点型，浮点型），（整型，浮点型）\n那么编译器就会根据我们写的函数模版和提供的函数参数类型，推断并生成对应的实例函数\n而不会把所有类型的函数生成，比如我们这个例子中就不会生成char类型的Swap函数\n注意：\n不同类型的参数，调用的不同的函数 模版本质是让编译器当牛马，实例化生成对应的函数 模版不是函数，编译器根据模版实例化生成的才是函数 2.3 函数模版的原理 函数模版是一个蓝图，它本身不是一个函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器\n模版是在编译阶段生成对应函数的，编译器编译成指令后，就没有模版这个概念了，只有对应生成的函数实例了\n在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。\n比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。\n2.4 函数模版实例化 用不同类型的参数使用函数模板时，称为函数模板的实例化。\n函数模版的实例化分为隐式实例化和显式实例化\n以一个加法函数模版为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class T\u0026gt; T Add(const T\u0026amp; left, const T\u0026amp; right) { return left + right; } int main() { int a1 = 10, a2 = 20; double d1 = 10.1, d2 = 20.1; Add(a1, a2); Add(d1, d2); return 0; } 隐式实例化 \u0026ndash; 自动推导类型 隐式实例化就是，编译器会根据我们传的实参自己去推模版参数的实际类型\n1 2 3 //强转 cout \u0026lt;\u0026lt; Add(a1, (int)d1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Add((double)a1, d1) \u0026lt;\u0026lt; endl; 显示实例化 \u0026ndash; 不用推导 在函数名和参数中间加上\u0026lt;\u0026gt;告诉编译器是什么类型\n1 2 cout \u0026lt;\u0026lt; Add\u0026lt;int\u0026gt;(a1, d1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Add\u0026lt;double\u0026gt;(a1, d1) \u0026lt;\u0026lt; endl; 显示实例化的应用场景\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;class T\u0026gt; T* Func(size_t n) { return new T[n]; } int main() { Func\u0026lt;int\u0026gt;(10); Func\u0026lt;double\u0026gt;(10); return 0; } 在上面的场景中，编译器无法推断类型，所以需要我们显示地写\n2.5 模版参数的匹配原则 如果我们既写了函数模版，也写了普通函数，那么编译器会优先匹配谁呢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int Add(int left, int right) { return left + right; } template\u0026lt;class T\u0026gt; T Add(T left, T right) { return (left + right) * 5; } int main() { cout \u0026lt;\u0026lt; Add(1, 2) \u0026lt;\u0026lt; endl; return 0; } 如果函数模版和普通函数同时存在，编译器会优先调用普通函数\n那如果我们就是要调用函数模版呢？我们可以显示调用\n1 cout \u0026lt;\u0026lt; Add\u0026lt;int\u0026gt;(1, 2) \u0026lt;\u0026lt; endl; 如果传的参数和普通函数的参数类型不匹配，那么会调模版\n1 cout \u0026lt;\u0026lt; Add(1.1, 2.2) \u0026lt;\u0026lt; endl; 补充：交换函数我们不需要自己写，库里面有swap函数\n不需要我们自己包头文件，间接被包了\n编译器会先调用更匹配的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int Add(int left, int right) { return left + right; } template\u0026lt;class T\u0026gt; T Add(T left, T right) { return (left + right) * 5; } template\u0026lt;class T1, class T2\u0026gt; T1 Add(T1 left, T2 right) { return (left + right) * 5; } int main() { //优先匹配 template\u0026lt;class T\u0026gt; cout \u0026lt;\u0026lt; Add(1.1, 2.2) \u0026lt;\u0026lt; endl; return 0; } 3. 类模版 3.1 类模版的定义格式 如果一个类中的数据成员的数据类型不能确定，或者是某个成员函数的参数或者返回值的类型不能确定，就必须将此类声明为模板。\n1 2 3 4 5 template\u0026lt;class T1, class T2, ..., class Tn\u0026gt; class 类模版名 { //类内成员定义 }; 例如我们写一个栈的模版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;typename T\u0026gt; class Stack { public: Stack(size_t capacity = 4) { _array = new T[capacity]; _capacity = capacity; _size = 0; } private: T* _array; size_t _capacity; size_t _size; }; 使用类的模版后，我们就可以创建多个存有不同数据类型的栈了。\n而使用typedef或using就只能创建存有同一种数据类型的栈\nC++中喜欢用using替代typedef。\n例如：using STDataType = int;\n3.2 类模版的实例化 类模版一般是显示实例化，即类名\u0026lt;显示传类型\u0026gt; 对象\n类模板名字不是真正的类，而实例化的结果才是真正的类\n1 2 3 4 5 6 7 8 9 int main() { //实例化生成对应的类，这里是两个不同的类型 //Stack是类名，Stack\u0026lt;int\u0026gt;才是类型 Stack\u0026lt;int\u0026gt; st1; //存储int的栈 Stack\u0026lt;double\u0026gt; st2; //存储double的栈 return 0; } 注意：\n模版一般不会声明和定义分离 要么全写在.h要么全写在.cpp ==类模版不能用类名代表类型==，必须加上模版参数才是类型（也就是必须显示调用模版） 如果类模版中的成员函数声明和定义分离写，那么指定类域应该这样写类名::\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template\u0026lt;typename T\u0026gt; class Stack { public: Stack(size_t capacity = 4) { _array = new T[capacity]; _capacity = capacity; _size = 0; } private: T* _array; size_t _capacity; size_t _size; }; //再次声明 template\u0026lt;class T\u0026gt; void Stack\u0026lt;T\u0026gt;::Push(const T\u0026amp; data) { //... _arr[_size++] = data; } 类模板中的成员函数都是函数模板\n4.STL简介 4.1什么是STL STL（standard template libaray 标准模版库）：是C++标准库的重要组成部分。\n不仅是一个可复用的组件库，而且是一个包罗数据结构与算法的软件框架。\nIO流、智能指针、线程库\u0026hellip;不属于STL\n4.2 STL的版本 原始版本\nAlexander Stepanov、Meng Lee 在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使用。\nHP 版本是所有STL实现版本的始祖\nP. J. 版本\n由P. J. Plauger开发，继承自HP版本，被**Windows Visual C++**采用，不能公开或修改，\n缺陷：可读性比较低，符号命名比较怪异。\nRW版本\n由Rouge Wage公司开发，继承自HP版本，被C+ + Builder 采用，不能公开或修改，可读性一般\nSGI版本\n由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版 本。被**GCC(Linux)**采用，可移植性好，可公开、修改甚至贩卖，从命名风格和编程 风格上看，阅读性非常高。我们后面学习STL要阅读部分源代码，主要参考的就是这个版本\n4.3 STL的六大组件 容器 - 就是我们常见的数据结构 算法 - 空间配置器 - 内存池，给容器（数据结构）提供内存，提高效率 迭代器 仿函数 配接器 4.3 STL的重要性 笔试\n面试\n工作\n4.4如何学习STL 学习STL的三种境界\n熟用STL 了解泛型技术的内涵与STL的学理乃至实作 扩充STL 简单总结一下：学习STL的三个境界：能用，明理，能扩展\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/template-basics-and-stl-introduction/09_hu_ff05472c48d52328.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/template-basics-and-stl-introduction/","title":"【C++初阶】06模版初阶+STL简介"},{"content":"String类 1. 标准库中的String 这个网站ctrl+F可以搜索\n1.1string的基本介绍 String不属于STL容器，String产生的比STL早\nString就是串，本质就是字符数组\nString类是一个模版\n原模版叫basic_string\n模版是可以给缺省参数的\n但是我们一般是用string类，是一个模版，只不过被typedef了，是char数组\n除了有string外，C11还新增了u16string ，也是字符数组\n每个字符是16位的char，占两个字节\n还有u32string字符数组，每个字符是4个字节\n为什么要定义成basic-string？\n这与编码有关，因为计算机底层是01，要用计算机表示各种符号字母数字就需要编码，编码的底层就是字符串\n类string支持utf-8，支持变长编码\nstring类在C++标准库中，使用要包含头文件#include\u0026lt;string\u0026gt;\n1.2string类的常用接口（上） 1.常见构造函数\nconstructor函数名称 功能说明 string(); 构造空的string类对象，即空字符串 string(const string\u0026s) ; 用已经存在的string对象拷贝给要初始化的string对象 string(const char* s); 用C风格的字符串来构造string类对象 string(size_t n, char c) ; string类对象中包含n个字符c string(const char* s, n); string(const string\u0026s, size_t pos, size_t len = npos); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //std::string s1; string s1; string s2(\u0026#34;1111112222\u0026#34;); string s3(\u0026#34;123456\u0026#34;, 3); //123 拷贝前n个字符 string s4(\u0026#34;123456\u0026#34;, 1, 3);//234 从下标为1的字符开始拷贝（下标从0开始） //string s3(s2, 1, 3);//122 string s5(100, \u0026#39;x\u0026#39;);//拷贝100个字符x string s6(s2, 4);//从s2下标为4的字符开始拷贝到结束 //下标从0开始，包括第4个字符 string s7(s2, 4, 20);//字符不够，就拷贝到字符串结束 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s5 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s6 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s7 \u0026lt;\u0026lt; endl; string重载了流插入和流提取，可以直接用\n2.2.2 string::npos npos是string里的静态成员变量，所以可以做缺省参数\nsize_t在32位下可以理解为unsigned int ，赋值给size_t的变量 -1 也就是全1\n即整型的最大值\n2.2.3运算符重载operator[] 同时重载了普通对象和const对象 string重载了一个运算符operator[]，可以访问pos位置的字符，如果越界了会报错\nstring::operator重载了两个成员函数，一个是普通的重载，一个是const修饰的重载\n所以它是既可读又可写的接口，如果是const对象调用，那么就不可以修改 如果是普通对象，可以用它来打印字符串，也可以修改字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (size_t i = 0; i \u0026lt; s1.size(); i++) { s1[i]++; } for (size_t i = 0; i \u0026lt; s1.size(); i++) { cout \u0026lt;\u0026lt; s1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 底层相当于是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;string\u0026gt; #include\u0026lt;assert.h\u0026gt; class string { public: char\u0026amp; operator[] (size_t pos) { assert(pos \u0026lt; _size);//加了断言，如果访问时越界了就会报错 return _str[pos]; // 返回的是别名 } private: char* _str; size_t _size; size_t _capacity; }; int main() { //s2.operator[](0) = \u0026#39;x\u0026#39; s2[0] = \u0026#39;x\u0026#39;; s2[5] = \u0026#39;x\u0026#39;; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; for (size_t i = 0; i \u0026lt; s2.size(); i++) { s2[i]++; } cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } 2.2.4 迭代器（一） 迭代器是容器通用的一种遍历方式，是像指针一样的对象\n我们可以定义一个iterator的对象，接收begin()返回第一个字符的位置\n当该对象不等于该字符串有效数据的下一个位置时，我们就得到该字符*it1（有点像我们学过的指针解引用），然后++it1就可以到下一个位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 string s1(\u0026#34;hello world\u0026#34;); //迭代器 //iterator是定义在string这个类域里面的 string::iterator it1 = s1.begin();//begin()返回第一个字符的位置 while (it1 != s1.end())//end返回最后一个有效数据的下一个位置，即返回的是\\0 { cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it1;//到下一个位置 } cout \u0026lt;\u0026lt; endl; //迭代器 string::iterator it1 = s1.begin();//begin()返回第一个字符的位置 while (it1 != s1.end()) { (*it1)--; ++it1; } cout \u0026lt;\u0026lt; endl; 为什么要使用迭代器？\n我们一般喜欢使用下标加方括号的形式，但是下标加方括号的这种方式只适用于string和vector\n因为string和vector底层是连续的物理空间，才能重载[]\n迭代器是所有容器通用的方式，因为像链表这种，通过重载[]来遍历，效率低\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; #include\u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; lt; lt.push_back(1); lt.push_back(2); lt.push_back(3); lt.push_back(4); list\u0026lt;int\u0026gt;::iterator it = lt.begin(); while (it != lt.end())//注意，此处不能用小于，因为空间不是连续的 { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it; } return 0; } 注意：\n迭代器的底层是指针，但是它不等于指针，是运算符重载*\n遍历的时候，循环条件最好写 s.begin() != s.end()\n因为其它容器不像string和vector物理空间是连续的\n1.3 C++11新特性：auto和范围for 1.3.1 auto自动推导类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int i = 0; int j = i; //auto会自动推导类型 auto z = i; // int auto x = 1.1; // double auto p = \u0026amp;i; // int* //auto不能推导出引用 int\u0026amp; r1 = i; auto r2 = r1; // int，r1是i的别名，r1本质上还是int类型 auto\u0026amp; r3 = r1;// int\u0026amp; //auto r4; // 报错 return 0; } 对于一些涉及到比较长的类型（比如迭代器，map），我们就可以使用auto\n1 2 3 4 5 6 7 8 9 #include\u0026lt;map\u0026gt; int main() { std::map\u0026lt;std::string, std::string\u0026gt; dict; //std::map\u0026lt;std::string, std::string\u0026gt;::iterator dit = dict.begin(); auto dit = dict.begin(); return 0; } 总结：auto作用就是简化代码，替代写起来长的类型\nC++20开始支持auto做函数形参\n1 void func(auto x); C++11开始支持auto做返回值\n1 2 3 4 5 auto func() { int x = 0; return x; } 1.3.2 范围for 遍历容器 范围for基本介绍 自动取容器的数据赋值给左边的值（赋值是一种拷贝）\n自动++，自动判断结束。\n范围for是用来遍历容器的（也就是数据结构），底层是迭代器，只有容器才支持迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0； } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; #include\u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; lt; lt.push_back(1); lt.push_back(2); lt.push_back(3); lt.push_back(4); for (auto e : lt) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0； } 使用范围for修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (auto ch : s1) { ch++; // 修改 cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 我们发现在范围for里修改后，在里面确实打印出来的是修改后的值，\n但是出了范围for再打印就是原来的值了。\n原因是，范围for是自动取容器里的数据赋值给左边的值，赋值是\n一种拷贝，所以我们在范围for里修改后，不会影响外面的值\n要是想修改里面的值，因为auto不能自动推导出引用，==所以我们需要使用auto\u0026amp;==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //范围for c++11 for (auto\u0026amp; ch : s1) { ch++; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for (auto ch : s1) { cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 总结范围for有两种情况要用引用：\n要修改数据 容器里面存的是一些比较大的对象，减少拷贝 ==如果是一些比较大的对象使用引用但是不想修改，可以使用const auto\u0026amp;== 范围for只适用于容器和数组\n数组可以使用范围for\n因为范围for底层是迭代器，迭代器的行为跟指针类似\n容器才能支持范围for\n因为容器才支持迭代器，而范围for的底层就是迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a[] = { 1, 2, 3, 4, 5, 6 }; for (auto e : a) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 范围for不能遍历哪些呢?\n比如范围for就不能用来遍历日期类\n1.4 string常用的接口（下） 1.4.1 迭代器（二） 反向迭代器 rebigin指向\\0的前一个字符，rend指向第一个字符的前一个位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); //rbegin指向最后一个位置的前一个位置 string::reverse_iterator rit = s1.rbegin(); //rend指向第一个元素的前一个位置 while (rit != s1.rend()) { cout \u0026lt;\u0026lt; *rit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++rit; // 注意是++ } cout \u0026lt;\u0026lt; endl; return 0; } const 迭代器 const对象无法使用普通的迭代器，要使用const迭代器\nconst对象调用const修饰的begin，返回的是const_iterator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { const string s2(s1); string::const_iterator it1 = s2.begin(); // 返回的是const_iterator while (it1 != s2.end()) { cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it1; } cout \u0026lt;\u0026lt; endl; return 0; } const_iterator可以遍历，不能修改\nconst的反向迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { string s1(\u0026#34;hello world\u0026#34;); //string::const_reverse_iterator rit1 = s2.rbegin(); auto rit1 = s2.rbegin(); while (rit1 != s2.rend()) { cout \u0026lt;\u0026lt; *rit1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++rit1; } cout \u0026lt;\u0026lt; endl; return 0; } cbegin()和const迭代器效果相同\n1.4.2 size和length size和length都是获取string的长度，不包含结尾的\\0，推荐使用size，size是通用的\n（因为对于链表、树等数据结构使用length不太合理）\n1 2 3 4 5 6 7 8 9 int main() { string s1(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; // 11 cout \u0026lt;\u0026lt; s1.length() \u0026lt;\u0026lt; endl;// 11 cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; // 15 实际是16 return 0; } capacity求字符传串能存多少有效字符\n空间不够会扩容\nclear把数据清空，但是一般不清空间\nclear就是把size变为0，capacity没变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; //clear把数据清空，但是一般不清空间 s1.clear(); cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; return 0; } 1.4.3 at访问pos位置的数据 at和operator[]的区别\nat失败后会抛异常，需要捕获；而operator[]是通过断言处理的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { try { string s1(\u0026#34;hello world\u0026#34;); //s1[20]; //程序直接终止，弹窗 s1.at(20); } catch (const exception\u0026amp; e) { cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } return 0; } front和back返回的pos位置字符的引用，也就是可以修改\nfront返回第一个字符，back返回最后一个字符\n不过[0]和[size()-1]可以达到同样的效果\n1.4.4 尾插 push_back尾插 底层：空间不够就扩容\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello\u0026#34;); s1.push_back(\u0026#39;,\u0026#39;); s1.push_back(\u0026#39;w\u0026#39;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } append追加 迭代器区间一定是左闭右开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello\u0026#34;); //尾插一个字符 s1.push_back(\u0026#39;,\u0026#39;); s1.push_back(\u0026#39;w\u0026#39;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //尾插一个字符串 s1.append(\u0026#34;orld\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1.append(10, \u0026#39;!\u0026#39;); // 尾插10个字符\u0026#39;!\u0026#39; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; string s2(\u0026#34;hello world\u0026#34;); //s1.append(s2.begin(), s2.end());//使用迭代器，左闭右开 s1.append(s2.begin() + 6, s2.end()); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } operator+= 1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s3(\u0026#34;hello\u0026#34;); s3 += \u0026#39;,\u0026#39;; s3 += \u0026#34;world\u0026#34;; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; return 0; } 1.4.5 insert pos必须是有效的位置\n1 2 3 4 5 6 7 8 int main() { string s1(\u0026#34;hello world\u0026#34;); s1.insert(5, \u0026#34;xxxx\u0026#34;);//在下标为5处插入一个字符串 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 1.4.6 string的扩容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1; size_t old = s1.capacity(); // 旧的容量 cout \u0026lt;\u0026lt; \u0026#34;capacity:\u0026#34; \u0026lt;\u0026lt; old \u0026lt;\u0026lt; endl; for (size_t i = 0; i \u0026lt; 100; i++) { s1 += \u0026#39;x\u0026#39;; if (s1.capacity() != old) // 如果当前容量和旧的容量不等 { cout \u0026lt;\u0026lt; \u0026#34;capacity:\u0026#34; \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; old = s1.capacity(); } } return 0; } capacity的值没有算\\0\nVS上string的扩容是呈1.5倍扩容\nLinux下扩容是呈2倍扩容\n1.4.7 reserve预留容量 如果我们知道要开多大的空间，那么可以使用reserve\n如果给200的话会开一个比200大的一段空间\n因为每次插入数据可能会有扩容，而扩容需要拷贝旧空间里的数据，\n开辟新空间，释放旧空间，有消耗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 提前开空间，避免扩容 s1.reserve(200); size_t old = s1.capacity(); cout \u0026lt;\u0026lt; \u0026#34;capacity:\u0026#34; \u0026lt;\u0026lt; old \u0026lt;\u0026lt; endl; return 0; } 注意：\nstring的void reserve(size_type n)方法是进行容量调整的\n当n大于string对象的实际容量时，会将string对象的容量扩大\n但是当n小于string对象的实际容量时，具体是将容量缩小还是容量保持不变，C++标准并没有严格限制，具体版本在实现时，实现者可能会处于效率、内存分配策略等因素，自行决定\n在vs2019中，string在实现时，当n小于string对象的实际容量时，容量是不会被缩小的。\n1.4.8 reverse反向/翻转 1.4.9 resize调整大小 resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, charc)用字符c来填充多出的元素空间。\n注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;111111111111111111\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; //删除 // n \u0026lt; size s1.resize(15); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; //插入 // size \u0026lt; n \u0026lt; capacity s1.resize(25); // 如果不指定，那么补的是 \\0 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; // n \u0026gt; capacity s1.resize(40); // 补的是 \\0 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1.capacity() \u0026lt;\u0026lt; endl; return 0; } assign赋值 erase删除 从pos位置开始，删除len个字符\n删除后，后面的字符要往前挪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); s1.insert(5, \u0026#34;xxxx\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1.erase(5, 5); // 从第5个位置开始，删除5个字符 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //头删 s1.erase(0, 1); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //使用迭代器头删 s1.erase(s1.begin()); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } substr取子串 从pos位置开始，取len个字符\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { string s3(\u0026#34;test.cpp.zip\u0026#34;); size_t pos = s3.rfind(\u0026#39;.\u0026#39;); // rfind默认是从后往前找 if (pos != string::npos) { string sub = s3.substr(pos); // 从pos位置开始一直取到结尾 cout \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; endl; } return 0; } find查找字符或字符串 查找字符串或字符，默认从0位置开始查找\n不常用的 replace替换 replace只有平替时效率最高，其它时候需要挪动数据，效率低\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { string s1(\u0026#34;hello world hello bit\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //s1.replace(5, 1, \u0026#34;%%\u0026#34;);//第5个位置开始的1个字符替换成%% //cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //将字符串中所有空格都替换成%% //先通过find找到要替换的字符的下标，然后通过下标替换 size_t i = s1.find(\u0026#39; \u0026#39;);//查找字符串或字符，默认从0位置开始查找 while (i != string::npos) { s1.replace(i, 1, \u0026#34;%%\u0026#34;);//将i位置开始的1个字符替换成%% //替换完后再找下一个字符 i = s1.find(\u0026#39; \u0026#39;, i+2); } cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 下面这种方法同样能实现，空间换时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 string s1(\u0026#34;hello world hello bit\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; string s2; for (auto ch : s1) { if (ch != \u0026#39; \u0026#39;) s2 += ch; else s2 += \u0026#34;%%\u0026#34;; } cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; s1.swap(s2); c_str 取char*类型的str 获取string底层的字符串，主要是为了保持和C语言兼容\n1 2 3 string s1(\u0026#34;hello world\u0026#34;); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // 重载string的流插入 cout \u0026lt;\u0026lt; s1.c_str() \u0026lt;\u0026lt; endl; // 返回string底层的字符串，是内置类型的 使用场景：\n我们现在在写一个C++的程序，但是我们必不可少地需要调用一些C语言的库，\n（C++不是纯的面向对象，它还有面向过程）\n假设我们现在需要打开一个文件进行读，假设我们现在只学了C的库\nfopen要求第一个参数必须是const char*类型，但是我们的文件名是string类型的\n那么现在我们就可以使用 c_str()\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { string s2(\u0026#34;review05.cpp\u0026#34;); FILE* fout = fopen(s2.c_str(), \u0026#34;r\u0026#34;);// fopen的第一个参数必须是const char* char ch = fgetc(fout); while (ch != EOF) { cout \u0026lt;\u0026lt; ch; ch = fgetc(fout); } return 0; } 1 2 3 4 5 6 7 const char* p1 = \u0026#34;xxxxx\u0026#34;; int* p2 = nullptr; //cout是通过函数重载，自动识别类型 //但是const char*不会按照指针类型打印，而是直接解引用对应的字符串 cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (void*)p1 \u0026lt;\u0026lt; endl; // 强转成void*就可以打印 cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; endl; data rfind倒着找 使用场景：\n**需求：**取出文件名的后缀\n后缀一般是 .xxx 但是还有一种可能就是这个文件被压缩了，\n比如test.cpp.zip，此时得到的后缀.cpp.zip显然不是真实的后缀\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { string s3(\u0026#34;test.cpp.zip\u0026#34;); size_t pos = s3.rfind(\u0026#39;.\u0026#39;);// 默认是从后往前找 if (pos != string::npos) { string sub = s3.substr(pos);//从pos位置开始一直截取到字符串末尾 cout \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; endl; } return 0; } find_first_of 找字符串中的是否有任意一个字符在str中，可以理解为find_first_any_of\n1 2 3 4 5 6 7 8 9 10 std::string str (\u0026#34;PLease, replace the vowels in this sentence by asterisks.\u0026#34;); // 看“aeiou”是不是str中的任意一个 std::string::size_type found = str.find_first_of(\u0026#34;aeiou\u0026#34;); while (found!=std::string::npos) { str[found]=\u0026#39;*\u0026#39;; found=str.find_first_of(\u0026#34;aeiou\u0026#34;,found+1); } std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; find_last_of 可以理解为rfind_last_any_of\nfind_first_not_of 不是str中任意一个的保留下来\n1 2 3 4 5 6 7 8 9 std::string str(\u0026#34;Please, replace the vowels in this sentence by asterisks.\u0026#34;); std::size_t found = str.find_first_of(\u0026#34;aeiou\u0026#34;); // 看“aeiou”是不是str中的任意一个 while (found != std::string::npos) { str[found] = \u0026#39;*\u0026#39;; found = str.find_first_not_of(\u0026#34;aeiou\u0026#34;, found + 1); } std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 只有aeiou留下来了\n总结常用的 1.5 和string相关的函数 to_string 将整型、浮点型\u0026hellip;转成字符串\n1 string s3 = to_string(11.11); // 会补齐六位 stoi 将string转成整型\n2. string类的模拟实现 2.1 构造函数+析构函数 \u0026mdash;-\u0026gt;\nstring.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #pragma once #include \u0026lt;iostream\u0026gt; using namespace std; namespace dyy { class string { public: //\tstring(); //缺省参数只能在声明的时候给 string(const char* str = \u0026#34;\u0026#34;); // C语言默认字符串结尾是\\0 ~string(); const char* c_str() const { return _str; } private: char* _str; size_t _size; size_t _capacity; }; } string.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define _CRT_SECURE_NO_WARNINGS 1 #include \u0026#34;string.h\u0026#34; namespace dyy { //string::string() //\t:_str(new char[1] {\u0026#39;\\0\u0026#39;}) // 为了和string(const char* str)析构时delete[] _str配对 //\t, _size(0) //\t, _capacity(0) //{ //} // 注意：初始化列表中是按成员声明的顺序进行初始化 string::string(const char* str) :_size(strlen(str)) { _capacity = _size; _str = new char[_size + 1]; //空间开辟后，还需要把数据拷贝过来 strcpy(_str, str); } string::~string() { delete[] _str; _str = nullptr; _size = 0; _capacity = 0; } } strlen是O(N)的函数，运行时计算，遇到\\0终止\nsizeof是操作符，在编译时计算\n2.2 遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 char\u0026amp; operator[](size_t i) { assert(i \u0026lt; _size); return _str[i]; } const char\u0026amp; operator[](size_t i) const { assert(i \u0026lt; _size); return _str[i]; } size_t size() const { return _size; } 2.3 迭代器 测试：\n2.4插入 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/string-class/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/string-class/","title":"【C++初阶】07string"},{"content":"一、vector的使用 vector是用大小可变的数组实现的\nhttps://legacy.cplusplus.com/reference/vector/vector/\n1.1vector的创建 1 2 3 4 5 6 7 8 9 10 // 创建了一个名为a1的可变长数组，里面都是int类型的数据 vector\u0026lt;int\u0026gt; v1; //创建一个大小为10的可变长数组，初始化为1 vector\u0026lt;int\u0026gt; v2(10, 1); //使用push_back插入数据 v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); vector还可以使用 {} 来初始化\n1 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; 原因是有initializer_list这个对象，只支持遍历，不支持修改\n底层就是开数组空间\n1 2 3 4 5 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; // 隐式类型转换 vector\u0026lt;int\u0026gt; v2({ 1, 2, 3, 4, 5 }); auto il1 = { 1, 2, 3, 4, 5, 6 }; initializer_list\u0026lt;int\u0026gt; il2 = { 1, 2, 3, 4, 5, 6 }; 注意：\n1 2 string s1; vector\u0026lt;char\u0026gt; vs; 这两者不等价\n1.string的char数组后面有\\0 2.接口的功能，string后面可以插入一个字符，也可以插入字符串，所以有push_back，append，+=等，还有c_str\n但是可以这样写 vector\u0026lt;string\u0026gt; vstr; 可以push_back string对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector\u0026lt;string\u0026gt; vstr; string s1 = \u0026#34;张三\u0026#34;; vstr.push_back(s1); vstr.push_back(\u0026#34;李四\u0026#34;); //传引用，减少拷贝 for (const auto\u0026amp; e : vstr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //vstr[0]是string字符串，可以使用+= vstr[0] += \u0026#39;x\u0026#39;; // vstr.operator[](0) 等价于 vstr[0] 即s1 vstr[0] += \u0026#34;apple\u0026#34;; vstr[0][0]++; vstr[0][1]++; // 等价于 vstr.operator[](0).operator[](1)++; for (const auto\u0026amp; e : vstr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 1.2Vector的遍历 重载了[] 遍历的时候可以下标+[] 1 2 3 4 5 for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 可以使用迭代器 1 2 3 4 5 6 7 vector\u0026lt;int\u0026gt;::iterator it1 = v1.begin(); while (it1 != v1.end()) { cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it1; } cout \u0026lt;\u0026lt; endl; 可以使用范围for 1 2 3 4 5 for (auto x : v1) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 1.3常用接口的使用 operator[]越界直接断言 assign assign 就是覆盖的赋值，如果assign的数据比较多，会扩容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; v1.assign({ 10, 20, 30 }); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; insert string支持用下标插入，vector不支持用下标插入，vector都是使用迭代器\n但是迭代器比如begin() + 一个整数，相当于下标插入\n在某个位置插入1个值\n在某个位置插入n个值\n在某个位置插入一段迭代区间的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; v1.insert(v1.begin(), 9); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; v1.insert(v1.begin() + 2, 200); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; erase erase删除一个值，删除一个迭代区间的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3, 4, 5 }; for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; v1.erase(v1.begin() + 2); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; emplace emplace 等价于 insert\nemplace_back 等价于 push_back尾插\n1.4扩容问题 vs下是按1.5倍扩容，g++下是按2倍扩容的\nreserve只负责开辟空间 resize在开空间的同时还会进行初始化，影响size 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void VectorExpand() { size_t sz; vector\u0026lt;int\u0026gt; v; sz = v.capacity(); cout \u0026lt;\u0026lt; \u0026#34;making v grow:\\n\u0026#34;; for (int i = 0; i \u0026lt; 100; i++) { v.push_back(i); if (sz != v.capacity()) { sz = v.capacity(); cout \u0026lt;\u0026lt; \u0026#34;capacity changed: \u0026#34; \u0026lt;\u0026lt; sz \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } 1.6vector\u0026lt;vector\u0026lt;int\u0026raquo; vector\u0026lt;int\u0026gt; ：可变长数组里的元素类型都是int\nvector\u0026lt;vector\u0026lt;int\u0026raquo; ：可变长数组里的类型都是vector\u0026lt;int\u0026gt;\n如何进行访问？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;class T\u0026gt; class vector { public: T\u0026amp; operator[](size_t i) { assert(i \u0026lt; _size); return _a[i]; } private: T* a; size_t _size; size_t _capacity; }; vector\u0026lt;vector\u0026lt;int\u0026raquo; vv\n本质实例化出两个类型\nvector\u0026lt;int\u0026gt;\nvector\u0026lt;vector\u0026lt;int\u0026raquo;\n二、练习题 2.1杨辉三角 杨辉三角\nC语言中动态开辟二维数组，先开一个一维的指针数组，数组里的每个值是指针(int*)\n1 2 3 4 5 int** ptr = (int**)malloc(sizeof(int*) * N); for(int i = 0; i \u0026lt; N; i++) { ptr[i] = (int*)malloc(sizeof(int*)(i + 1)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generate(int numRows) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ret(numRows, vector\u0026lt;int\u0026gt;()); for(int i = 0; i \u0026lt; numRows; i++) { ret[i].resize(i + 1, 1); // 开空间的同时初始化 } //填值 for(int i = 2; i \u0026lt; ret.size(); i++) // 从第3行开始填 { for(int j = 1; j \u0026lt; ret[i].size() - 1; j++) // 只填中间的 { ret[i][j] = ret[i-1][j - 1] + ret[i-1][j]; } } return ret; } }; 三、模拟实现 3.1说明 模版不支持分离到两个文件，分离到两个文件会报链接错误，所以我们这里只写string.h\n我们模拟实现string的时候没有按模版写，所以我们写了string.h和string.cpp\n看stl30这个版本的，看源码：成员变量，构造，成员函数\n该版本的vector是用原生指针做的迭代器\n3.2实现vector的核心框架接口 3.2.1成员变量，构造析构，size()，capacity 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 namespace dyy { template\u0026lt;class T\u0026gt; class vector { public: typedef T* iterator; vector() :_start(nullptr) ,_finish(nullptr) ,_endofstorage(nullptr) { } ~vector() { if (_start) { delete[] _start; _start = _finish = _endofstorage = nullptr; } } size_t size() const { return _finish - _start; } size_t capacity() const { return _endofstorage - _start; } private: iterator _start; iterator _finish; iterator _endofstorage; }; } 3.2.2push_back 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void push_back(const T\u0026amp; x) { ////空间不够，扩容 //if (_finish == _endofstorage) //{ //\treserve(capacity() == 0 ? 4 : capacity() * 2); //} //*_finish = x; //++_finish; //复用insert insert(_finish, x); } 3.2.3reserve 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void reserve(size_t n) { if (n \u0026gt; capacity()) { size_t oldSize = size(); // 记录旧size T* tmp = new T[n]; // 开新空间 if (_start) // 如果是第一次扩容，不需要拷贝旧数据和释放旧空间 { memcpy(tmp, _start, sizeof(T) * oldSize); // 拷贝旧数据 delete[] _start; // 释放旧空间 } _start = tmp; // 指向新空间 _finish = _start + oldSize; // 更新_finish _endofstorage = _start + n; // 更新_endofstorage } } 3.2.4迭代器 要支持迭代器，还需要支持提供迭代器相关的接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 typedef T* iterator; typedef const T* const_iterator; iterator begin() { return _start; } iterator end() { return _finish; } const_iterator begin() const { return _start; } const_iterator end() const { return _finish; } 3.2.5pop_back 1 2 3 4 bool empty() { return _start == _finish; } 3.2.6insert insert如果扩容，那么_start和_finish就不是指向原来的位置了，但是pos还是指向原来那块空间的位置，之后挪动数据就没有挪对了，所以我们需要更新pos\n也就是如果出现了扩容，就需要更新pos\n怎么更新pos？计算相对距离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void insert(iterator pos, const T\u0026amp; x) { //判断pos是否合法 assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt;= _finish); //空间不够，扩容 if (_finish == _endofstorage) { size_t len = pos - _start; // 计算pos和_start之间的相对距离 reserve(capacity() == 0 ? 4 : capacity() * 2); pos = _start + len; // 更新pos } //挪数据 iterator i = _finish - 1; while (i \u0026gt;= pos) { *(i + 1) = *i; --i; } //赋值 *pos = x; ++_finish; } 如果我们想要在外面拿到it的值，是拿不到的，因为 v1.begin()是传值返回，是拷贝了一份的临时变量，const修饰的，还有v1.begin()+2是表达式，也是临时变量，所以用const引用行不通\n可以传值返回，把pos位置的iterator返回来并接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //迭代器失效 iterator insert(iterator pos, const T\u0026amp; x) { //判断pos是否合法 assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt;= _finish); //空间不够，扩容 if (_finish == _endofstorage) { size_t len = pos - _start; // 计算pos和_start之间的相对距离 reserve(capacity() == 0 ? 4 : capacity() * 2); pos = _start + len; // 更新pos } //挪数据 iterator i = _finish - 1; while (i \u0026gt;= pos) { *(i + 1) = *i; --i; } //赋值 *pos = x; ++_finish; return pos; } 3.2.7erase 注意删除数据，导致数据挪动，it已经不是指向之前位置了，所以erase返回pos位置，让外面的更新之后再使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 iterator erase(iterator pos) { assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt; _finish); //后面数据往前挪 iterator i = pos + 1; while (i \u0026lt; _finish) { *(i - 1) = *i; ++i; } --_finish; return pos; } 3.2.8支持initializer_list initializer_list底层是开数组空间，支持迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 vector(initializer_list\u0026lt;T\u0026gt; il) :_start(nullptr) , _finish(nullptr) , _endofstorage(nullptr) { reserve(il.size()); for (auto\u0026amp; e : il) { push_back(e); } } 3.2.9 resize n表示要vector多大，val表示缺省值\n如果n小于等于size，缩小有效元素的个数 如果n大于size，那么考虑扩容reserve，然后让超出原来size的部分赋上缺省值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void resize(size_t n, T val = T()) { if (n \u0026lt;= size()) { _finish = _start + n; } else { reserve(n); //插入数据 while (_finish \u0026lt; _start + n) { *_finish = val; ++_finish; } } } C++对内置类型进行了升级\nint i = int(); int i = int(1); int k(2);\n3.2.10operator[] 普通对象可以调用的operator[] 和 const对象可以调用的operator[]\n1 2 3 4 5 6 7 8 9 10 11 12 13 T\u0026amp; operator[](size_t i) { assert(i \u0026lt; size()); return _start[i]; } const T\u0026amp; operator[](size_t i) const { assert(i \u0026lt; size()); return _start[i]; } 3.3迭代器失效(insert和erase) 使用typeid查看迭代器真正的类型\ntypeid可以获取一个类型或对象的真实类型\ntypeid(vector\\::iterator).name()\n迭代器是像指针一样的类对象\n迭代器失效就是像野指针一样，本质因为一些原因，迭代器不可用\n迭代器失效之后就不能再进行++，解引用等操作\n3.3.1第一种失效：扩容引起的野指针的问题 传入的是迭代器pos，如果扩容，开新空间拷贝旧数据释放旧空间，但是pos指向的还是旧空间，所以之后挪动数据会越界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void insert(iterator pos, const T\u0026amp; x) { assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt;= _finish); //空间不够，扩容 if (_finish == _endofstorage) { size_t len = pos - _start; reserve(capacity() == 0 ? 4 : capacity() * 2); pos = _start + len; } iterator i = _finish - 1; while (i \u0026gt;= pos) { *(i + 1) = *i; --i; } *pos = x; ++_finish; } it作为实参传给形参，形参的改变不会影响实参\n3.3.2第二种失效：删除数据，导致数据挪动，it已经不是指向之前位置了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void erase(iterator pos) { assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt; _finish); //后面数据往前挪 iterator i = pos + 1; while (i \u0026lt; _finish) { *(i - 1) = *i; ++i; } --_finish; } 可能会导致逻辑问题，比如我们删除vector中所有的偶数\n如果vector中的数据是 1 2 2 3 5 类似这样的，那么偶数没有删除完\n如果最后一个数是偶数，_finish\u0026ndash;就相当把最后一个数删除了，然后再让it++，这时it不等于v1.end()，所以就一直往后走，造成越界访问\n此外，insert可能会扩容，erase也可能会缩容\n所以，erase，迭代器也失效，要访问，必须得更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 iterator erase(iterator pos) { assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt; _finish); //后面数据往前挪 iterator i = pos + 1; while (i \u0026lt; _finish) { *(i - 1) = *i; ++i; } --_finish; return pos; } 内置类型默认构造\n1 2 3 int i = int(); int j = int(1); int k(2); 3.5拷贝构造 默认生成的是浅/值拷贝，指向同一块空间，析构时会析构两次\n复用已有的接口\n1 2 3 4 5 6 7 8 9 //v2(v1) vector(const vector\u0026lt;T\u0026gt;\u0026amp; v) { reserve(v.capacity())); for (auto\u0026amp; e : v) { push_back(e); } } 3.6赋值运算符重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void swap(vector\u0026lt;T\u0026gt;\u0026amp; tmp) { std::swap(_start, tmp + _start); std::swap(_finish, tmp + _finish); std::swap(_endofstorage, tmp + _endofstorage); } //v1 = v3 vector\u0026lt;T\u0026gt;\u0026amp; operator=(vector\u0026lt;T\u0026gt; v) { swap(v); return *this; } 3.7迭代区间构造 类模版的成员函数，也可以是一个函数模版\n用一个迭代器区间构造，可以是vector迭代器区间，也可以是其他容器的迭代器区间\n1 2 3 4 5 6 7 8 9 10 //类模版的成员函数，也可以是一个函数模版 template \u0026lt;class InputIterator\u0026gt; vector(InputIterator first, InputIterator last) { while (first != last) { push_back(*first); ++first; } } 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void test_vector7() { vector\u0026lt;int\u0026gt; v1; v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); //可以是自己容器的迭代器区间 vector\u0026lt;int\u0026gt; v2(v1.begin(), v1.end()); for (auto e : v2) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //也可以是其他容器的迭代器区间 string s1(\u0026#34;hello\u0026#34;); vector\u0026lt;int\u0026gt; v3(s1.begin(), s1.end()); for (auto e : v3) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 3.8n个val的构造 1 2 3 4 5 6 7 8 9 10 //n个val构造 vector(size_t n, const T\u0026amp; val = T()) { reserve(n); for (size_t i = 0; i \u0026lt; n; i++) { push_back(val); } } 编译器找最匹配的，会优先匹配模版，而不是n个val\n解决办法：再写一个参数是int的构造函数，构成函数重载\n1 2 3 4 5 6 7 8 9 vector(int n, const T\u0026amp; val = T()) { reserve(n); for (size_t i = 0; i \u0026lt; n; i++) { push_back(val); } } 3.8存string时会出现乱码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void test_vector6() { vector\u0026lt;string\u0026gt; v1; v1.push_back(\u0026#34;1111111111111111111\u0026#34;); v1.push_back(\u0026#34;222222222222222222\u0026#34;); v1.push_back(\u0026#34;333333333333333\u0026#34;); v1.push_back(\u0026#34;44444444444444\u0026#34;); v1.push_back(\u0026#34;44444444444444\u0026#34;); for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } string对象里面还有 _str ,_size, _capacity，_str指向堆里的一块空间\n扩容的时候，拷贝会有问题，是值拷贝，释放旧空间的时候，会导致新空间里的string的str指向空间的数据也被释放\n需要对string对象深拷贝——\u0026gt;将memcpy改成for循环赋值\nstring的赋值运算符重载就是深拷贝\n3.9反向迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 typedef ReverseIterator\u0026lt;iterator, T\u0026amp;, T*\u0026gt; reverse_iterator; typedef ReverseIterator\u0026lt;const_iterator, const T\u0026amp;, const T*\u0026gt; const_reverse_iterator; reverse_iterator rbegin() { return reverse_iterator(end()); } reverse_iterator rend() { return reverse_iterator(begin()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); } const_reverse_iterator rend() const { return const_reverse_iterator(begin()); } 完整代码 iterator.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #pragma once template\u0026lt;class Iterator, class Ref, class Ptr\u0026gt; struct ReverseIterator { typedef ReverseIterator\u0026lt;Iterator, Ref, Ptr\u0026gt; Self; ReverseIterator(Iterator it) :_it(it) { } Ref operator*() { Iterator tmp(_it); return *(--tmp); } Ptr operator-\u0026gt;() { return \u0026amp;(operator*()); } Self\u0026amp; operator++() { --_it; return *this; } Self\u0026amp; operator--() { _it++; return *this; } bool operator!=(const Self\u0026amp; s) { return _it != s._it; } bool operator==(const Self\u0026amp; s) { return _it == s._it; } Iterator _it; }; vector.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 #pragma once #include \u0026lt;cassert\u0026gt; #include \u0026#34;iterator.h\u0026#34; namespace dyy { template\u0026lt;class T\u0026gt; class vector { public: typedef T* iterator; typedef const T* const_iterator; typedef ReverseIterator\u0026lt;iterator, T\u0026amp;, T*\u0026gt; reverse_iterator; typedef ReverseIterator\u0026lt;const_iterator, const T\u0026amp;, const T*\u0026gt; const_reverse_iterator; reverse_iterator rbegin() { return reverse_iterator(end()); } reverse_iterator rend() { return reverse_iterator(begin()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); } const_reverse_iterator rend() const { return const_reverse_iterator(begin()); } iterator begin() { return _start; } iterator end() { return _finish; } const_iterator begin() const { return _start; } const_iterator end() const { return _finish; } vector() :_start(nullptr) ,_finish(nullptr) ,_endofstorage(nullptr) { } //类模版的成员函数，也可以是一个函数模版 template \u0026lt;class InputIterator\u0026gt; vector(InputIterator first, InputIterator last) { while (first != last) { push_back(*first); ++first; } } //vector\u0026lt;int\u0026gt; v4(10, 1) vector(size_t n, const T\u0026amp; val = T()) { reserve(n); for (size_t i = 0; i \u0026lt; n; i++) { push_back(val); } } vector(int n, const T\u0026amp; val = T()) { reserve(n); for (size_t i = 0; i \u0026lt; n; i++) { push_back(val); } } vector(initializer_list\u0026lt;T\u0026gt; il) :_start(nullptr) , _finish(nullptr) , _endofstorage(nullptr) { reserve(il.size()); for (auto\u0026amp; e : il) { push_back(e); } } //v2(v1) vector(const vector\u0026lt;T\u0026gt;\u0026amp; v) { reserve(v.capacity()); for (auto\u0026amp; e : v) { push_back(e); } } void swap(vector\u0026lt;T\u0026gt;\u0026amp; tmp) { std::swap(_start, tmp._start); std::swap(_finish, tmp._finish); std::swap(_endofstorage, tmp._endofstorage); } //v1 = v3 vector\u0026lt;T\u0026gt;\u0026amp; operator=(vector\u0026lt;T\u0026gt; v) { swap(v); return *this; } ~vector() { if (_start) { delete[] _start; _start = _finish = _endofstorage = nullptr; } } T\u0026amp; operator[](size_t i) { assert(i \u0026lt; size()); return _start[i]; } const T\u0026amp; operator[](size_t i) const { assert(i \u0026lt; size()); return _start[i]; } size_t size() const { return _finish - _start; } size_t capacity() const { return _endofstorage - _start; } void resize(size_t n, T val = T()) { if (n \u0026lt;= size()) { _finish = _start + n; } else { //扩容 reserve(n); //插入数据 while (_finish \u0026lt; _start + n) { *_finish = val; ++_finish; } } } void reserve(size_t n) { if (n \u0026gt; capacity()) { size_t oldSize = size(); // 记录旧size T* tmp = new T[n]; // 开新空间 if (_start) // 如果是第一次扩容，不需要拷贝旧数据和释放旧空间 { //memcpy(tmp, _start, sizeof(T) * oldSize); // 拷贝旧数据 for (size_t i = 0; i \u0026lt; oldSize; i++) { tmp[i] = _start[i]; } delete[] _start; // 释放旧空间 } _start = tmp; // 指向新空间 _finish = _start + oldSize; // 更新_finish _endofstorage = _start + n; // 更新_endofstorage } } void push_back(const T\u0026amp; x) { ////空间不够，扩容 //if (_finish == _endofstorage) //{ //\treserve(capacity() == 0 ? 4 : capacity() * 2); //} //*_finish = x; //++_finish; //复用insert insert(_finish, x); } bool empty() { return _start == _finish; } void pop_back() { assert(!empty()); --_finish; } //迭代器失效 iterator insert(iterator pos, const T\u0026amp; x) { //判断pos是否合法 assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt;= _finish); //空间不够，扩容 if (_finish == _endofstorage) { size_t len = pos - _start; // 计算pos和_start之间的相对距离 reserve(capacity() == 0 ? 4 : capacity() * 2); pos = _start + len; // 更新pos } //挪数据 iterator i = _finish - 1; while (i \u0026gt;= pos) { *(i + 1) = *i; --i; } //赋值 *pos = x; ++_finish; return pos; } iterator erase(iterator pos) { assert(pos \u0026gt;= _start \u0026amp;\u0026amp; pos \u0026lt; _finish); //后面数据往前挪 iterator i = pos + 1; while (i \u0026lt; _finish) { *(i - 1) = *i; ++i; } --_finish; return pos; } private: iterator _start = nullptr; iterator _finish = nullptr; iterator _endofstorage = nullptr; }; } ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/vector/13_hu_3987f883505dd09a.png","permalink":"https://Amarantos-Arrebol.github.io/p/vector/","title":"【C++初阶】08vector"},{"content":"一、list的使用 list底层是带头双向循环链表\n1.1list的创建、插入、删除 list的基本创建\n1 2 3 4 5 6 7 list\u0026lt;int\u0026gt; lt1; lt1.push_back(1); lt1.push_back(1); lt1.push_back(1); lt1.push_back(1); list\u0026lt;int\u0026gt; lt2 = { 1, 2, 3, 4, 5 }; 遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 list\u0026lt;int\u0026gt;::iterator it1 = lt1.begin(); while (it1 != lt1.end()) { cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++it1; } cout \u0026lt;\u0026lt; endl; //支持迭代器就支持范围for for (auto e : lt2) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; list的迭代器\n删除某个位置\nlist没有实现find，可以调算法库中的find，传入一段迭代器区间[begin, end)和一个值，如果找到，就返回该位置的迭代器，如果没有找到，就返回迭代器end\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 list\u0026lt;int\u0026gt; lt1 = { 1, 2, 3, 4, 5 }; for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; int x; cin \u0026gt;\u0026gt; x; auto it = find(lt1.begin(), lt1.end(), x); if (it != lt1.end()) { lt1.erase(it); } for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 此外还有reverse逆置链表：例如 lt1.reverse()\nmerge合并两个有序链表：\n1 2 3 4 first.sort(); second.sort(); first.merge(second); // merge之后，second为空 unique去重，需要先让链表有序，再去重\n1.2remove remove删除一个值，可以看成find和erase的结合\nerase需要先查找（find）这个值，有才删\nremove就是这个位置有就删，没有也不会报错\nvoid remove (const value_type\u0026amp; val);\n1.3splice splice 把一个链表的值转移给另一个链表\n1）将list里的元素全部拼接到position的前面\n2）仅将list里的元素的 i 的迭代器对应的元素拼接到position的前面\n3）把list里的一段迭代区间里的元素拼接到position的前面\nsplice可以用来调整链表中结点的顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; lt1 = { 1, 2, 3, 4, 5 }; for (auto x : lt1) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //输入一个值，如果一个值存在，就把它转移到头部 int x; while (cin \u0026gt;\u0026gt; x) { auto pos = find(lt1.begin(), lt1.end(), x); if (pos != lt1.end()) { lt1.splice(lt1.begin(), lt1, pos); } for (auto x : lt1) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } 在vs中ctrl+z加 enter 结束输入(把流的标志设置了一下)，是正常结束，后面的程序继续执行\nctrl+c 本质是把进程kill了\n1.4排序 1）list的sort，默认升序排列，底层是归并排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; lt1 = { 1, 20, 3, -4, 5 }; for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; lt1.sort(); for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 2）如果想要降序需要传仿函数\n仿函数是一个类，重载了operator()\n默认是 less 升序\n如果希望降序排列，需要传一个greater的对象（一般传匿名对象）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; lt1 = { 1, 20, 3, -4, 5 }; for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //降序 /*greater\u0026lt;int\u0026gt; gt; lt1.sort(gt); */ lt1.sort(greater\u0026lt;int\u0026gt;()); // 一般传匿名对象 for (auto e : lt1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } vector需要调算法库中的sort\n默认是升序，参数传一个仿函数就可以降序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; v1 = { 1, 20, 3, -4, 5 }; for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //sort(v1.begin(), v1.end());//升序 sort(v1.begin(), v1.end(), greater\u0026lt;int\u0026gt;());//降序 for (auto e : v1) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 1.5迭代器的功能划分 为什么list要自己有一个sort呢，算法库中不是有一个sort了吗？\n从上到下，从父到子\n单向迭代器：只支持++ 比如forwad_list/unordered_xxx 双向迭代器：支持++和\u0026ndash; 比如list (底层是归并排序) 随机迭代器：支持++、\u0026ndash;、+和- 比如string/vector 算法库中的sort要求传随机迭代器，sort底层是快排，需要随机访问\n迭代器从使用方面来划分：\n普通迭代器，const迭代器，反向迭代器，const反向迭代器\n1.6emplace_back和push_back的区别 emplace_back和push_back差不多\nemplace_front和push_front差不多\n涉及到可变模版参数\npush_back传自定义类型的时候，必须传一个对象\nemplace_back是一个模版，可以传多个参数，根据实参推形参\nemplace_back不能走隐式类型转换\npush_back进去的值是要去初始化T对象的，实参是一个{}也就是initializer_list，无法用来初始化T对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Pos { int _row; int _col; public: Pos(int row, int col) :_row(row) ,_col(col) { } }; int main() { list\u0026lt;Pos\u0026gt; lt; Pos p1(1, 1); lt.push_back(p1);//有名对象 lt.push_back(Pos(2, 2));//匿名对象 lt.push_back({ 3, 3 }); // 隐式类型转换 lt.emplace_back(p1); lt.emplace_back(Pos(2, 2)); //lt.emplace_back({ 3, 3 }); // 不支持隐式类型转换，因为类型不确定 lt.emplace_back(3, 3); return 0; } 相当于lt.emplace_back(3, 3);是用两个整型直接构造\n而lt.emplace_back({ 3, 3 });是先用两个整型构造一个Pos对象，然后再拷贝构造\n对于隐式类型转换，emplace_back比push_back更高效\n二、list的模拟实现 list是 带头双向循环链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #pragma once #include \u0026lt;assert.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; namespace dyy { //全部都是公有，一般用struct template\u0026lt;class T\u0026gt; struct list_node { T _data; list_node\u0026lt;T\u0026gt;* _next; list_node\u0026lt;T\u0026gt;* _prev; list_node(const T\u0026amp; x = T()) :_data(x) , _next(nullptr) , _prev(nullptr) {} }; template\u0026lt;class T\u0026gt; class list { typedef list_node\u0026lt;T\u0026gt; Node; public: void empty_init() { _head = new Node(); _head-\u0026gt;_next = _head; _head-\u0026gt;_prev = _head; _size = 0; } list() { empty_init(); } private: Node* _head; size_t _size; }; } 2.1核心接口 尾插 1 2 3 4 5 6 7 8 9 10 11 void push_back(const T\u0026amp; x) { Node* new_node = new Node(x); Node* tail = _head-\u0026gt;_prev; tail-\u0026gt;_next = new_node; new_node-\u0026gt;_prev = tail; new_node-\u0026gt;_next = _head; _head-\u0026gt;_prev = new_node; } insert insert在pos位置之前插入数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 iterator insert(iterator pos, const T\u0026amp; val) { Node* new_node = new Node(val); Node* cur = pos._node; Node* prev = cur-\u0026gt;_prev; //prev new_node cur new_node-\u0026gt;_next = cur; cur-\u0026gt;_prev = new_node; prev-\u0026gt;_next = new_node; new_node-\u0026gt;_prev = prev; ++_size; return iterator(new_node); } erase失效 erase有迭代器失效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 iterator erase(iterator pos) { assert(pos != end()); Node* del = pos._node; Node* prev = del-\u0026gt;_prev; Node* next = del-\u0026gt;_next; prev-\u0026gt;_next = next; next-\u0026gt;_prev = prev; delete del; --_size; return iterator(next); } 头插头删尾插尾删 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void push_back(const T\u0026amp; x) { insert(end(), x); } void push_front(const T\u0026amp; x) { insert(begin(), x); } void pop_front() { erase(begin()); } void pop_back() { erase(--end()); } clear和析构 clear把所有的值删掉，但是不删除哨兵位的头节点\n析构不仅要把所有的值删掉，还有删除哨兵位的头结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ~list() { clear(); delete _head; _head = nullptr; } void clear() { auto it = begin(); while (it != end()) { it = erase(it); } } 2.2迭代器 直接提供迭代器相关的接口行不通，需要重载++，\u0026ndash;，*等，因为++迭代器我们是希望走到下一个节点，*迭代器我们是希望得到里面的值而不是得到结点，也就是我们需要将结点用类封装起来，重载运算符\n2.2.1普通迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 template\u0026lt;class T\u0026gt; struct list_iterator { typedef list_node\u0026lt;T\u0026gt; Node; typedef list_iterator\u0026lt;T\u0026gt; Self; Node* _node; list_iterator(Node* node) :_node(node) { } T\u0026amp; operator*() { return _node-\u0026gt;_data; } T* operator-\u0026gt;() { return \u0026amp;_node-\u0026gt;_data; } //前置++返回自己类型的值 Self\u0026amp; operator++() { _node = _node-\u0026gt;_next; return *this; } Self\u0026amp; operator--() { _node = _node-\u0026gt;_prev; return *this; } //后置 Self operator++(int) { Self tmp(*this); _node = _node-\u0026gt;_next; return tmp; } Self operator--(int) { Self tmp(*this); _node = _node-\u0026gt;_prev; return tmp; } bool operator != (const Self \u0026amp; s) { return _node != s._node; } }; List中\n1 2 3 4 5 6 7 8 9 10 11 typedef list_iterator\u0026lt;T\u0026gt; iterator; iterator begin() { return iterator(_head-\u0026gt;_next); } iterator end() { return iterator(_head); } 重载-\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026#34;list.h\u0026#34; struct Pos { public: int _row; int _col; Pos(int row = 0, int col = 0) :_row(row) ,_col(col) {} Pos(const Pos\u0026amp; p) :_row(p._row) , _col(p._col) {} }; int main() { dyy::list\u0026lt;Pos\u0026gt; lt2; Pos p1(1, 1); lt2.push_back(p1); // 有名对象 lt2.push_back(Pos(2, 2)); // 匿名对象 lt2.push_back({3, 3}); // 隐式类型转换 dyy::list\u0026lt;Pos\u0026gt;::iterator it2 = lt2.begin(); while (it2 != lt2.end()) { //cout \u0026lt;\u0026lt; (*it2)._row \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; (*it2)._col \u0026lt;\u0026lt; endl; //为了可读性，特殊处理，省略了一个-\u0026gt; cout \u0026lt;\u0026lt; it2-\u0026gt;_row \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; it2-\u0026gt;_col \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; it2.operator-\u0026gt;()-\u0026gt;_row \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; it2.operator-\u0026gt;()-\u0026gt;_col \u0026lt;\u0026lt; endl; ++it2; } cout \u0026lt;\u0026lt; endl; return 0; } 2.2.2 迭代器的设计思想 1 2 3 4 5 6 容器::iterator it = begin(); while(it != end()) { *it; it++; } 容器迭代器设计思路体现了封装\n屏蔽底层实现细节，屏蔽各容器结构的差异，本质封装底层细节和差异，提供统一的访问方式\n封装就是把底层的细节屏蔽，想给你看到的给你，不想给你看到的就屏蔽起来，\n并且提供统一的访问方式，简单的封装是什么样的，复杂的封装是什么样的(比如迭代器)\n比如网银支付，像支付宝/微信这类的软件就是需要和各大银行对接，然后我们可以支付宝等软件上\n轻松使用自己其它银行卡里的钱进行付款\n2.2.3const迭代器 我们希望迭代器本身可以改变，但是迭代器指向的内容不能改变\n这种写法是错的：\n1 2 3 4 5 6 7 8 9 10 11 typedef const list_iterator\u0026lt;T\u0026gt; const_iterator; const_iterator begin() const { return const_iterator(_head-\u0026gt;_next); } const_iterator end() const { return const_iterator(_head); } 我们要让解引用不能修改（解引用 返回const别名）\n再实现一个类，让 operator* 和 operator-\u0026gt; 返回值被const修饰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 template\u0026lt;class T\u0026gt; struct list_const_iterator { typedef list_node\u0026lt;T\u0026gt; Node; typedef list_const_iterator\u0026lt;T\u0026gt; Self; Node* _node; list_const_iterator(Node* node) :_node(node) { } const T\u0026amp; operator*() { return _node-\u0026gt;_data; } const T* operator-\u0026gt;() { return \u0026amp;_node-\u0026gt;_data; } //前置++返回自己类型的值 Self\u0026amp; operator++() { _node = _node-\u0026gt;_next; return *this; } Self\u0026amp; operator--() { _node = _node-\u0026gt;_prev; return *this; } //后置 Self operator++(int) { Self tmp(*this); _node = _node-\u0026gt;_next; return tmp; } Self operator--(int) { Self tmp(*this); _node = _node-\u0026gt;_prev; return tmp; } bool operator != (const Self\u0026amp; s) { return _node != s._node; } }; 但是我们实现的这两个类高度相似，只有operator*和operator-\u0026gt;的返回值类型不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 template\u0026lt;class T, class Ref, class Ptr\u0026gt; struct list_iterator { typedef list_node\u0026lt;T\u0026gt; Node; typedef list_iterator\u0026lt;T, Ref, Ptr\u0026gt; Self; Node* _node; list_iterator(Node* node) :_node(node) { } Ref operator*() { return _node-\u0026gt;_data; } Ptr operator-\u0026gt;() { return \u0026amp;_node-\u0026gt;_data; } //前置++返回自己类型的值 Self\u0026amp; operator++() { _node = _node-\u0026gt;_next; return *this; } Self\u0026amp; operator--() { _node = _node-\u0026gt;_prev; return *this; } //后置 Self operator++(int) { Self tmp(*this); _node = _node-\u0026gt;_next; return tmp; } Self operator--(int) { Self tmp(*this); _node = _node-\u0026gt;_prev; return tmp; } bool operator != (const Self \u0026amp; s) { return _node != s._node; } }; list中\n1 2 typedef list_iterator\u0026lt;T, T\u0026amp;, T*\u0026gt; iterator; typedef list_iterator\u0026lt;T, const T\u0026amp;, const T*\u0026gt; const_iterator; 2.2.4反向迭代器 我们知道反向迭代器的++就是正向迭代器\u0026ndash;，反向迭代器的\u0026ndash;就是正向迭代器的++，因此，我们可以通过封装正向迭代器来实现反向迭代器\n源码 先看一下SGI-STL30版本里是怎么实现的：\nvector中反向迭代器\n1 2 3 4 5 6 7 8 9 #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION typedef reverse_iterator\u0026lt;const_iterator\u0026gt; const_reverse_iterator; typedef reverse_iterator\u0026lt;iterator\u0026gt; reverse_iterator; #else /* __STL_CLASS_PARTIAL_SPECIALIZATION */ typedef reverse_iterator\u0026lt;const_iterator, value_type, const_reference, difference_type\u0026gt; const_reverse_iterator; typedef reverse_iterator\u0026lt;iterator, value_type, reference, difference_type\u0026gt; reverse_iterator; #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ list中的反向迭代器\n1 2 3 4 5 6 7 8 9 10 11 #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION typedef reverse_iterator\u0026lt;const_iterator\u0026gt; const_reverse_iterator; typedef reverse_iterator\u0026lt;iterator\u0026gt; reverse_iterator; #else /* __STL_CLASS_PARTIAL_SPECIALIZATION */ typedef reverse_bidirectional_iterator\u0026lt;const_iterator, value_type, const_reference, difference_type\u0026gt; const_reverse_iterator; typedef reverse_bidirectional_iterator\u0026lt;iterator, value_type, reference, difference_type\u0026gt; reverse_iterator; #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ 反向迭代器的部分源码（stl_iterator.h中）\n1 2 3 4 5 6 7 8 9 10 11 12 13 #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION // This is the new version of reverse_iterator, as defined in the // draft C++ standard. It relies on the iterator_traits template, // which in turn relies on partial specialization. The class // reverse_bidirectional_iterator is no longer part of the draft // standard, but it is retained for backward compatibility. template \u0026lt;class Iterator\u0026gt; class reverse_iterator { protected: Iterator current; 1 2 3 4 5 6 7 8 9 10 11 12 #ifndef __STL_LIMITED_DEFAULT_TEMPLATES template \u0026lt;class RandomAccessIterator, class T, class Reference = T\u0026amp;, class Distance = ptrdiff_t\u0026gt; #else template \u0026lt;class RandomAccessIterator, class T, class Reference, class Distance\u0026gt; #endif class reverse_iterator { typedef reverse_iterator\u0026lt;RandomAccessIterator, T, Reference, Distance\u0026gt; self; protected: RandomAccessIterator current; 1 2 3 4 5 6 7 8 9 10 11 12 #ifndef __STL_LIMITED_DEFAULT_TEMPLATES template \u0026lt;class BidirectionalIterator, class T, class Reference = T\u0026amp;, class Distance = ptrdiff_t\u0026gt; #else template \u0026lt;class BidirectionalIterator, class T, class Reference, class Distance\u0026gt; #endif class reverse_bidirectional_iterator { typedef reverse_bidirectional_iterator\u0026lt;BidirectionalIterator, T, Reference, Distance\u0026gt; self; protected: BidirectionalIterator current; 反向迭代器的实现 库里面的rbegin()是在最后一个结点的前一个位置，rend()是在第一个节点；解引用的时候是解引用的前一个节点\n1 2 3 4 5 6 7 8 reference operator*() const { Iterator tmp = current; return *--tmp; } //... Reference operator*() const { return *(current - 1); } 1 2 reverse_iterator rbegin() { return reverse_iterator(end()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); } 所以我们也这样实现\niterator.h中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #pragma once template\u0026lt;class Iterator, class Ref, class Ptr\u0026gt; struct ReverseIterator { typedef ReverseIterator\u0026lt;Iterator, Ref, Ptr\u0026gt; Self; ReverseIterator(Iterator it) :_it(it) { } Ref operator*() { Iterator tmp(_it); return *(--tmp); } Ptr operator-\u0026gt;() { return \u0026amp;(operator*()); } Self\u0026amp; operator++() { --_it; return *this; } Self\u0026amp; operator--() { _it++; return *this; } bool operator!=(const Self\u0026amp; s) { return _it != s._it; } bool operator==(const Self\u0026amp; s) { return _it == s._it; } Iterator _it; }; list.h中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 typedef ReverseIterator\u0026lt;iterator, T\u0026amp;, T*\u0026gt; reverse_iterator; typedef ReverseIterator\u0026lt;const_iterator, const T\u0026amp;, const T*\u0026gt; const_reverse_iterator; reverse_iterator rbegin() { return reverse_iterator(end()); } reverse_iterator rend() { return reverse_iterator(begin()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); } const_reverse_iterator rend() const { return const_reverse_iterator(begin()); } 2.3拷贝构造和赋值运算符重载 默认生成的是浅拷贝，会导致析构的时候析构多次的问题\n1 2 3 4 5 6 7 8 9 10 //lt2(lt1) list(const list\u0026lt;T\u0026gt;\u0026amp; lt) { empty_init(); for (auto\u0026amp; e : lt) { push_back(e); } } 赋值运算符重载只需要交换两个链表的头结点指针\n1 2 3 4 5 6 7 8 9 10 11 12 void swap(list\u0026lt;T\u0026gt;\u0026amp; tmp) { std::swap(_head, tmp._head); std::swap(_size, tmp._size); } //lt2 = lt3 list\u0026lt;T\u0026gt;\u0026amp; operator=(list\u0026lt;T\u0026gt; lt) // lt拷贝构造lt3 { swap(lt);//交换lt3好和lt2的头节点指针，出作用域后lt3会销毁 return *this; } 全局的swap\n1 2 3 4 5 template\u0026lt;class T\u0026gt; void swap(list\u0026lt;T\u0026gt;\u0026amp; a, list\u0026lt;T\u0026gt;\u0026amp; b) { a.swap(b); } 完整代码 iterator.h中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #pragma once template\u0026lt;class Iterator, class Ref, class Ptr\u0026gt; struct ReverseIterator { typedef ReverseIterator\u0026lt;Iterator, Ref, Ptr\u0026gt; Self; ReverseIterator(Iterator it) :_it(it) { } Ref operator*() { Iterator tmp(_it); return *(--tmp); } Ptr operator-\u0026gt;() { return \u0026amp;(operator*()); } Self\u0026amp; operator++() { --_it; return *this; } Self\u0026amp; operator--() { _it++; return *this; } bool operator!=(const Self\u0026amp; s) { return _it != s._it; } bool operator==(const Self\u0026amp; s) { return _it == s._it; } Iterator _it; }; list.h中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 #pragma once #include \u0026lt;assert.h\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026#34;iterator.h\u0026#34; using namespace std; namespace dyy { //全部都是公有，一般用struct template\u0026lt;class T\u0026gt; struct list_node { T _data; list_node\u0026lt;T\u0026gt;* _next; list_node\u0026lt;T\u0026gt;* _prev; list_node(const T\u0026amp; x = T()) :_data(x) , _next(nullptr) , _prev(nullptr) {} }; //typedef list_iterator\u0026lt;T, T\u0026amp;, T*\u0026gt; iterator; //typedef list_iterator\u0026lt;T, const T\u0026amp;, const T*\u0026gt; const_iterator; template\u0026lt;class T, class Ref, class Ptr\u0026gt; struct list_iterator { typedef list_node\u0026lt;T\u0026gt; Node; typedef list_iterator\u0026lt;T, Ref, Ptr\u0026gt; Self; Node* _node; list_iterator(Node* node) :_node(node) { } Ref operator*() { return _node-\u0026gt;_data; } Ptr operator-\u0026gt;() { return \u0026amp;_node-\u0026gt;_data; } //前置++返回自己类型的值 Self\u0026amp; operator++() { _node = _node-\u0026gt;_next; return *this; } Self\u0026amp; operator--() { _node = _node-\u0026gt;_prev; return *this; } //后置 Self operator++(int) { Self tmp(*this); _node = _node-\u0026gt;_next; return tmp; } Self operator--(int) { Self tmp(*this); _node = _node-\u0026gt;_prev; return tmp; } bool operator != (const Self \u0026amp; s) { return _node != s._node; } bool operator == (const Self\u0026amp; s) { return _node == s._node; } }; template\u0026lt;class T\u0026gt; class list { typedef list_node\u0026lt;T\u0026gt; Node; public: //typedef list_iterator\u0026lt;T\u0026gt; iterator; //typedef list_const_iterator\u0026lt;T\u0026gt; const_iterator; typedef list_iterator\u0026lt;T, T\u0026amp;, T*\u0026gt; iterator; typedef list_iterator\u0026lt;T, const T\u0026amp;, const T*\u0026gt; const_iterator; typedef ReverseIterator\u0026lt;iterator, T\u0026amp;, T*\u0026gt; reverse_iterator; typedef ReverseIterator\u0026lt;const_iterator, const T\u0026amp;, const T*\u0026gt; const_reverse_iterator; reverse_iterator rbegin() { return reverse_iterator(end()); } reverse_iterator rend() { return reverse_iterator(begin()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); } const_reverse_iterator rend() const { return const_reverse_iterator(begin()); } iterator begin() { return iterator(_head-\u0026gt;_next); } iterator end() { return iterator(_head); } const_iterator begin() const { return const_iterator(_head-\u0026gt;_next); } const_iterator end() const { return const_iterator(_head); } void empty_init() { _head = new Node(); _head-\u0026gt;_next = _head; _head-\u0026gt;_prev = _head; _size = 0; } list() { empty_init(); } //lt2(lt1) list(const list\u0026lt;T\u0026gt;\u0026amp; lt) { empty_init(); for (auto\u0026amp; e : lt) { push_back(e); } } list(size_t n, const T\u0026amp; val = T()) { empty_init(); for (size_t i = 0; i \u0026lt; n; i++) { push_back(val); } } void swap(list\u0026lt;T\u0026gt;\u0026amp; tmp) { std::swap(_head, tmp._head); std::swap(_size, tmp._size); } //lt2 = lt3 list\u0026lt;T\u0026gt;\u0026amp; operator=(list\u0026lt;T\u0026gt; lt) { swap(lt); return *this; } ~list() { clear(); delete _head; _head = nullptr; } void clear() { auto it = begin(); while (it != end()) { it = erase(it); } } void push_back(const T\u0026amp; x) { //Node* new_node = new Node(x); //Node* tail = _head-\u0026gt;_prev; //tail-\u0026gt;_next = new_node; //new_node-\u0026gt;_prev = tail; //new_node-\u0026gt;_next = _head; //_head-\u0026gt;_prev = new_node; insert(end(), x); } void push_front(const T\u0026amp; x) { insert(begin(), x); } void pop_front() { erase(begin()); } void pop_back() { erase(--end()); } iterator insert(iterator pos, const T\u0026amp; val) { Node* new_node = new Node(val); Node* cur = pos._node; Node* prev = cur-\u0026gt;_prev; //prev new_node cur new_node-\u0026gt;_next = cur; cur-\u0026gt;_prev = new_node; prev-\u0026gt;_next = new_node; new_node-\u0026gt;_prev = prev; ++_size; return iterator(new_node); } iterator erase(iterator pos) { assert(pos != end()); Node* del = pos._node; Node* prev = del-\u0026gt;_prev; Node* next = del-\u0026gt;_next; prev-\u0026gt;_next = next; next-\u0026gt;_prev = prev; delete del; --_size; return iterator(next); } private: Node* _head; size_t _size; }; template\u0026lt;class T\u0026gt; void swap(list\u0026lt;T\u0026gt;\u0026amp; a, list\u0026lt;T\u0026gt;\u0026amp; b) { a.swap(b); } void test_list() { dyy::list\u0026lt;int\u0026gt; lt1; lt1.push_back(1); lt1.push_back(2); lt1.push_back(3); lt1.push_back(4); dyy::list\u0026lt;int\u0026gt;::reverse_iterator rit = lt1.rbegin(); while (rit != lt1.rend()) { *rit += 1; cout \u0026lt;\u0026lt; *rit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++rit; } cout \u0026lt;\u0026lt; endl; const dyy::list\u0026lt;int\u0026gt; lt2(lt1); dyy::list\u0026lt;int\u0026gt;::const_reverse_iterator rit1 = lt2.rbegin(); while (rit1 != lt2.rend()) { cout \u0026lt;\u0026lt; *rit1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++rit1; } cout \u0026lt;\u0026lt; endl; } } 三、list和vector的对比 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/list/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%80%92%E5%BD%B1-%E5%85%89%E5%BD%B1%E6%95%88%E6%9E%9C_hu_9af2b09bc3d802e9.png","permalink":"https://Amarantos-Arrebol.github.io/p/list/","title":"【C++初阶】09list"},{"content":"1.容器适配器 栈和队列的底层是容器适配器\n1.1什么是适配器 适配器是一种设计模式\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结\n该种模式是将一个类的接口转换成客户希望的另外一个接口\n1.2容器适配器 栈具有先进先出的特性，可以用数组或链表来实现——\u0026gt;vector和list\n队列具有后进先出的特性，也可以用数组或链表来实现——\u0026gt;vector和list\n因为vector和list都是已经实现好了的，栈和队列可以封装一下vector或list就可以实现，也就是 对其他容器的接口进行了包装\n但是库里面的栈和队列不是简单的封装了vector或list，而是在类模版中添加了一个模版参数 Container ，我们使用栈和队列的时候，可以自己指定底层是用list还是用vector实现栈/队列\n1 2 3 4 5 6 7 8 9 //stack\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; s1; //stack\u0026lt;int, list\u0026lt;int\u0026gt;\u0026gt; s1; template\u0026lt;class T, class Container\u0026gt; class Stack { private: Container _con; }; 凡是在模版或带有模版参数的类模版里，要去取一个东西，它可能是静态成员变量，也可能是一个内嵌类型\n静态成员变量是公有的，可以通过类域去取\n内嵌类型：比如内部类，在一个类里面定义的类型（即typedef的类型）\n类模版没有实例化，是不能去里面找东西的\n1.2deque的简单介绍 1.2.1介绍 deque 双端队列，是一种双开口的\u0026quot;连续\u0026quot;空间的数据结构\n允许在头尾两端进行插入和删除操作，且时间复杂度为O（1）\n与vector比较，头插效率高，不需要搬移元素\n与list比较，空间利用率比较高\n1.2.2deque的原理 vector插入数据删除数据尾部很方便，中间和尾部不方便，要挪动数据，但是访问很方便\n链表不存在挪动数据的问题，插入删除都很方便，但是不支持下标访问\ndeque就是开几段连续的空间，用一个指针数组管理\ndeque就两个迭代器，一个start，一个finish\nstart指向第一个buffer的开始和结束位置，finish指向最后一个buffer的开始和结束位置\n三个 T* ，cur 、first、last\n一个T**，node\n1.2.3deque的缺陷 1、deque 插入或删除时\n方法1：挪动后面所有的数据。效率低\n方法2：只挪动当前buffer的数据，但这样的话会导致每个buffer的大小不一样，insert/erase的效率不错，但是[]效率直线下降\n一般是选择方法一，因为牺牲[]的效率，代价比较大\n2、deque下标访问的效率没有vector高，中间插入删除的效率没有list效率高\ndeque头尾插入或删除的时候，效率不错\n1.3为什么选择deque作为stack和queue的底层默认容器 deque头尾插入/删除效率比较高\n比如，以实现queue为例\n用vector来实现，尾插要扩容，头插要挪动数据，效率低（当然，vector没有头插的接口） 用链表来实现，每次插入一个数据都要开空间，每次删除一个数据就要销毁一个空间 2.stack 为了保持栈的先进先出特性，所以栈不支持迭代器遍历栈\n2.1使用 empty 判空 size 返回元素个数 top 取栈顶元素 push 入栈 pop 出栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int main() { stack\u0026lt;int\u0026gt; st; st.push(1); st.push(2); st.push(3); st.push(4); while (st.size()) { cout \u0026lt;\u0026lt; st.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; st.pop(); } return 0; } 2.2模拟实现 库里面默认是deque实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #pragma once #include \u0026lt;vector\u0026gt; #include \u0026lt;list\u0026gt; namespace dyy { //stack\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; s1; //stack\u0026lt;int, list\u0026lt;int\u0026gt;\u0026gt; s1; template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class stack { public: void push(const T\u0026amp; x) { _con.push_back(x); } void pop() { _con.pop_back(); } const T\u0026amp; top() const { return _con.back(); } size_t size() const { return _con.size(); } bool empty() const { return _con.empty(); } private: Container _con; }; } 3.queue 3.1使用 1 2 3 4 5 6 7 8 9 10 11 12 queue\u0026lt;int\u0026gt; q; q.push(1); q.push(2); q.push(3); q.push(4); while (q.size()) { cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q.pop(); } cout \u0026lt;\u0026lt; endl; 还支持用迭代器区间构造\n也就是可以传容器，也可以传数组指针\n3.2模拟实现 建堆，从后往前找到第一个非叶子结点，执行向下调整算法\n例如下图中，当我们执行到1结点的时候，3,4,5,6结点都已经调整成大/小根堆了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #pragma once #include \u0026lt;vector\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;deque\u0026gt; namespace dyy { template\u0026lt;class T, class Container = deque\u0026lt;T\u0026gt;\u0026gt; class queue { public: void push(const T\u0026amp; x) { _con.push_back(x); } void pop() { _con.pop_front(); } const T\u0026amp; front() { return _con.front(); } const T\u0026amp; back() { return _con.back(); } size_t size() const { return _con.size(); } bool empty() const { return _con.empty(); } private: Container _con; }; } 4.priority_queue 普通队列是一种先进先出的数据结构（队头入数据，队尾出数据）\n而在优先级队列中，元素被赋予优先级\n当插入元素时，同样是在队尾，但是会根据优先级进行位置调整，优先级越高，\n调整后的位置就越靠近队头；同样的，删除元素也是根据优先级进行，优先级最高\n的元素（队头）最先被删除\npriority_queue就是C++提供的已经实现好的优先级队列，底层实现就是一个堆结构。\n优先级队列，在queue头文件里面\n4.1使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;queue\u0026gt; int main() { //默认是大根堆 //priority_queue\u0026lt;int\u0026gt; pq; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; pq.push(1); pq.push(3); pq.push(2); pq.push(4); while (pq.size()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; pq.pop(); } cout \u0026lt;\u0026lt; endl; return 0; } 库里面传小于是大堆，传大于是小堆\n4.2模拟实现 注意下标，vector下标从0开始\nchild = parent * 2 + 1\nparent = (child - 1) / 2\npriority_queue() = default; 强制生成默认构造\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 #pragma once #include \u0026lt;vector\u0026gt; namespace dyy { template \u0026lt;class T\u0026gt; struct less { //重载了operator() bool operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x \u0026lt; y; } }; template \u0026lt;class T\u0026gt; struct greater { //重载了operator() bool operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x \u0026gt; y; } }; // 默认创建一个大根堆 template\u0026lt;class T, class Container = vector\u0026lt;T\u0026gt;, class Compare = less\u0026lt;T\u0026gt;\u0026gt; class priority_queue { public: //强制生成 //默认生成的构造会去调用_con的构造，我们没有必要自己写 priority_queue() = default; template\u0026lt;class InputIterator\u0026gt; priority_queue(InputIterator first, InputIterator last) :_con(first, last) { //建堆，从最后一个非叶子结点开始，执行向下调整算法 for (int i = (_con.size() - 1 - 1) / 2; i \u0026gt;= 0; i--) { AdjustDown(i); } } //向上调整算法，当新来一个元素时，放最后 //和父节点比较，如果比父节点大，就交换，直到到根节点 void AdjustUp(int child) { Compare com; int parent = (child - 1) / 2; //while (child \u0026gt;= 0 \u0026amp;\u0026amp; _con[parent] \u0026lt; _con[child]) while (child \u0026gt;= 0 \u0026amp;\u0026amp; com(_con[parent] , _con[child])) { swap(_con[child], _con[parent]); child = parent; parent = (parent - 1) / 2; } } //向下调整算法，当删除堆顶元素时，将第一个元素和最后一个元素做交换 //然后从根位置开始向下调，如果父结点比最大的孩子都小，就交换 void AdjustDown(int parent) { Compare com; size_t child = parent * 2 + 1; while (child \u0026lt; _con.size()) { if (child + 1 \u0026lt; _con.size() \u0026amp;\u0026amp; com(_con[child], _con[child + 1])) child++; //if (_con[parent] \u0026lt; _con[child]) if (com(_con[parent], _con[child])) { swap(_con[child], _con[parent]); parent = child; child = parent * 2 + 1; } else { break; } } } void push(const T\u0026amp; x) { _con.push_back(x); AdjustUp(_con.size() - 1); } void pop() { swap(_con[0], _con[_con.size() - 1]); _con.pop_back(); AdjustDown(0); } bool empty() { return _con.empty(); } const T\u0026amp; top() { return _con[0]; } size_t size() { return _con.size(); } private: Container _con; }; } 4.3仿函数 仿函数是一个类，这个类可以像函数一样去使用，因为该类重载了 函数调用的()运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //仿函数 template \u0026lt;class T\u0026gt; struct Less { //重载了operator() bool operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x\u0026lt;y; } }; template \u0026lt;class T\u0026gt; struct Greater { //重载了operator() bool operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x \u0026gt; y; } }; int main() { Less\u0026lt;int\u0026gt; lessFunc; cout \u0026lt;\u0026lt; lessFunc(1, 2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; lessFunc.operator()(1, 2) \u0026lt;\u0026lt; endl; // 显示调用 return 0; } 什么时候需要仿函数？\n这个类不支持比较大小，可能是别人写的，我们不方便修改\n比如库里面写的\n这个类型支持比较大小，但是这个类型支持比较大小的行为和我们预期不符\n比如这里是用 Date* 进行比较，如果不传仿函数，那么就是按地址的大小来排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026#34;Priority_Queue.h\u0026#34; class Date { public: Date(int year = 1900, int month = 1, int day = 1) :_year(year) ,_month(month) ,_day(day) { } bool operator\u0026lt;(const Date\u0026amp; d) const { return (_year \u0026lt; d._year) || (_year == d._year \u0026amp;\u0026amp; _month \u0026lt; d._month) || (_year \u0026lt;mark\u0026gt; d._year \u0026amp;\u0026amp; _month \u0026lt;/mark\u0026gt; d._month \u0026amp;\u0026amp; _day \u0026lt; d._day); } bool operator\u0026gt;(const Date\u0026amp; d) const { return (_year \u0026gt; d._year) || (_year == d._year \u0026amp;\u0026amp; _month \u0026gt; d._month) || (_year \u0026lt;mark\u0026gt; d._year \u0026amp;\u0026amp; _month \u0026lt;/mark\u0026gt; d._month \u0026amp;\u0026amp; _day \u0026gt; d._day); } friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; _cout, const Date\u0026amp; d); private: int _year; int _month; int _day; }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; _cout, const Date\u0026amp; d) { _cout \u0026lt;\u0026lt; d._year \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; d._month \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; d._day; return _cout; } struct DateLess { bool operator()(const Date* d1, const Date* d2) const { return *d1 \u0026lt; * d2; } }; struct DateGreater { bool operator()(const Date* d1, const Date* d2) const { return *d1 \u0026gt; *d2; } }; int main() { //按日期从大到小排序 dyy::priority_queue\u0026lt;Date*, vector\u0026lt;Date*\u0026gt;, DateLess\u0026gt; q1; q1.push(new Date(2024, 10, 23)); q1.push(new Date(2024, 5, 27)); q1.push(new Date(2024, 11, 2)); while (q1.size()) { cout \u0026lt;\u0026lt; *q1.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; q1.pop(); } cout \u0026lt;\u0026lt; endl; return 0; } sort是一个函数模版，函数参数传的是对象\npriority_queue是一个类模版，模版参数传的是类型\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/stack-and-queue/14_hu_cb45f078a2d636f.png","permalink":"https://Amarantos-Arrebol.github.io/p/stack-and-queue/","title":"【C++初阶】10stack和queue"},{"content":"1.非类型模版参数 1.1基本介绍 类型模版参数就是我们定义的是一个类型，例如 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;class T\u0026gt; class Stack { public: Stack(size_t capacity = 4) { _array = new T[capacity]; _capacity = capacity; _size = 0; } private: T* _array; size_t _capacity; size_t _size; }; 非类型模版参数就是我们定义的不是一个类型，定义的是整型常量 ​\t我们可以用来定义数组的大小，比如可以用来定义静态数组的、定义静态的栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;class T, size_t N = 10\u0026gt; class Stack { private: T _a[N]; int _top; }; int main() { Stack\u0026lt;int\u0026gt; st0; // 定义一个静态栈，默认大小为0 Stack\u0026lt;int, 20\u0026gt; st1; // 定义一个大小为 20 的静态栈 Stack\u0026lt;int, 2000\u0026gt; st1; // 定义一个大小为 2000 的静态栈 return 0; } 比宏更优的地方：\n如果是定义的是宏，那么常量写死了\n如果定义的是非类型模版参数，那么我们在调用的时候可以指定常量的大小\n注意：\n浮点数、类对象以及字符串 是不允许作为非类型模板参数的。\n浮点数 是 C++20才支持\n非类型的模板参数必须在编译期就能确认结果。\n1.2应用场景 C++11增加了一个容器 array ，array就是一个静态数组，但不会初始化 array定义静态数组和直接定义数组的好处是，array是对静态数组进行了封装，检查时更严格(比如越界时一定会报错)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;array\u0026gt; int main() { array\u0026lt;int, 100\u0026gt; a1; array\u0026lt;int, 200\u0026gt; a2; int aa1[100]; int aa2[100]; // 抽查，越界读不报错，越界写不一定报错 cout \u0026lt;\u0026lt; aa1[100] \u0026lt;\u0026lt; endl; // 指针的解引用 // 越界一定报错 cout \u0026lt;\u0026lt; a1[100] \u0026lt;\u0026lt; endl; // 函数调用 return 0; } 容器 bitset 位图 2.模版的特化 2.1基本介绍 特化就是特殊化处理\n通常情况下，使用模板可以实现一些与类型无关的代码，但是在某些场景下，对于一些特殊的类型我们需要做特殊处理\n2.2函数模版特化 函数模版不建议特化，容易写错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //函数模版 template\u0026lt;class T\u0026gt; bool Less(const T\u0026amp; left, const T\u0026amp; right) { return left \u0026lt; right; } //特化 template\u0026lt;\u0026gt; bool Less\u0026lt;Date*\u0026gt;(Date* const\u0026amp; left, Date* const\u0026amp; right) { return *left \u0026lt; *right; } int main() { cout \u0026lt;\u0026lt; Less(1, 2) \u0026lt;\u0026lt; endl; // 可以比较，结果正确 Date d1(2022, 7, 7); Date d2(2022, 7, 8); cout \u0026lt;\u0026lt; Less(d1, d2) \u0026lt;\u0026lt; endl; // 可以比较，结果正确 Date* p1 = new Date(2019, 1,2); Date* p2 = new Date(2019, 3,2); //对Date*有特殊化的处理需求：因为按Date*比较没意义，我们还是希望用Date比较 cout \u0026lt;\u0026lt; Less(p1, p2) \u0026lt;\u0026lt; endl; return 0; } 如果想把函数模版做特殊处理，建议直接写成函数重载\n1 2 3 4 5 6 7 8 9 10 11 //函数模版 template\u0026lt;class T\u0026gt; bool Less(const T\u0026amp; left, const T\u0026amp; right) // const修饰 left 和 right { return left \u0026lt; right; } bool Less(Date* left, Date* right) { return *left \u0026lt; *right; } 2.3类模版特化 2.3.1全特化 全特化：所有参数都特殊化处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;class T1, class T2\u0026gt; class Data { public: Data() { cout \u0026lt;\u0026lt; \u0026#34;Data\u0026lt;T1, T2\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } private: T1 _d1; T2 _d2; }; //全特化 template\u0026lt;\u0026gt; class Data\u0026lt;int, char\u0026gt; { public: Data() { cout \u0026lt;\u0026lt; \u0026#34;Data\u0026lt;int, char\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } }; 使用时：\n1 2 Data\u0026lt;int, int\u0026gt; d1; Data\u0026lt;int, char\u0026gt; d2; 2.3.2偏特化 偏特化有两种：\n一种是特化部分参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;class T1, class T2\u0026gt; class Data { public: Data() { cout \u0026lt;\u0026lt; \u0026#34;Data\u0026lt;T1, T2\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } private: T1 _d1; T2 _d2; }; //偏特化 template\u0026lt;class T1\u0026gt; class Data\u0026lt;T1, int\u0026gt; // 只要第二个参数是int，就走该模版 { public: Data() { cout \u0026lt;\u0026lt; \u0026#34;Data\u0026lt;T1, int\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } }; 另一种是对类型的进一步限制，比如可以引用和指针混用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 template\u0026lt;class T1, class T2\u0026gt; class Data\u0026lt;T1*, T2*\u0026gt; // 指针 指针 { public: Data() { cout \u0026lt;\u0026lt; \u0026#34;Data\u0026lt;T1*, T2*\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } private: }; template\u0026lt;class T1, class T2\u0026gt; class Data\u0026lt;T1\u0026amp;, T2\u0026amp;\u0026gt; // 引用 引用 { public: Data() { cout \u0026lt;\u0026lt; \u0026#34;Data\u0026lt;T1\u0026amp;, T2\u0026amp;\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } private: }; template\u0026lt;class T1, class T2\u0026gt; class Data\u0026lt;T1\u0026amp;, T2*\u0026gt; // 引用 指针 { public: Data() { cout \u0026lt;\u0026lt; \u0026#34;Data\u0026lt;T1\u0026amp;, T2*\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } private: }; 传参时可以传下面的参数\n1 2 3 4 5 Data\u0026lt;int, int\u0026gt; d1; Data\u0026lt;char*, int*\u0026gt; d5; Data\u0026lt;int*, int*\u0026gt; d6; Data\u0026lt;int\u0026amp;, int\u0026amp;\u0026gt; d7; Data\u0026lt;int\u0026amp;, int*\u0026gt; d8; 可以用 typeid(T1).name() 查看模版的类型\n2.3.3类模版特化应用示例 1 2 3 4 5 6 7 8 9 10 11 12 // 对Less类模板按照指针方式特化 namespace dyy { template\u0026lt;\u0026gt; struct Less\u0026lt;Date*\u0026gt; { bool operator()(Date* x, Date* y) const { return *x \u0026lt; *y; } }; } 3.模版分离编译 3.1什么是分离编译 a.h\n1 2 3 4 5 6 7 8 9 10 #pragma once #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T\u0026gt; T Add(const T\u0026amp; left, const T\u0026amp; right); void Func(int x); a.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026#34;a.h\u0026#34; template\u0026lt;class T\u0026gt; T Add(const T\u0026amp; left, const T\u0026amp; right) { return left + right; } void Func(int x) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } test.cpp\n1 2 3 4 5 6 7 8 9 10 #include \u0026#34;a.h\u0026#34; int main() { Add(1, 2); Add(1.0, 2.0); //Func(3); return 0; } a.h a.cpp test.cpp —预处理—\u0026gt;a.i test.i—编译—\u0026gt;a.s test.s—汇编—\u0026gt;a.o test.o—链接—\u0026gt;a.out\n预处理：头文件展开，条件编译，宏替换，去注释\n编译：检查语法，生成汇编代码\n汇编：汇编代码转换成二进制的机器码\n链接：合并在一起，并且没有确定地址的函数，要确定地址等工作\n3.2模版的分离编译 链接时，Func可以链接成功，Add无法链接成功\ntest.i中知道Add需要实例化成int和double各一份Add函数，但是他只有声明没有定义\na.i中有Add的定义，但是不知道要实例化模版成什么类型\n3.3解决方法 解决方案1：.cpp中显示实例化\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;class T\u0026gt; T Add(const T\u0026amp; left, const T\u0026amp; right) { return left + right; } //显示实例化 template int Add(const int\u0026amp; left, const int\u0026amp; right); template double Add(const double\u0026amp; left, const double\u0026amp; right); **解决方案二：**不要声明和定义分离到两个文件，直接在.h中定义\n4.模版总结 【优点】 1.模板复用了代码，节省资源，更快的迭代开发，C++的标准模板库(STL)因此而产生 2.增强了代码的灵活性\n【缺陷】 1.模板会导致代码膨胀问题，也会导致编译时间变长 2.出现模板编译错误时，错误信息非常凌乱，不易定位错误\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/template-advancement/02_hu_b09e032a367fa6ec.png","permalink":"https://Amarantos-Arrebol.github.io/p/template-advancement/","title":"【C++初阶】11模版进阶"},{"content":"实现string类的接口，并完成测试，要求利用深拷贝和深赋值实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class string { public: string(const char* str = \u0026#34;\u0026#34;)； string(const string \u0026amp;s); string\u0026amp; operator=(const string \u0026amp;s); ~string()； private: char *_str; }; 一、swap 我们发现：\nstring既自己实现了一个swap\n又在全局实现了一个swap\n算法库中还有一个swap\n为什么要搞这么多swap呢?\n1.1 算法库中的swap 我们先看一看算法库中的swap\n然后写一个代码测试一下：\n1 2 3 4 5 6 7 8 9 10 void test1() { zhangsan::string s1(\u0026#34;hello world\u0026#34;); zhangsan::string s2(\u0026#34;xxxxxxxxxxxxxxxxxxxxx\u0026#34;); //swap(s1, s2); s1.swap(s2); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; } 我们发现，使用算法库中的 swap ，交换前的地址和交换后的地址均不相同，说明开了新空间\n简单分析一下：\n如果我们用的是算法库中的swap函数来交换 s1，s2 这两个string对象，那么需要\n1）先用 s1 构造一个 c，让 c 开一个和 s1 一样大的空间\n2）然后让 s2 赋值给 s1：让 s1 释放旧空间，并开一个和 s2 一样大的空间\n3）最后让 c 赋值给s2 ：让 s2 释放旧空间，并开一个和 c 一样大的空间\n4）最后出作用域，c 会析构，释放空间\n使用这个swap，我们申请了三次空间，释放了三次空间，这样的代价是很大的\n1.2 string的成员函数swap 实际上，交换两个string对象不需要这么复杂，我们只需要将两个string对象的字符指针交换，_size 和 _capacity交换\n我们可以自己试着实现一个string 成员函数的 swap：\n1 2 3 4 5 6 7 void swap(string\u0026amp; s) { //交换内置类型调用算法库中的swap即可 std::swap(_str, s._str); std::swap(_size, s._size); std::swap(_capacity, s._capacity); } 细节：\n如果直接写swap 默认会优先调用我们自己写的swap，即zhangsan这个命名空间的swap，所以我们需要指定命名空间std，调用算法库中的swap\n再测试一下：\n1 2 3 4 5 6 7 8 9 10 void test1() { zhangsan::string s1(\u0026#34;hello world\u0026#34;); zhangsan::string s2(\u0026#34;xxxxxxxxxxxxxxxxxxxxx\u0026#34;); //swap(s1, s2); s1.swap(s2); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; } 我们发现 swap 交换前后地址没变，说明并没有开新空间，只是交换了指针\n**总结：**使用算法库中的swap交换 string对象 代价大，使用string成员函数中的swap 代价小\n1.3 string 全局的swap 我们现在已经了解了算法库中的swap和string成员函数中的swap的差异，但是string在全局还有一个 swap，这个swap设计出来又有什么意义呢？\n1 2 3 4 5 //string全局的swap void swap(string\u0026amp; s1, string\u0026amp; s2) { s1.swap(s2); } string全局的swap其实是对成员函数的封装，是普通函数，而算法库中的swap是函数模版。\n我们之前学过，如果既写了函数模版，又写了普通函数，如果传的参数和普通函数的参数类型匹配，编译器会优先调用普通函数。\n也就是说string实现全局的swap后，无论我们是通过 对象.swap的方式调用成员函数的swap，还是直接调用swap函数，都不会调用算法库中的swap\n补充说明一下：\nC++11提供的右值引用和移动语义后，即使string不提供全局的swap，也不会调用算法库中的swap，而是调用string成员函数中深拷贝的swap\n二、拷贝构造和赋值的简洁写法 传统写法和简洁写法没有效率的提升，只是简洁一点，本质是复用\n2.1 拷贝构造 string 拷贝构造的传统写法：\n传统写法是自己开空间，自己拷贝数据\n1 2 3 4 5 6 7 8 //s2(s1) string(const string\u0026amp; s) { _str = new char[s._capacity + 1]; strcpy(_str, s._str); _size = s._size; _capacity = s._capacity; } string 拷贝构造的简洁写法：\n1 2 3 4 5 6 //s2(s1) string(const string\u0026amp; s) { string tmp(s._str); swap(tmp); } 先用 s1 的 _str 构造一个 tmp 对象，再让 s2 和 tmp 交换\n2.2 赋值 string赋值运算符重载的传统写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // s1 = s3 string\u0026amp; operator=(const string\u0026amp; s) { if (this != \u0026amp;s) // 防止出现自己给自己赋值的情况 { delete[] _str; _str = new char[s._capacity + 1]; strcpy(_str, s._str); _capacity = s._capacity; _size = s._size; } return *this; } string赋值运算符重载的简洁写法：\n1 2 3 4 5 6 7 8 9 10 11 // s1 = s3 string\u0026amp; operator=(const string\u0026amp; s) { if (this != \u0026amp;s) // 防止出现自己给自己赋值的情况 { string tmp(s._str); swap(tmp); } return *this; } 先用 s3 的 _str 构造一个 tmp，再让 s1 和 tmp 交换。传统写法中，我们需要手动释放s1的空间，但在现代写法中，由于tmp是局部变量，出作用域就调用析构函数，相当于把之前s1的空间销毁了。\n这个写法还可以进一步改进：\n1 2 3 4 5 6 //s1 = s3 string\u0026amp; operator=(string s) { swap(s); return *this; } 直接传值传参，调用拷贝构造，让 s 和 s3 有一样大的空间和一样的值，然后让 this 指向的对象和 s 进行交换\n三、写时拷贝（了解） 先看一个场景：\ns2(s1)，用 s1 拷贝构造 s2，使用的是深拷贝，但是可能过一会其中一个就要销毁，我们觉得代价太大了，但是如果使用浅拷贝，会有两个问题 1.会析构两次 2.如果修改了其中一个，另一个也会修改。我们可以利用引用计数和写时拷贝解决这个两个问题\n3.1 引用计数 写时拷贝就是在s1指向这块空间的时候，额外开辟一块空间，这个空间存储一个整型值，这个整型值叫引用计数。引用计数是来记录有多少个对象指向这块空间，析构的时候就 \u0026ndash;引用计数 ，当减到0 就释放 s1 指向的这块空间。\n通过引用计数，解决了多个对象指向同一块空间，析构多次的问题\n3.2 写时拷贝 写时拷贝是在浅拷贝的基础上增加了引用计数的方式来实现的。写时拷贝可以解决使用浅拷贝的另一个问题，即如果修改了其中一个对象，其它的对象也会修改。\n当只有一个对象指向这块空间的时候，修改这个对象就直接在这块空间修改 如果有多个对象指向这块空间，那么哪个对象要修改的时候，哪个对象就进行深拷贝，并且引用计数\u0026ndash; 举个例子：\ns2(s1) ，假如我们现在要把s1下标为0对应位置的字符改为字符 x\n写时拷贝就是谁写谁进行深拷贝\n如果想了解更多关于写时拷贝的知识，可以看下面两篇大佬写的文章\nhttps://coolshell.cn/articles/1443.html\nhttps://coolshell.cn/articles/12199.html\n四、编码 编码 一些比特位的值 \u0026lt;\u0026mdash;\u0026ndash;映射\u0026mdash;\u0026ndash;\u0026gt; 文字符号\nUTF-16、UTF-32和UTF-8\nUTF-16 ：以两个字节为一个单位 UTF-32 ：以四个字节为一个单位 UTF-8 ：以一个字节为单位，是一种变长编码，兼容ASCII ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/string-deep-copy-and-deep-assignment/4.Water%20World%EF%BC%88%E6%B0%B4%E3%81%AE%E4%B8%96%E7%95%8C%EF%BC%89_hu_89f113f3b08ccc91.png","permalink":"https://Amarantos-Arrebol.github.io/p/string-deep-copy-and-deep-assignment/","title":"【C++初阶】string深拷贝和深赋值"},{"content":"1.继承的基本介绍 继承是类设计层次的复用\n1.1继承定义 父类/基类，子类/派生类\n继承方式：\npublic继承 protected继承 private继承 访问限定符：\npublic访问 protected访问 private访问 1.子类对象不管是类里面还是类外面 都不能访问 父类的private成员\n2.如果父类成员不想在类外直接被访问，但需要在子类中能访问，就定义成protected\n3.父类的私有成员在子类中是不可见的，父类的其它成员的访问方式==min(成员在父类中的访问限定符，继承方式)，public \u0026gt; protected \u0026gt; private\n4.使用class时默认是private继承，使用struct时默认是public继承，不过最好显示写出继承方式\n1.2继承类模版 用继承的方式实现栈 stack和vector既符合is-a的关系，也符合has-a的关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; namespace dyy { //用继承的方式实现栈 //stack和vector既符合is-a的关系，也符合has-a的关系 template\u0026lt;class T\u0026gt; class stack : public std::vector\u0026lt;T\u0026gt; { public: void push(const T\u0026amp; x) { //父类是类模版时，需要指定一下类域，否则编译报错 //因为stack\u0026lt;int\u0026gt;实例化时，也实例化vector\u0026lt;int\u0026gt;了 //但是模版是需要按需实例化，push_back等成员函数未实例化，所以找不到 vector\u0026lt;T\u0026gt;::push_back(x); } void pop() { vector\u0026lt;T\u0026gt;::pop_back(); } const T\u0026amp; top() { return vector\u0026lt;T\u0026gt;::back(); } bool empty() { return vector\u0026lt;T\u0026gt;::empty(); } }; } int main() { dyy::stack\u0026lt;int\u0026gt; st; st.push(1); st.push(2); st.push(3); while (!st.empty()) { cout \u0026lt;\u0026lt; st.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; st.pop(); } return 0; } 父类是类模版时，需要指定一下类域，否则编译报错 因为stack\u0026lt;int\u0026gt;实例化时，也实例化vector\u0026lt;int\u0026gt;了 但是模版是需要按需实例化，push_back等成员函数未实例化，所以找不到\n按需实例化：\n实例化一个类的时候，并不会把它所有的成员函数都实例化，而是用哪个成员函数，才会实例化哪个成员函数\n补充：\n凡是在模版或带有模版参数的类模版里，要去取一个东西，它可能是静态成员变量，也可能是一个内嵌类型\n静态成员变量是公有的，可以通过类域去取\n内嵌类型：比如内部类，在一个类里面定义的类型（即typedef的类型）\n类模版没有实例化，是不能去里面找东西的\n或者直接用auto接收\n2.基类和派生类间的转换 public继承的子类对象，可以赋值给 父类的指针/引用，指针/引用指向的是子类中父类的一部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Person { protected: string _name; string _gender; int _age; }; class Student : public Person { public: int _no; }; int main() { Student stu; //1.子类对象可以赋值给父类的指针/引用 Person* pp = \u0026amp;stu; Person\u0026amp; rp = stu; return 0; } 赋值兼容转换（这个过程没有产生临时对象），或者说 切片 或 切割\n1 2 3 4 5 6 double d = 1.1; const int\u0026amp; i = d; //单参数的构造支持隐式类型转换，产生临时对象 string s1 = \u0026#34;11111\u0026#34;; const string\u0026amp; s2 = \u0026#34;11111\u0026#34;; 2.子类的对象可以给父类对象（通过调父类的拷贝构造完成），但是父类对象不能赋值给子类对象，因为父类类型对于子类类型来说类型不完全\n3.父类指针或引用可以通过强制类型转换 赋值给子类的指针或引用。但是必须是父类指针或引用指向子类对象时才是安全的。\n这里父类如果是多态类型，可以使用RTT的dynamic_cast来进行识别后进行安全转换\n3.继承中的作用域 1.在继承体系中父类和子类都有独立的作用域\n2.子类和父类中的成员，在子类成员函数中访问成员优先在子类查找，子类没有才到父类查找\n3.子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏\n如果在子类成员函数中，想要调用父类的成员，必须显示指定父类类域：父类::父类成员\n4.需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class A { public: void fun() { cout \u0026lt;\u0026lt; \u0026#34;func()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A { public: void fun(int i) { cout \u0026lt;\u0026lt; \u0026#34;func(int i)\u0026#34; \u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } }; int main() { B b; b.func(10); b.func(); // 编译报错，子类父类之前同名函数，构成隐藏，如果要调用父类的func函数，需要显示指定类域 b.A::func(); // ok return 0; } 上面这段代码中，A和B类中的两个func就构成隐藏\n重载要求在同一作用域中，同一个作用域里面函数名相同参数不同才构成重载\n4.派生类的默认成员函数 4.1构造 默认生成的构造：子类成员 + 父类成员\n子类成员\n内置类型，有缺省值就用；没有缺省值，它的值可能是随机的 自定义类型，调用它的默认构造，没有默认构造，就需要在初始化列表中显示调用 父类成员\n默认会调用父类的默认构造，如果父类没有默认构造，就需要子类显示调用父类带参的构造\n可以把子类中继承下来的父类成员当做一个整体对象\n子类显示调用父类构造的例子：\n初始化列表不是根据出现的顺序初始化，而是根据声明的顺序初始化\n所以会先初始化父类的成员\n4.2拷贝构造 默认生成的拷贝构造：子类成员 + 父类成员\n子类成员 内置类型，值拷贝 自定义类型，调用这个类类型的拷贝构造 父类成员 必须调用父类的拷贝构造 显示写，例子：\n注意：子类的拷贝构造函数必须调用父类的拷贝构造完成父类的拷贝初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Func(Person ptr) // 不管传父类对象还是子类对象，调用的都是父类的拷贝构造 { ptr.BuyTicket(); } int main() { Person p; Student stu; Func(p); Func(stu); // 调用的是父类的拷贝构造 return 0; } 4.3赋值运算符重载 默认生成的赋值运算符重载的行为和默认生成的拷贝构造的行为是相同的\n显示写，例子：\n注意，子类和父类的同名成员函数构成隐藏，如果子类要调同名的父类的成员函数，需要显示指定父类的类域\n4.4析构 默认生成的析构：子类成员 + 父类成员\n子类成员 内置类型，不处理 自定义类型，调用它自己的析构 父类成员 调用它自己的析构 由于多态中一些场景中析构函数需要构成重写，重写的条件之一是函数名相同，所以编译器会对析构函数的函数名做特殊处理，处理成destructor()，所以子类析构函数不加virtual的情况下，子类析构函数和父类析构函数构成隐藏关系\n1 2 3 4 5 6 7 8 ~Student() { cout \u0026lt;\u0026lt; \u0026#34;~Student()\u0026#34; \u0026lt;\u0026lt; endl; //delete[] _ptr; //~Person(); // err Person::~Person(); // ok } **注意：**如果我们要显示写子类的析构，不需要显示调用父类析构\n因为子类的析构函数会在被调用完成后，会自动调用父类的析构函数清理父类成员\n这样才能保证析构时先析构子类对象，再析构父类对象\n析构的时候先析构子，再析构父；构造的时候先构造父，再构造子\n4.5总结 一般情况下，子类我们只需要写构造\n如果需要写析构，就还需要写拷贝构造和赋值运算符重载\n需要自己写析构，说明有资源要清理，那么拷贝构造和赋值运算符重载应该是深拷贝\n如果要自己显示写成员函数，那么构造、拷贝构造、赋值运算符重载需要我们显示调父类的，但是父类的析构不需要我们显示调\n4.6面试题：实现一个不能被继承的类 方法一：把父类的构造函数私有化\n因为子类构造必须调用父类的构造函数，如果父类构造函数私有化，那么子类就不能调用了，子类就无法实例化出对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Base { public: void func5() { cout \u0026lt;\u0026lt; \u0026#34;Base::func5()\u0026#34; \u0026lt;\u0026lt; endl; } protected: int a = 1; private: Base() {} }; 方法二：使用C++11新增的final关键字 来修饰父类\n1 2 3 4 5 6 7 8 9 10 11 class Base final { public: void func5() { cout \u0026lt;\u0026lt; \u0026#34;Base::func5()\u0026#34; \u0026lt;\u0026lt; endl; } protected: int a = 1; private: }; 5.继承与友元 友元关系不能继承，也就是说父类友元不能访问子类私有和保护成员\n6.继承与静态成员 如果父类定义了静态成员，那么无论派生出多少子类，都只有一份静态成员，也就是静态成员在子类和父类之间是共享的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Person { public: string _name; static int _count; }; int Person::_count = 0; class Student : public Person { protected: int _stuNum; }; int main() { Person p; Student s; //对于非静态成员，子类继承后，子类对象和父类对象各一份 cout \u0026lt;\u0026lt; \u0026amp;p._name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;s._name \u0026lt;\u0026lt; endl; //子类和父类共用同一份静态成员 cout \u0026lt;\u0026lt; \u0026amp;p._count \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;s._count \u0026lt;\u0026lt; endl; //公有的情况下，父类子类都可以通过指定类域访问静态成员 cout \u0026lt;\u0026lt; \u0026amp;Person::_count \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026amp;Student::_count \u0026lt;\u0026lt; endl; return 0; } 7.多继承及其菱形继承问题 7.1继承模型 单继承：一个子类只有一个直接父类 ​\t多继承：一个子类有两个或以上的直接父类\n多继承对象在内存中的模型是，先继承的父类在前面，后面继承的父类在后面，子类成员在放到最后面\n​\t菱形继承：菱形继承是多继承的一种特殊情况，即一个类继承的两个或多个类有公共的父类\n菱形继承有数据冗余和二义性的问题，在Assistant的对象中Person成员会有两份\n有多继承就有可能出现菱形继承\n显示指定访问哪个父类的成员可以解决二义性问题，但数据冗余问题无法解决\n​\t1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Person { public: string _name; }; class Student : public Person { protected: int _id; // 学号 }; class Teacher : public Person { protected: int _id; // 职工编号 }; class Assistant : public Student, public Teacher { protected: string _majorCourse; // 主修课程 }; int main() { Assistant a; //a._name = \u0026#34;peter\u0026#34;; // 编译报错，对 \u0026#34;_name\u0026#34; 的访问不明确 //需要显示指定访问哪个父类的成员可以解决二义性问题，但数据冗余问题无法解决 a.Student::_name = \u0026#34;小王\u0026#34;; a.Teacher::_name = \u0026#34;王老师\u0026#34;; return 0; } 7.2虚继承 有多继承就存在菱形继承，有菱形继承就有菱形虚拟继承。\n但是菱形虚拟继承底层实现很复杂，性能也会有一些损失，所以最好不要设计出菱形继承\n我们可以设计出多继承，但是不建议设计出菱形继承，但有多继承语法支持，就一定存在会设计出菱形继承\nvirtual关键字\nvirtual关键字需放在直接继承共同父类的子类的继承声明中，如下图中共同父类是A，所以virtual关键字应该放在 A类的直接子类 B 和 C 类的继承声明中\n最好不要玩菱形继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Person { public: Person(const char* name) :_name(name) { } string _name; }; class Student : virtual public Person { public: Student(const char* name, int num) :Person(name) , _num(num) { } protected: int _num; // 学号 }; class Teacher : virtual public Person { public: Teacher(const char* name, int id) :Person(name) , _id(id) { } protected: int _id; // 职工编号 }; class Assistant : public Student, public Teacher { public: Assistant(const char* name1, const char* name2, const char* name3) :Person(name3) , Student(name1, 1) , Teacher(name2, 2) {} protected: string _majorCourse; // 主修课程 }; int main() { //不会走三次Person的构造 //已经是虚继承了，Person不在 Teacher 和 Student里面，而在一个公共的区域 //所以调Teacher 和 Student的构造时，不会走Person的构造 Assistant a(\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;); // name=\u0026#34;王五\u0026#34; return 0; } 7.3多继承中指针偏移问题 多继承中指针偏移问题？下面说法正确的是( C )\nA：p1 p2 p3 B：p1 \u0026lt; p2 \u0026lt; p3 C：p1 == p3 != p2 D：p1 != p2 != p3\n1 2 3 4 5 6 7 8 9 10 11 12 class Base1 { public: int _b1; }; class Base2 { public: int _b2; }; class Derive : public Base1, public Base2 { public: int _d; }; int main() { Derive d; Base1* p1 = \u0026amp;d; Base2* p2 = \u0026amp;d; Derive* p3 = \u0026amp;d; return 0; } 先声明的在前，先继承的在前\n7.4IO库中的菱形虚拟继承 源码：\n1 2 3 4 5 6 7 template\u0026lt;class CharT, class Traits = std::char_traits\u0026lt;CharT\u0026gt;\u0026gt; class basic_ostream : virtual public std::basic_ios\u0026lt;CharT, Traits\u0026gt; {}; template\u0026lt;class CharT, class Traits = std::char_traits\u0026lt;CharT\u0026gt;\u0026gt; class basic_istream : virtual public std::basic_ios\u0026lt;CharT, Traits\u0026gt; {}; 8.继承和组合 继承和组合 本质上都是类之间的复用\npublic继承是一种is-a的关系\n也就是说每个子类对象都是一个父类对象 组合是一种has-a的关系\n假设B组合了A，每个B对象中都有一个A对象 适配器的方式就是组合，只不过适配器的方式更灵活 1 2 3 4 5 6 7 8 9 //组合 class A {}; class B { private: A _a; }; 继承和组合哪个更好？\n继承允许你根据父类的实现来定义子类的实现\n通过生成子类的复用通常被称为白箱复用(white-boxreuse)\n在继承方式中，父类的内部细节对子类可见\n继承一定程度破坏了父类的封装，父类的改变，对子类有很大的影响\n子类和父类间的依赖关系很强，耦合度高\n对象组合是类继承之外的另一种复用选择，新的更复杂的功能可以通过组装或组合对象来获得\n对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-boxreuse)\n对象的内部细节是不可见的。对象只以“黑箱”的形式出现。\n组合类之间没有很强的依赖关系，耦合度低\n优先使用对象组合有助于你保持每个类被封装。\n优先使用组合，而不是继承。实际尽量多去用组合，组合的耦合度低，代码维护性好。不过也不太 那么绝对，类之间的关系就适合继承(is-a)那就用继承，另外要实现多态，也必须要继承。类之间的 关系既适合用继承(is-a)也适合组合(has-a)，就用组合。\n总结-易混点 菱形继承，子类对象不能直接访问最顶层父类继承下来的成员，因为在子类对象中，有两份最顶层的父类成员，直接通过子类对象访问会存在二义性问题 菱形继承存在二义性问题，尽量避免设计菱形继承，如果真有需要，一般采用虚拟继承减少数据冗余 子类构造函数的定义有时需要参考基类构造函数，原因是需要看父类构造函数是否需要参数子类的，从而你决定子类构造函数的定义 如果父类没有默认构造函数，派生类构造函数初始化列表的位置必须显式调用基类的构造函数，以完成基类部分成员的初始化 基类对象中没有包含所有基类的成员变量，静态成员变量为整个类所共有，不属于某一个对象 构造时，先构造父，再构造子；析构时，先析构子，再析构父 子类要继承父类的所有成员 静态成员一定是不被包含在对象中的 基类不能给子类对象直接赋值，因为父类类型对于子类类型来说类型不完全 赋值兼容规则，基类指针/引用可以直接指向子类对象，子类对象可以直接赋值给基类对象 要是public成员对象都可以直接访问 在派生构造函数初始化列表的位置不是必须显式调用基类构造函数，如果父类有默认构造函数就不需要 子类的对象可以给父类对象，通过调父类的拷贝构造完成，父类的指针/引用指向子类对象叫切片 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-inherit/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BC%91%E9%97%B2-%E5%92%96%E5%95%A1%E9%A6%86-%E6%89%8B%E7%BB%98%E9%A3%8E_hu_454a7102b0bad057.png","permalink":"https://Amarantos-Arrebol.github.io/p/c-inherit/","title":"【C++进阶】01继承"},{"content":"1.多态的基本介绍 多态，通俗来讲就是多种形态。\n多态分为 编译时多态(静态多态) 和 运行时多态(动态多态)\n编译时多态，比如 函数重载，函数模版 就体现多态\n它们传不同类型的参数就可以调用不同的函数，通过参数不同达到多种形态\n之所以叫编译时多态，是因为他们实参传给形参的参数匹配是在编译时完成的\n我们把编译时一般归为静态，运行时归为动态。\n1 2 3 int i; double d; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; d; // 自动识别类型？编译时调用了两个重载函数 运行时多态\n具体点就是完成某个行为(函数)，可以传不同的对象就会完成不同的行为，就达到多种形态\n比如买票这个行为，当普通人买票时，是全价买票；学生买票时，是优惠买票(5折或75折)；军人买票时是优先买票\n再比如，同样是动物叫的一个行为(函数)，传猫对象过去，就是”(\u003e\\^w^\u003c)\u0026ldquo;喵“，传狗对象过去，就是\u0026quot;汪汪\u0026rdquo;\n我们主要谈运行时多态，构成运行时多态的前提：\n1）对象之间存在继承关系\n2）子类必须对父类的虚函数完成重写/覆盖\n3）必须是父类的指针或者引用调用虚函数\n2.虚函数 2.1虚函数的基本介绍 在类的非静态成员函数前面加 virtual 修饰，那么这个成员函数就被称为虚函数\n注意：非成员函数和静态成员函数不能加 virtual 修饰\n1 2 3 4 5 6 7 8 class Person { public: virtual void BuyTicket() { cout \u0026lt;\u0026lt; \u0026#34;买票-全价\u0026#34; \u0026lt;\u0026lt; endl; } }; 2.2虚函数的重写/覆盖 子类的虚函数重写了父类的虚函数：子类中有一个跟父类完全相同的虚函数，即子类虚函数与父类虚函数的返回值类型、函数名字、参数列表完全相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Person { public: virtual void BuyTicket() { cout \u0026lt;\u0026lt; \u0026#34;买票-全价\u0026#34; \u0026lt;\u0026lt; endl; } }; class Student : public Person { public: virtual void BuyTicket() { cout \u0026lt;\u0026lt; \u0026#34;买票-打折\u0026#34; \u0026lt;\u0026lt; endl; } }; void Func(Person* ptr) { //虽然都是Person指针ptr在调用BuyTicket //但是跟ptr无关，而是由ptr指向的对象决定 ptr-\u0026gt;BuyTicket(); } int main() { Person p; Student stu; Func(\u0026amp;p); Func(\u0026amp;stu); return 0; } 注意： 子类在重写父类虚函数时，子类的虚函数可以不加virtual关键字，也可以构成重写（因为继承后父类的虚函数被继承下来了，在子类依旧保持虚函数属性），但是不建议这样使用\n1.是父类的指针或者引用调用虚函数\np指针调用test函数，先去子类B找有没有test函数，没有，去父类A找，找到了\n父类A的test函数，参数有隐含的this指针，是父类类型的指针\n调用func函数时，实际上是父类类型的指针 this 调用的 func函数\n2.子类的func函数的函数名、返回值类型、形参列表和父类完全一致，虽然没有写virtual，但也构成重写\n以上两点满足了多态，所以调用的是子类重写的虚函数\n一定要注意，满足了多态的情况下，调用的是子类重写的虚函数\n满足多态的条件：1.子类重写了父类的虚函数 2.调用虚函数的是父类的指针或引用\n2.3虚函数重写的一些问题 2.3.1 协变 子类重写父类虚函数时，与父类虚函数返回值类型不同\n即父类虚函数返回父类对象的指针或者引用，子类虚函数返回子类对象的指针或者引用时，称为协变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class A {}; class B : public A {}; class Person { public: virtual A* BuyTicket() { cout \u0026lt;\u0026lt; \u0026#34;买票-全价\u0026#34; \u0026lt;\u0026lt; endl; return nullptr; } }; class Student : public Person { public: virtual B* BuyTicket() { cout \u0026lt;\u0026lt; \u0026#34;买票-打折\u0026#34; \u0026lt;\u0026lt; endl; return nullptr; } }; void Func(Person* ptr) { ptr-\u0026gt;BuyTicket(); } int main() { Person p; Student stu; Func(\u0026amp;p); Func(\u0026amp;stu); return 0; } 2.3.2析构函数的重写 父类的析构函数为虚函数，此时子类析构函数只要定义，无论是否加virtual关键字，都与父类的析 构函数构成重写\n虽然父类与子类析构函数名字不同看起来不符合重写的规则，实际上编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor，所以父类的析构函数加了vialtual修饰，子类的析构函数就构成重写\n上面的代码我们可以看到，如果A()，不加virtual，那么delete p2时只调用的A的析构函数，没有调用 B的析构函数，就会导致内存泄漏问题，因为B()中在释放资源\n父类指针可以指向父类对象，也可以指向子类对象\n父类指针指向指向子类对象，析构时只调用了父类的析构，可能会导致子类对象的资源没有释放\n要想正确释放，必须构成多态\n构成多态，才能指向谁，调用谁的析构函数，正确释放资源\n3.override 和 final关键字 C++11提供了override，可以帮助用户检测是否重写\nC++对虚函数重写的要求比较严格，但是有些情况下由于疏忽，比如函数名写错参数写错等导致无法构成重写，而这种错误在编译期间是不会报出的，只有在程序运行时没有得到预期结果才来debug会得不偿失\noverride的写法：放在子类成员函数形参列表的后面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class A { public: virtual ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A { public: virtual ~B() override { cout \u0026lt;\u0026lt; \u0026#34;~B()-\u0026gt;delete:\u0026#34; \u0026lt;\u0026lt; _p \u0026lt;\u0026lt; endl; } protected: int* _p = new int[10]; }; final修饰一个类，那么这个类不能被继承\n1 2 3 4 5 6 class Car final { public: virtual void Dirve() final {} }; final修饰一个成员函数，那么这个成员函数不能被重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Car { public: virtual void Dirve() final {} }; class Benz : public Car { public: virtual void Drive() { cout \u0026lt;\u0026lt; \u0026#34;Benz-舒适\u0026#34; \u0026lt;\u0026lt; endl; } }; 4.重载/重写/隐藏的对比 5.纯虚函数和抽象类 在虚函数的后面写上=0，则这个函数为纯虚函数\n虚函数不需要定义实现，只要声明即可，因为要被派生类重写，但是语法上可以实现，\n1 2 3 4 5 class Car { public: virtual void Drive() = 0; } 含纯虚函数的类叫做抽象类，抽象类不能实例化出对象\n如果派生类继承后不重写纯虚函数，那么派生类也是抽象类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Car { public: virtual void Drive() = 0; }; class Benz : public Car { public: virtual void Drive() { cout \u0026lt;\u0026lt; \u0026#34;Benz-舒适\u0026#34; \u0026lt;\u0026lt; endl; } }; class BMW : public Car { public: virtual void Drive() { cout \u0026lt;\u0026lt; \u0026#34;BMW-操控\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { //Car c; //抽象类无法实例化出对象 Car* pBenz = new Benz; pBenz-\u0026gt;Drive(); Car* pBMW = new BMW; pBMW-\u0026gt;Drive(); return 0; } 纯虚函数某种程度上强制了派生类重写虚函数，因为不重写实例化不出对象\n6.多态的原理 6.1虚函数表指针 __vfptr 虚函数表指针 (v 代表virtual，f 代表function)\n（1）虚函数表本质是一个存虚函数地址/指针的指针数组，虚函数表也简称虚表\n（2）一个类所有虚函数的地址要被放到这个类对象的虚函数表中\n（3）一个含有虚函数的类中都至少都有一个虚函数表指针\n下面编译为32位程序的运行结果是什么（) A.编译报错 B.运行报错 C.8 D.12\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base { public : virtual void Func1() { cout \u0026lt;\u0026lt; \u0026#34;Func1()\u0026#34; \u0026lt;\u0026lt; endl; } protected: int _b = 1; char _ch = \u0026#39;x\u0026#39;; }; int main() { Base b; cout \u0026lt;\u0026lt; sizeof(b) \u0026lt;\u0026lt; endl; return 0; } 上面题目运行结果12bytes\n除了_b和_ch成员，还多一个虚函数表指针__vfptr放在对象的前面（注意有些平台可能会放到对象的最后面，这个跟平台有关)。\n6.2多态的原理 多态本质上是去调用不同的函数\n静态多态是编译时确定\n运行时多态是运行时去确定调用不同的函数（指向哪个对象，就调用哪个对象的函数）\n子类对象的虚函数表中存放子类虚函数的地址\n父类的指针指向子类对象会发生切片，即父类的指针指向子类中父类的一部分 父类对象的虚函数表中存放父类虚函数的地址\n动态多态：运行时到指向对象虚表中找到对应虚函数进行调用\n目的：指向谁，调用谁的对应虚函数\n父类指针/引用既可以指向父类对象也可以指向子类对象，指向父类对象，运行时就到父类的虚函数表中找到对应的虚函数进行调用；指向子类对象，运行时就到从子类对象中切出来的被子类重写的虚函数表中找到虚函数进行调用\n编译期间，编译器主要检测代码是否违反语法规则，此时无法知道父类的指针或者引用到底引用那个类的对象，也就无法知道调用那个类的虚函数，在程序运行时，才知道具体指向那个类的对象，然后通过虚表调用对应的虚函数，从而实现多态\n再看构成运行时多态的前提：\n1）对象之间存在继承关系\n2）子类必须对父类的虚函数完成重写/覆盖\n​\t子类对象的虚表覆盖成重写的虚表\n3）必须是父类的指针或者引用调用虚函数\n​\t父类的指针指向子类对象会发生切片，即父类的指针指向子类中父类的一部分\n动态绑定与静态绑定\n（1）静态绑定就是编译时确定调用函数的地址\n（2）动态绑定就是 在运行时到指向对象的虚函数表中找到调用函数的地址\n满足多态条件的函数调用是运行时绑定，其它函数是静态绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ptr是指针+BuyTicket是虚函数满⾜多态条件。 // 这⾥就是动态绑定，编译在运⾏时到ptr指向对象的虚函数表中确定调用函数地址 ptr-\u0026gt;BuyTicket(); 00EF2001 mov eax,dword ptr [ptr] 00EF2004 mov edx,dword ptr [eax] 00EF2006 mov esi,esp 00EF2008 mov ecx,dword ptr [ptr] 00EF200B mov eax,dword ptr [edx] 00EF200D call eax // BuyTicket不是虚函数，不满⾜多态条件。 // 这⾥就是静态绑定，编译器直接确定调⽤函数地址 ptr-\u0026gt;BuyTicket(); 00EA2C91 mov ecx,dword ptr [ptr] 00EA2C94 call Student::Student (0EA153Ch) 虚函数表\n同类型的对象共用同一张虚表，不同类型的对象各自有独立的虚表，所以父类和子类有各自独立的虚表\n（1）父类对象的虚函数表中存放父类所有虚函数的地址\n（2）子类由两部分构成，继承下来的父类和自己的成员\n一般情况下，继承下来的父类中有虚函数表指针，自己就不会再生成虚函数表指针\n但是要注意的这里继承下来的父类部分虚函数表指针和父类对象的虚函数表指针不是同一个，就像父类对象的成员和子类对象中的父类对象成员也独立的\n子类中重写的父类的虚函数，子类的虚函数表中对应的虚函数就会被覆盖成子类重写的虚函数地址\n子类的虚函数表中包含\n（1）父类的虚函数地址\n（2）子类重写的虚函数地址完成覆盖\n（3）子类自己的虚函数地址三个部分\n虚函数表本质是一个存虚函数指针的指针数组，一般情况这个数组最后面放了一个0x00000000标 记\n这个C++并没有进行规定，各个编译器自行定义的，VS系列编译器会再后面放个0x00000000标记，g++系列编译不会放\n**虚函数存在哪的？**代码段\n虚函数和普通函数一样的，编译好后是一段指令，都是存在代码段的，只是虚函数的地址又存到了虚表中\n**虚函数表存在哪的？**C++标准没有规定\n这个问题严格说并没有标准答案C++标准并没有规定。Vs下是存在代码段(常量区)\n对象是在栈帧里面，虚表的地址一般是存在对象的头4/8个字节里\n取出一个对象头4/8个字节的地址：\nBase b;\nBase* p = \u0026amp;b;\nprintf(\"Base虚表地址：%p\\n\", \\*(int*)p); // 强转成int，解引用就取出4个字节\n注意：规定取成员函数的地址要加上取地址符 \u0026amp;，例如 \u0026amp;Person::func1 才是取出Person类中f成员函数func1的地址\n总结-易混点 virtual关键字只能在声明时加，在类外现实时不能加\n使用父类对象调用的方法永远是父类的方法\n赋值兼容规则保证了子类对象可以直接赋值给父类对象，不需要强转\n虚函数表是在编译时生成的\n静态成员函数不能设置为虚函数（没有this指针，无法拿到虚表，就不能实现多态）\n父类的析构函数建议设置为虚函数，这样动态释放父类指针所指的子类对象时，能够达到析构的多态\n运行时多态\n编译期间，编译器主要检测代码是否违反语法规则，此时无法知道父类的指针或引用到底引用哪个类的对象，也就无法知道调用哪个类的虚函数。在程序运行时，才知道具体指向哪个类的对象，然后通过虚表调用对应的虚函数，从而实现多态 重写即覆盖，针对多态，要求函数完全相同\n重定义即隐藏，只需要函数名相同\n通过对象调用时，编译期间就知道调用哪个函数了\n抽象类不能实例化对象，但是可以定义指针，目的是用父类指针指向子类从而实现多态\n同类型的对象共用同一张虚表，不同类型的对象各自有独立的虚表。\n多继承的时候，一个类可能会有多张表 子类对象构造时，调用父类父类构造的过程中，多态机制还没有生效，如果调用函数，调的是父类的\n多态仅仅是用子类函数的地址覆盖虚表，最终调用的位置不变，只是执行函数发生变化\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-polymorphic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%8A%A8%E6%BC%AB%E5%A5%B3%E5%AD%A9-%E5%8F%AF%E7%88%B1_hu_58809c74293089fa.png","permalink":"https://Amarantos-Arrebol.github.io/p/c-polymorphic/","title":"【C++进阶】02多态"},{"content":"1.基本概念 二叉搜索树（Binary Search Tree），也称二叉排序树，简称BST\n具有以下性质：\n若左子树非空，则左子树所有节点的值均小于等于根节点的值 若右子树非空，则右子树所有节点的值均大于等于根节点的值 左右子树也是一棵二叉搜索树 左 \u0026lt; 根 \u0026lt; 右\n中序遍历的结果是从小到大的\n但是，我们创建二叉搜索树主要是为了快速插入、删除以及查找元素，而不是排序\nmap/set/multimap/multiset系列容器底层是二叉搜索树\nmap/set不支持插入相等值，multimap/multiset支持插入相等值\n2.性能分析 一般情况下，在二叉搜索树中查找，最多查找高度次，时间复杂度为O(logN)\n但在一些极端情况下，二叉搜索树会退化成单链表，查找以及插入操作的时间复杂度为O(N)\n比如当给我们的序列是从小到大依次递增的排列的时候\n二分查找也可以实现O(logN）级别的查找效率，但是二分查找有两大缺陷：\n要求有序\n插入和删除数据效率很低，因为底层结构要求是数组\n在数组的头部或中间插入数据时一般要挪动数据\n3.模拟实现二叉搜索树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #pragma once template\u0026lt;class K\u0026gt; struct BSTNode { K _key; BSTNode\u0026lt;K\u0026gt;* _left; BSTNode\u0026lt;K\u0026gt;* _right; BSTNode(const K\u0026amp; key) :_key(key) ,_left(nullptr) ,_right(nullptr) {} }; template\u0026lt;class K\u0026gt; class BSTree { typedef BSTNode\u0026lt;K\u0026gt; Node; public: void InOrder() { _InOrder(_root); cout \u0026lt;\u0026lt; endl; } private: //中序遍历：左子树 根 右子树 void _InOrder(Node* root) { if (root == nullptr) return; _InOrder(root-\u0026gt;_left); cout \u0026lt;\u0026lt; root-\u0026gt;_key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; _InOrder(root-\u0026gt;_right); } Node* _root = nullptr; }; 3.1插入 根据BST的特性，从根节点开始一路向下找，直到找到一个空位置\n插入的具体过程：\n树为空，直接把新结点赋值给根节点\n树不空，新结点的值比当前结点大往右走，比当前结点小往左走，直到找到空位置，插入新结点\n如果该二叉搜索树支持插入相同的值，那么当新结点的值和当前结点的值相等时，既可以往右走，也可以往左走（但要注意插入相等的值不要一会往右走，一会往左走)，然后找到空位置，插入新结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 bool Insert(const K\u0026amp; key) { if (_root == nullptr) { _root = new Node(key); return true; } //和根节点进行比较，比根节点小放左边，比根节点大，放右边 Node* parent = nullptr; Node* cur = _root; while (cur) { if (key \u0026lt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_left; } else if(key \u0026gt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_right; } else // 这个值已经有了 { return true; } } cur = new Node(key); if (key \u0026lt; parent-\u0026gt;_key) { parent-\u0026gt;_left = cur; } else { parent-\u0026gt;_right = cur; } return true; } 3.2查找 要查找的值为x，从根开始查找\n如果x比根的值大，查找根的左子树 如果x比根的值小，查找根的右子树 一直查找，直到走到空或发现x和当前节点的值相等\n如果x和当前结点的值相等 如果该二叉搜索树不支持插入相等值，那么可以直接返回 如果二叉搜索树支持插入相等值，那么和x有相同值的结点可能有多个，一般要求查找的是中序的第一个x，比如下图中如果查找3，那么就是返回1的右孩子的那个3返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool find(const K\u0026amp; key) const { Node* cur = _root; while (cur) { if (key \u0026lt; cur-\u0026gt;_key) { cur = cur-\u0026gt;_left; } else if (key \u0026gt; cur-\u0026gt;_key) { cur = cur-\u0026gt;_right; } else { return true; } } return false; } 3.3删除 首先查找元素是否在二叉搜索树中，如果不存在，则返回false\n如果查找元素在二叉搜索树中，那么要分以下三种情况分别处理\n1.要删除的节点没有左右孩子，即要删除的是叶子结点\n2.要删除的节点只有一个孩子（只有左子树或右子树）\n3.要删除的节点有两个孩子（有左子树和右子树）\n1.删除的结点为叶子节点 如果删除的节点为叶子结点，也就是该结点没有左右孩子，那么直接删除即可\n2.删除的节点只有左子树或右子树 如果要删除的结点只有右子树，那么就让右子树替代要删除的节点\n如果要删除结点只有左子树，就让左子树替代要删除的节点\n例子1：要删除的结点为10，该节点只有右子树\n例子2：要删除的结点为14，该节点只有左子树\n3.删除的结点有左右子树 如果删除的结点有左右子树，那么替换的结点的值应该要么比左子树都大，比右子树都小，这样才能继续保持二叉搜索树的性质（左 \u0026lt; 根 \u0026lt; 右）。\n也就是要么用左子树中值最大结点来替换要删除的节点，要么用右子树中值最小的结点来替换\n总结\n策略一：用左子树的最大结点的值替换，删除左子树最大结点\n策略二：用右子树的最小结点的值替换，删除右子树最小结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 bool Erase(const K\u0026amp; key) { //1.先查找该结点是否存在 Node* parent = nullptr; Node* cur = _root; while (cur) { if (key \u0026lt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_left; } else if (key \u0026gt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_right; } else { //2.删除操作 if (cur-\u0026gt;_right == nullptr) { //右子树为空，左子树不为空，让parent指向我的左 if (cur == _root) _root = cur-\u0026gt;_left;//删除的是根节点 else { if (parent-\u0026gt;_left == cur) parent-\u0026gt;_left = cur-\u0026gt;_left; else parent-\u0026gt;_right = cur-\u0026gt;_left; } delete cur; cur = nullptr; } else if (cur-\u0026gt;_left == nullptr) { //左子树为空，右子树不为空，让parent指向我的右 if(cur == _root) _root = cur-\u0026gt;_right;//删除的是根节点 else { if (parent-\u0026gt;_left == cur) parent-\u0026gt;_left = cur-\u0026gt;_right; else parent-\u0026gt;_right = cur-\u0026gt;_right; } delete cur; cur = nullptr; } else { //删除结点有左右子树 //用 左子树的最大结点 或 右子树的最小节点 替代要删除的节点 Node* minRightParent = cur; Node* minRight = cur-\u0026gt;_right; while (minRight-\u0026gt;_left) { minRightParent = minRight; minRight = minRight-\u0026gt;_left; } cur-\u0026gt;_key = minRight-\u0026gt;_key; if (minRightParent-\u0026gt;_left == minRight) { minRightParent-\u0026gt;_left = minRight-\u0026gt;_right; } else { cur-\u0026gt;_right = minRight-\u0026gt;_right; } delete minRight; minRight = nullptr; } return true; } } return false; } 4.叉搜索树key和key/value使用场景 4.1key搜索场景 key只作为关键码(需要搜索到的值)，搜索场景只需要判断key在不在\nkey的搜索场景实现的二叉搜索树只支持插入、删除、查找，不支持修改\n场景1：小区无人值守车库\n小区车库买了车位的业主车才能进小区，那么物业会把买了车位的业主的车牌号录入后台系统，车辆进入时扫描车牌在不在系统中，在则抬杆，不在则提示非本小区车辆，无法进入\n场景2：检查一篇英文文章单词拼写是否正确\n将词库中所有单词放入二叉搜索树，读取文章中的单词，查找是否在二叉搜索树中，不在则波浪线标红提示\n4.2key/value搜索场景 每一个关键码key，都有与之对应的值value\n增/删/查还是以key为关键字走二叉搜索树的规则进行比较，可以快速查找到key对应的value\nKey/value的搜索场景实现的二叉树搜索树支持修改value，但是不支持修改key\n场景1：简单中英互译字典\n树的结构中(结点)存储key(英文)和vlaue(中文)，搜索时输入英文，则同时查找到了英文对应的中文\n场景2：商场无人值守车库\n入口进场时扫描车牌，记录车牌和入场时间，出口离场时，扫描车牌，查找入场时间，用当前时间-入场时间计算出停车时长，计算出停车费用，缴费后抬杆，车辆离场\n场景3：统计一篇文章中单词出现的次数\n读取一个单词，查找单词是否存在，不存在这个说明第一次出现，（单词，1），单词存在，则++单词对应的次数\n4.3key/value二叉搜索树代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 template\u0026lt;class K, class V\u0026gt; struct BSTNode { K _key; V _value; BSTNode\u0026lt;K, V\u0026gt;* _left; BSTNode\u0026lt;K, V\u0026gt;* _right; BSTNode(const K\u0026amp; key, const V\u0026amp; value) :_key(key) ,_value(value) ,_left(nullptr) ,_right(nullptr) { } }; template\u0026lt;class K, class V\u0026gt; class BSTree { typedef BSTNode\u0026lt;K, V\u0026gt; Node; public: BSTree() = default; BSTree(const BSTree\u0026lt;K, V\u0026gt;\u0026amp; t) { _root = Copy(t._root); } BSTree\u0026lt;K, V\u0026gt;\u0026amp; operator=(BSTree\u0026lt;K, V\u0026gt; t) { swap(_root, t._root); return *this; } ~BSTree() { Destroy(_root); _root = nullptr; } bool Insert(const K\u0026amp; key, const V\u0026amp; value) { if (_root == nullptr) { _root = new Node(key, value); return true; } //和根节点进行比较，比根节点小放左边，比根节点大，放右边 Node* parent = nullptr; Node* cur = _root; while (cur) { if (key \u0026lt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_left; } else if (key \u0026gt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_right; } else // 这个值已经有了 { return false; } } cur = new Node(key, value); if (key \u0026lt; parent-\u0026gt;_key) { parent-\u0026gt;_left = cur; } else { parent-\u0026gt;_right = cur; } return true; } Node* find(const K\u0026amp; key) { Node* cur = _root; while (cur) { if (key \u0026lt; cur-\u0026gt;_key) { cur = cur-\u0026gt;_left; } else if (key \u0026gt; cur-\u0026gt;_key) { cur = cur-\u0026gt;_right; } else { return cur; } } return nullptr; } bool Erase(const K\u0026amp; key) { //1.先查找该结点是否存在 Node* parent = nullptr; Node* cur = _root; while (cur) { if (key \u0026lt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_left; } else if (key \u0026gt; cur-\u0026gt;_key) { parent = cur; cur = cur-\u0026gt;_right; } else { //2.删除操作 if (cur-\u0026gt;_right == nullptr) { //右子树为空，左子树不为空，让parent指向我的左 if (cur == _root) _root = cur-\u0026gt;_left;//删除的是根节点 else { if (parent-\u0026gt;_left == cur) parent-\u0026gt;_left = cur-\u0026gt;_left; else parent-\u0026gt;_right = cur-\u0026gt;_left; } delete cur; cur = nullptr; } else if (cur-\u0026gt;_left == nullptr) { //左子树为空，右子树不为空，让parent指向我的右 if (cur == _root) _root = cur-\u0026gt;_right;//删除的是根节点 else { if (parent-\u0026gt;_left == cur) parent-\u0026gt;_left = cur-\u0026gt;_right; else parent-\u0026gt;_right = cur-\u0026gt;_right; } delete cur; cur = nullptr; } else { //删除结点有左右子树 //用 左子树的最大结点 或 右子树的最小节点 替代要删除的节点 Node* minRightParent = cur; Node* minRight = cur-\u0026gt;_right; while (minRight-\u0026gt;_left) { minRightParent = minRight; minRight = minRight-\u0026gt;_left; } cur-\u0026gt;_key = minRight-\u0026gt;_key; //cur-\u0026gt;_value = minRight-\u0026gt;_value; if (minRightParent-\u0026gt;_left == minRight) { minRightParent-\u0026gt;_left = minRight-\u0026gt;_right; } else { cur-\u0026gt;_right = minRight-\u0026gt;_right; } delete minRight; minRight = nullptr; } return true; } } return false; } void InOrder() { _InOrder(_root); cout \u0026lt;\u0026lt; endl; } private: //中序遍历：左子树 根 右子树 void _InOrder(Node* root) { if (root == nullptr) return; _InOrder(root-\u0026gt;_left); cout \u0026lt;\u0026lt; root-\u0026gt;_key \u0026lt;\u0026lt; \u0026#34;：\u0026#34; \u0026lt;\u0026lt; root-\u0026gt;_value \u0026lt;\u0026lt; endl;; _InOrder(root-\u0026gt;_right); } void Destroy(Node* root) { if (root == nullptr) return; Destroy(root-\u0026gt;_left); Destroy(root-\u0026gt;_right); delete root; } Node* Copy(Node* root) { if (root == nullptr) return nullptr; Node* newRoot = new Node(root-\u0026gt;_key, root-\u0026gt;_value); newRoot-\u0026gt;_left = Copy(root-\u0026gt;_left); newRoot-\u0026gt;_right = Copy(root-\u0026gt;_right); return newRoot; } Node* _root = nullptr; }; 简单中英互译字典\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int main() { key_value::BSTree\u0026lt;string, string\u0026gt; dict; dict.Insert(\u0026#34;left\u0026#34;, \u0026#34;左边\u0026#34;); dict.Insert(\u0026#34;right\u0026#34;, \u0026#34;右边\u0026#34;); dict.Insert(\u0026#34;insert\u0026#34;, \u0026#34;插入\u0026#34;); dict.Insert(\u0026#34;string\u0026#34;, \u0026#34;字符串\u0026#34;); string str; while (cin \u0026gt;\u0026gt; str) { auto ret = dict.find(str); if (ret) { cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;-\u0026gt;\u0026#34; \u0026lt;\u0026lt; ret-\u0026gt;_value \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;无此单词，请重新输入\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 查找某个单词出现的次数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { string arr[] = { \u0026#34;苹果\u0026#34;, \u0026#34;苹果\u0026#34;, \u0026#34;西瓜\u0026#34;, \u0026#34;苹果\u0026#34; , \u0026#34;苹果\u0026#34;, \u0026#34;西瓜\u0026#34;, \u0026#34;香蕉\u0026#34;, \u0026#34;苹果\u0026#34; , \u0026#34;香蕉\u0026#34; , \u0026#34;香蕉\u0026#34; , \u0026#34;苹果\u0026#34; }; key_value::BSTree\u0026lt;string, int\u0026gt; countTree; for (const auto\u0026amp; str : arr) { key_value::BSTNode\u0026lt;string, int\u0026gt;* ret = countTree.find(str); if (ret == nullptr) // 第一次出现 { countTree.Insert(str, 1); } else // 出现次数++ { ret-\u0026gt;_value++; } } countTree.InOrder(); return 0; } ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/binary-search-tree/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%92%96%E5%95%A1-%E5%92%96%E5%95%A1%E5%B1%8B-%E5%A4%9C%E6%99%AF_hu_a0a2c5d69c393b62.png","permalink":"https://Amarantos-Arrebol.github.io/p/binary-search-tree/","title":"【C++进阶】03二叉搜索树"},{"content":"1.AVL树的基本介绍 二叉搜索树(左\u003c根\u003c右) 在有些极端情况下，会退化成单链表，并且各种操作的效率也会下降。因此我们需要一些特别的手段保证这个二叉树的“平衡”，进而保证各种操作的效率，即平衡二叉树\n平衡二叉树，也称AVL树，它是具有以下性质的二叉搜索树：\n左右子树分别也是平衡二叉树 左右子树的高度差的绝对值不超过1 AVL树高度可以控制在logN，增删查改的效率也可以控制在O(logN)\nAVL树中引入了一个平衡因子的概念\n每个结点都有一个平衡因子，平衡因子等于右子树的高度减去左子树的高度 任何一个结点的平衡因子的值只会是 -1 或 0 或 1 (平衡二叉树要求左右子树的高度差不超过1) 通过平衡因子，可以更方便我们去观察和控制树是否平衡 判断是不是平衡二叉树，只需要看\n是不是二叉搜索树\n左右子树的平衡因子是不是取值为 -1 或 0 或 1\n为什么AVL树是高度平衡搜索二叉树，要求高度差不超过1，而不是高度差是0呢？0不是更好的平衡吗？\n画画图分析我们发现，不是不想这样设计，而是有些情况是做不到高度差是0的。\n比如一棵树是2个结点，4个结点等情况下，高度差最好就是1，无法做到高度差是0\n2.AVL树的实现 2.1 AVL树的结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template\u0026lt;class K, class V\u0026gt; struct AVLTreeNode { pair\u0026lt;K, V\u0026gt; _kv; AVLTreeNode\u0026lt;K, V\u0026gt;* _left; AVLTreeNode\u0026lt;K, V\u0026gt;* _right; AVLTreeNode\u0026lt;K, V\u0026gt;* _parent;//后续更新平衡因子可以看到 int _bf; // 平衡因子 AVLTreeNode(const pair\u0026lt;K, V\u0026gt;\u0026amp; kv) :_kv(kv) ,_left(nullptr) ,_right(nullptr) ,_parent(nullptr) ,_bf(0) { } }; template\u0026lt;class K, class V\u0026gt; class AVLTree { typedef AVLTreeNode\u0026lt;K, V\u0026gt; Node; public: private: Node* _root = nullptr; }; 2.2 AVL树的插入 按照二叉搜索树的规则插入一个值，新增一个结点后，它根上结点的平衡因子的绝对值可能大于1，所以需要从新增节点开始向上更新路径上的平衡因子\n更新平衡因子过程中没有出现问题，则插入结束 更新平衡因子过程中出现不平衡，就对不平衡子树旋转。旋转本质是调平衡的同时，降低了子树的高度，不会再影响上一层，所以插入结束 平衡因子=右子树的高度-左子树的高度\n只有高度变化才会影响当前结点平衡因子\n插入结点，会增加高度，所以\n新增结点在parent的右子树，parent的平衡因子++ 新增结点在parent的左子树，parent平衡因子\u0026ndash; parent所在子树的高度是否变化，决定了是否会继续往上更新\n更新停止条件\n更新后parent的平衡因子等于0\n说明更新前parent子树一边高一边低，更新后parent所在的子树高度不变，不会影响parent的父节点的平衡因子，更新结束 更新后parent的平衡因子等于1/-1\n说明更新前parent两边子树一样高，更新后导致parent的子树一边高一边低，虽然parent的平衡因子符合要求，但是高度增加了1，会影响parent父亲结点的平衡因子，所以要继续向上更新 更新后parent的平衡因子等于2/-2\n说明更新前parent子树就是一边高一边低，新增节点是往高的那一边插入的，导致parent子树高的一边更高了，已经不平衡了，需要旋转。\n旋转的两个目标：1.把parent子树旋转平衡 2.降低parent子树的高度，恢复到插入结点以前的高度\n所以旋转后也不需要继续往上更新，插入结束\n不断更新，更新到根，根的平衡因子是1或-1也停止\n2.3 旋转 2.3.1 旋转的原则 parent的平衡因子等于2/-2，需要旋转\n旋转的两个目标：\n把parent子树旋转平衡\n降低parent子树的高度，恢复到插入结点以前的高度\n平衡二叉树的查找、插入以及删除操作基本上与二叉搜索树一致，但需要处理操作之后的“失衡”。\n重点需要掌握两种处理失衡的操作：\n左旋 让该节点成为右孩子的左子树 右孩子原本的左子树成为该结点的左子树 右旋 让该节点成为左孩子的右子树 左孩子原本的右子树成为该结点的左子树 2.3.2 右单旋 2.3.3 左单旋 2.3.4 左右双旋 2.3.5 右左双旋 2.4 AVL树的查找 2.5 AVL树平衡检测 2.6 AVL树的删除 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/avl/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI%E7%BE%8E%E5%A5%B3-%E5%8A%A8%E6%BC%AB_hu_ca6ce88864ce256.png","permalink":"https://Amarantos-Arrebol.github.io/p/avl/","title":"【C++进阶】05AVL树实现"},{"content":"1、为什么要有动态内存管理 向内存申请一块空间存放数据的方法\n1）创建一个变量\n2）创建一个数组，数组编译时开辟空间\n**缺陷：**1.空间开辟的大小是固定的\n​ 2.数组在声明的时候，必须指定数组的长度，数组空间一旦确定了大小不能调整\n但对于空间的需求，有时候我们需要的空间大小在程序运行的时候才能知道\n所以我们引入动态内存开辟，让程序员自己可以申请和释放空间\n动态内存管理的头文件stdlib.h\n2、malloc和free 2.1 基本介绍 memory:内存\nalloc:空间开辟\n向内存申请一块连续可用的空间（大小是字节），并返回指向这块空间的指针\n返回值void*：将这块空间起始地址返回，malloc函数并不知道开辟空间的类型\n​ 具体使用的时候，应该将其强转为我们期望的类型的指针\n注意：\n1、参数的单位是字节\n2、对malloc返回的指针做判断\n​ 申请空间成功的话，返回起始地址；申请失败，返回NULL\n3、如果参数size为0，malloc的行为是标准是未定义的，取决于编译器\n2.3 malloc申请空间和数组的空间有什么区别呢？ 1、动态内存的大小是可以调整的\n2、开辟空间的位置不一样\n2.4 内存中数据的存储划分 1）栈区：局部变量，局部的数组，函数的形式参数\n2）堆区：动态内存malloc，free，calloc，realloc\n3）静态区：全局变量，static修饰的静态变量\n2.5 free malloc申请的这块空间，使用完后，不想要了，需要释放\nfree是将申请的那块空间的使用权限还给操作系统了\n是通过代码的方式释放内存，如果不释放，程序结束的时候也会被操作系统自动回收\n但是指向这块空间的指针p，指向的空间不属于当前程序，但还是找得到\n这块空间（p是野指针，所以要将p置为空）\n注意\n1、如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的\n2、如果参数ptr是NULL指针，则函数什么事都不做\n3、free释放的空间一定是动态申请的\nmalloc和free最好成对使用\n3、calloc和realloc 3.1calloc 开辟num个大小为size的空间，并用0初始化数组，返回地址\nmalloc不会把申请的空间初始化，calloc会初始化，因此calloc函数效率要低一些\n3.2 realloc realloc 不仅能调整空间，还可以申请空间\n把已经通过malloc或realloc开辟的空间进行调整，\nptr：要调整的内存空间的起始地址\nsize：需要调整多大的空间\n返回值为调整后内存的起始地址\n3.3 realloc是如何扩容空间的 realloc函数在调整空间时，有两种情况\n可以扩容的情况\n情况1：原有空间后，尚未分配的空间足够\n情况2：原有空间后，尚未分配的空间不够\n1）realloc直接在内存的堆区找到一块新的满足大小的空间\n2）将旧的数据，拷贝到新的空间\n3）释放旧空间\n4）返回新的地址\n所以realloc函数可能返回新的地址，也可能返回旧地址，还可能返回NULL指针\n因为可能开辟失败，为了避免返回NULL指针，使原有的数据也丢失，所以\n需要新创建一个指针变量接收，如果该指针变量不为NULL，再将它的值赋给原有的\n指针变量\n4、常见的动态内存的错误 对NULL指针的解引用操作 对动态申请的空间返回的的指针先要判断是否为NULL\n对动态开辟空间的越界访问\n对非动态开辟内存使用free释放\n使用free释放一块动态开辟内存的一部分\np[i] = i相当于 *（p+i），此时free(p)正确\n*p = i; p++; 此时free(p)会报错\n对同一块内存空间的多次释放\n动态内存开辟忘记释放，可能导致内存泄漏的问题\n服务器的程序，7*24一直在运行\n内存管理是一把双刃剑\n1、提供灵活的内存管理方式\n2、带来风险\n5、经典笔试题分析 6、柔性数组 6.1 基本介绍 C99中，结构中最后一个元素允许是未知大小的数组，这就叫【柔性数组】成员\n1、结构体中\n2、最后一个成员\n3、未知大小的数组\n6.2 柔性数组的特点 1、结构中的柔性数组成员前面必须至少一个其它成员\n2、sizeof返回的这种结构大小不包括柔性数组的内容\n3、包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该\n​ 大于结构的大小，以适应柔性数组的预期大小\n​ 内存大小=结构大小+柔性数组大小\n因为n和arr都是malloc来的，所以后面可以通过realloc来调整这块空间\n一旦使用realloc来调整这块空间，那么后面的数组的空间大小就可以可大可小\n6.3与变长数组的区别 变长数组：指用整型变量或表达式声明或定义的数组\n数组的大小可以由变量来进行指定，并不是数组的大小可变\n变长数组大小一旦开辟好空间，就不能变\n6.4 使用柔性数组的优势 1）方便内存释放，一次free就搞定\n如果我们的代码是在一个给别人的函数中，你做了二次内存分配，并返回结构体的地址给\n用户。用户调用free可以释放结构体，但用户不知道这个结构体里的成员也需要free.\n所以，我们尽量把结构体的内存以及成员要的内存一次性分配好\n2）有利于访问速度（连续的内存有益于提高访问速度，也有益于减少内存碎片）\n注意最后要释放动态开辟的空间\n7、总结C/C++中程序内存区域划分 内核空间：用户代码不能读写\n栈（向下增长）：运行函数而分配的局部变量，函数的形式参数，返回数据，返回地址等\n内存映射段：文件映射、动态库、匿名映射\n堆（向上增长）：动态申请的内存，都在堆区\n静态区（数据段）：全局数据、静态数据\n代码段：可执行代码/只读常量，不能修改\nC/C++程序内存分配的几个区域：\n栈区，执行函数时，函数局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元\n自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限\n堆区一般由程序员分配释放，若程序员不释放，程序结束可能由OS（操作系统）回收\n分配方式类似于链表\n数据段（静态区）：(static)存放全局变量、静态数据。程序结束后由系统释放\n代码段：存放函数体（类成员函数和全局函数）的二进制代码\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-dynamic-memory-management/04_hu_fe9626df7516d3fb.png","permalink":"https://Amarantos-Arrebol.github.io/p/c-dynamic-memory-management/","title":"【C语言基础】动态内存管理"},{"content":"引言 C语言中的数据类型分为内置类型和自定义类型\n其中内置类型就是C语言本身就有的数据类型，比如我们学过的char,short,int,long,float,double… 自定义类型包括结构体、枚举、联合体\n由于内置类型能描述的数据有限，无法直接描述像人和书这样的复杂对象\n比如: 如果我们想描述学生，那么学生一定有姓名（字符型），年龄（整型），成绩（浮点型），学号（整型）…\n如果我们想描述书，那么书一定有书名（字符型），作者（字符型），价格（浮点型）…\n因此，这个时候我们就需要使用C语言中的自定义类型来自己创造这些复杂类型，用来描述复杂对象\n一. 结构体入门： 结构是一些值的集合，这些值被称为成员变量 结构体的每个成员可以是不同类型的变量（数组的每个成员必须是相同类型的变量） 结构体成员的类型可以是基本数据类型，数组，指针，甚至是结构体\n1.1 结构体类型的声明 一般结构体的声明：\n1 2 3 4 struct tag { member - list; }variable-list;//注意：分号不能少 struct：结构体的关键字 tag：结构体标签，可以随意替换，比如要描述书，就可以用Book，描述学生，就可以用Student member - list：成员列表，由一个或多个成员变量组成 variable-list：变量列表\n例如：如果我们想要创建一个学生对象，我们需要先声明学生类型，那么我们如何描述学生的属性呢？我们知道学生一定有姓名，年龄，性别，手机号等信息。因此，简单的学生结构体类型声明如下 1.2 结构体变量的创建和初始化 结构体变量的创建 结构体变量可以在声明的时候就创建 结构体既可以创建全局变量，也可以创建局部变量 结构体的初始化 结构体的初始化要使用大括号（数组初始化时也要用大括号） 结构体的初始化可以用通过两种方式，一种是按顺序来初始化，一种是不按顺序来初始化\n（1）按顺序来初始化 按照结构体类型声明时成员的顺序，给创建的结构体变量赋初始值\n一般初始化： 上面结构体成员声明的顺序是name，age，score，所以初始化的时候也按照这个顺序来初始化\n结构体的成员是结构体类型时的初始化： 结构体的初始化是一层一层往下初始化的，所以当结构体的成员是结构体类型时，我们要先初始化结构体 然后再对结构体里的成员初始化\n（2）不按顺序初始化 通过 .成员名=初始值 的方式初始化，可以不考虑顺序 1.2 结构体的成员访问 直接访问 结构体变量访问成员通过点操作符（.）来完成的 语法：结构体变量名.成员变量名\n例子1： 运行结果： 例子2： 运行结果： 间接访问 如果我们拿到的是指向结构体变量的指针(地址)，那么我们就可以通过结构体访问操作符 (-\u003e) 加成员名的方式，来访问结构体成员\n同时，这种方式也可以用来修改结构体成员里保存的值\n语法：结构体指针-\u0026gt;成员名\n例如： 在上面这段代码中，我们拿到结构体变量p的地址，用结构体指针变量ptr来接收，通过ptr-\u0026gt;x的方式， 我们就可以访问结构体变量p里的成员x，通过ptr-\u0026gt;x = 10 就可以将成员 x 存放的值(3)修改为10\n1.5 typedef 与 结构体 typedef就是给类型重新取一个名字 有时候，结构体的类型名可能比较复杂，这时我们就可以使用 typedef 来简化结构类型的名字\n比如： 一个结构体的类型名为struct Stu 我们可以使用 typedef 将该类型重命名为Stu 那么这个时候，我们既可以使用struct Stu来创建变量，也可以使用Stu来创建变量\ntypedef 重新定义结构体类型有两种方式 方式一： 方式二： 注意：此时的Stu是类型，不是变量\n1.5 结构体传参 结构体传参分为 拷贝结构体数据 和 拷贝结构体的地址 既然有两种结构体传参方式，那我们在写有关结构体传参的函数时应该选择哪种传参方式呢？\n先看一段代码： 在上面这段代码中，我们先是创建了一个结构体变量s，然后想写一个函数将s里的数据打印出来， 这时，我们发现 在函数的参数部分，我们既可以传结构体的地址，也可以传结构体数据的拷贝 两个函数的实现如下： 如果传的是结构体的数据\n1.3 匿名结构体 匿名结构体类型的声明 匿名结构体类型指的是结构体类型没有名字\n需要注意的是： 匿名结构体的类型只能用一次，也就是【只能在类型声明的同时，直接用这个类型创建变量】 因为如果之后再创建结构体变量，需要类型名+变量名的方式创建，但由于匿名结构体类型没有类型名 所以无法创建 匿名结构体类型的应用 定义两个结构体类型，并且它们的成员相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct { char c; int i; double d; }s1; struct { char c; int i; double d; }* ps;//匿名结构体的指针类型 但是，运行下面这段代码时会报错\n1 2 3 4 5 6 int main() { ps = \u0026amp;s1;//报错 return 0; } 原因是虽然这两个结构体的成员相同，但是它们都是没有名字的， 编译器会认为这是两个不同结构体类型的变量\n二、结构体进阶 2.1 结构体的自引用 2.2 结构体内存对齐 结构体内存对齐\n2.3 结构体实现位段（位段的填充\u0026amp;可移植性） 2.4 结构体与指针 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-struct/04_hu_fe9626df7516d3fb.png","permalink":"https://Amarantos-Arrebol.github.io/p/c-struct/","title":"【C语言基础】结构体"},{"content":"引言 我们之前学过strcpy, strcmp, strcat ，strncpy 等和字符串相关的函数，这些函数的操作对象是字符串和\\0，我们无法直接用这些函数完成对浮点型，整型，结构体等类型的数据进行这类操作，这时我们就需要使用到内存相关的函数\n基本介绍 内存相关的函数主要是针对内存块的，可以处理任意类型的数据 操作数据时是以字节为单位进行操作的 内存相关的函数可以接收任意类型的指针（void*），然后其强制转换成字符型指针，再通过一个字节一个字节地操作，最后完成对整个数据的操作\n使用要包含头文件 string.h 一. memcpy 内存拷贝函数 1. 基本介绍 1 void * memcpy ( void * destination, const void * source, size_t num ); memcpy函数作用：只要是放在内存里的数据，就都可以进行拷贝 返回的值：返回的是目标空间的起始地址 形参列表分别对应：目标空间的地址，源空间的地址，要拷贝的字节个数 函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;string.h\u0026gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; int arr2[10] = { 0 }; //将arr1中的3,4,5,6,7拷贝放到arr2中 memcpy(arr2, arr1 + 2, 20);//拷贝5个整型--20字节 for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d \u0026#34;, *(arr2 + i)); } //输出结果3 4 5 6 7 0 0 0 0 0 return 0; } 2. 使用细节 形参列表中的第三个参数指的是要拷贝的字节个数 memcpy函数不负责重叠内存的拷贝 比如 int arr1[ ] = {1,2,3,4,5,6,7}，\n不能使用memcpy函数将arr1里面的1, 2, 3，4拷贝到 arr1 里的3, 4, 5, 6位置上\n原因：当把 1 拷贝到 3 的位置上后，数字3就被覆盖了；当把 2拷贝到 4 的位置上后，数字4就被覆盖了，此后就一直循环拷贝 1, 2\n3. 模拟实现 思路：\n记录目标空间的起始地址(用于最后返回) 强转为字符型指针，原因：void*类型的指针不能进行解引用操作，也不能进行加减运算 循环赋值/拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;assert.h\u0026gt; void* my_memcpy(void* dest, const void* src, size_t num) { void* ret = dest;//记录目标空间的起始地址 assert(dest \u0026amp;\u0026amp; src); while (num--)//循环赋值/拷贝 { *((char*)dest) = *((char*)src);//强转为字符型指针 dest = (char*)dest + 1; src = (char*)src + 1; } return ret;//返回目标空间的起始地址 } 二. memmove 内存移动函数 1. 基本介绍 1 void * memmove ( void * destination, const void * source, size_t num ); memmove函数作用：负责重叠内存的拷贝 返回的值：返回的是目标空间的起始地址 形参列表分别对应：目标空间的地址，源空间的地址，要拷贝的字节个数 函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;string.h\u0026gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; memmove(arr1 + 2, arr1, 20);//将1,2,3,4,5拷贝到3,4,5,6,7处 for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d \u0026#34;, *(arr1 + i)); } //输出结果：1,2,1,2,3,4,5,6,7,8，9,10 return 0; } 2. 使用细节 形参列表中的第三个参数指的是要拷贝的字节个数 C语言标准规定，memcpy只要能实现不重叠的拷贝就行，重叠的拷贝由memmove实现 ​ 在VS上memcpy可以实现重叠内存的拷贝，但在其它编译器上不保证能实现\n3. 模拟实现 思路：\n1.记录目标空间的起始地址 2.强转为char*类型 3.分情况拷贝 情况1:当源的起始地址小于目的地的起始地址时，从后往前拷贝 情况2：当源的起始地址大于目的地的起始地址时，从前往后拷贝 原因：数组随着下标的增长，地址是由低到高变化的 4.返回目标空间的起始地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;assert.h\u0026gt; void* my_memmove(char* dest, char* src, size_t num) { void* ret = dest; assert(dest \u0026amp;\u0026amp; src); if (src \u0026lt; dest)//从后往前拷贝 { while (num--) { *((char*)dest + num ) = *((char*)src + num); } } else//从前往后拷贝 { while (num--) { *((char*)dest) = *((char*)src); dest = ((char*)dest) + 1; src = ((char*)src) + 1; } } return ret;//返回目标空间的起始地址 } 编辑\n三. memset 内存设置函数 1. 基本介绍 1 void * memset ( void * ptr, int value, size_t num ); memset函数是用来设置内存的，可以更改内存块中任意类型的数据 返回类型：返回的是目标空间的起始地址 形参列表分别对应：从哪开始设置内存块，设置成什么内容，总共要设置几个字节 函数的使用1\n1 2 3 4 5 6 7 8 9 #include\u0026lt;string.h\u0026gt; int main() { char arr[] = \u0026#34;hello world\u0026#34;; memset(arr + 6, \u0026#39;*\u0026#39;, 5); printf(\u0026#34;%s\\n\u0026#34;, arr); //输出结果 hello ***** return 0; } 函数的使用2\n1 2 3 4 5 6 7 8 9 #include\u0026lt;string.h\u0026gt; int main() { int arr[10] = { 0 }; memset(arr, 1, 10);//改前10个字节为1 //arr中前10个字节 01 01 01 01 01 01 01 01 01 01 //arr中的数值为 16843009 16843009 257 0 0 0 0 0 0 0 return 0; } 2. 使用细节 memset函数设置内存时是一个字节一个字节进行设置的\n四. memcmp 内存比较函数 1. 基本介绍 1 int memcmp ( const void * ptr1, const void * ptr2, size_t num ); memcmp函数作用：用于比较两个内存块的大小 返回的值：在前 num 个字节中，若ptr1指向的内存大于num2指向的内存，则返回大于0的数字；若ptr2指向的内存小于num2指向的内存，则返回小于0的数字；若ptr2指向的内存等于num2指向的内存，则返回0 形参列表对应：内存块1，内存块2，要比较的字节个数 函数的使用\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;string.h\u0026gt; int main() { int arr1[] = { 1,2,3,4,5 }; int arr2[] = { 1,2,3 ,6,5}; int ret1 = memcmp(arr1, arr2, 12);//返回0 int ret2 = memcmp(arr1, arr2, 13);//返回小于0的数字 return 0; } arr1在内存中的存储对应 0x 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 05 00 00 00\narr2在内存中的存储对应 0x 01 00 00 00 02 00 00 00 03 00 00 00 06 00 00 00 05 00 00 00\n2. 使用细节 函数的第三个参数表示：要比较的字节个数 注意超过一个字节的数据在内存中存储的顺序是怎样的 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-memory-memory-related-functions/04_hu_fe9626df7516d3fb.png","permalink":"https://Amarantos-Arrebol.github.io/p/c-memory-memory-related-functions/","title":"【C语言基础】内存相关的函数"},{"content":"一、指针入门 1.基本概念 1.1 指针 指针就是地址\n在内存里只要分配了数据空间就对应一个地址\n变量在创建的时候，会向内存中申请一块空间，这块空间在创建的同时会被分配一个地址\n可以把计算机中的内存看成宿舍楼，楼里的每个宿舍都有自己的门牌号，而这个门牌号也就是地址/指针，我们根据门牌号就可以找到对应的宿舍\n也就是 指针 = 地址 = 门牌号\n代码示例：\n1 2 short age = 20;//向内存申请2个字节的空间来存放20 float weight = 95.5F;//向内存申请4个字节的空间来存放95.5 示意图如下：\n另外，内存划分为多个内存单元，每个内存单元大小为1个字节（也就是8比特位，可以看成每个宿舍可以住8个人）， 每个内存单元都有自己的地址\n编译器是通过地址找到对应的内存单元\n示意图如下：\n1.2 指针变量 指针变量是用来存放地址的变量\n1.3取地址操作符 \u0026amp; 是取地址操作符，用于拿到地址。拿到的是第一个字节的地址（可以推出剩下的地址**）**\n%p 是用于打印地址的占位符\n看一段代码：\n1 2 int a = 20; int* pa = \u0026amp;a; 解读：\n\u0026amp;a ： 拿到变量a的地址\npa ：pa是一个用来存放a的地址的变量，叫指针变量\nint* 指针类型的理解\n（1）*表示pa是指针变量，int表示pa指向的对象a的类型是int类型的\n（2）int*是pa的类型，即整型指针类型\n整体代码解读：pa是一个整型指针类型的变量，里面存放的是a的第一个字节的地址(指针)\n示意图如下：\n1.4 解引用操作符 是解引用操作符 (间接访问操作符)，用于对指针变量所指向的对象进行操作 当我们拿到地址后，就可以通过地址找到对应的内存空间，\n但如果我们要访问或修改该内存空间里的值，就要通过使用解引用操作符 * 来完成\n例如：\n1 2 3 4 5 int a = 20; int* pa = \u0026amp;a; *pa = 200;//通过pa里面存放的a的地址，找到a对应的内存空间，将里面的值改为200 //等价于 a = 200 printf(\u0026#34;%d\\n\u0026#34;, a);//200 关于指针pa：\n\\1. pa ，里面存放着一个地址\n\\2. *pa ，pa指向的那个对象\n3.\u0026amp;pa，表示pa变量的地址\n2.指针变量的大小 指针变量是用来存放地址的变量\n一个地址的存放需要多大空间，指针变量的大小就是多大\n指针变量的大小只与环境有关**，在相同环境下指针变量的大小相同**\n32位环境下，地址的大小为32个比特位，指针变量大小为4****个字节\n64****位环境下，地址的大小为64个比特位，指针变量大小为8****个字节\n指针变量的大小与类型无关，取地址取的是第一个字节的地址，类型该占几个字节就占几个字节\n示例：\n1 2 3 4 char ch = \u0026#39;w\u0026#39;; char* pc = \u0026amp;ch; //sizeof：计算使⽤类型创建的变量所占内存空间的⼤⼩,单位是字节 printf(\u0026#34;%zd\\n\u0026#34;, sizeof(pc)); 上面代码输出的结果与环境有关，在x64环境下，结果为8 ；在 x86环境下，结果为4\n3.指针类型的意义 (1)指针类型决定了解引用时，一次能向后操作几个字节\n(2)指针类型决定了指针+-整数时，向前或向后走了多大的距离\n3.1指针类型决定了解引用时能向后操作几个字节 先看一段代码：\n1 2 3 int a = 0x11223344; int* pa = \u0026amp;a;//将拿到的a的地址存到整型指针类型的变量pa中 *pa = 0;//修改pa指向的变量a 的值 在上面这段代码中，当执行到 int a = 0x11223344; 这段代码时\n变量a在内存中4个字节的数据是这样的：\n编辑\n当执行到 *pa = 0; 这段代码时\n变量a在内存中4个字节的数据是这样的：\n编辑\n可以看出，当pa的类型是int*时，对pa进行解引用操作，一次能向后修改4个字节的值\n如果将pa的类型改为char*\n1 2 3 int a = 0x11223344; char* pa = \u0026amp;a;//将拿到的a的地址存到字符指针类型的变量pa中 *pa = 0;//修改pa指向的变量a 的值 当执行到*pa = 0时\n变量a在内存中4个字节的数据是这样的：\n编辑\n也就是当pa的类型是 char* 时，对pa进行解引用操作，一次能向后修改1个字节的值\n结论：\nchar*指针类型在解引用操作时只能向后访问1个字节\nint*指针类型在解引用操作时只能向后访问4个字节\n也就是：\nint* p; *p能操作4个字节\nchar* p; *p能操作1个字节\ndouble* p; *p能操作8个字节\nshort* p; *p能操作2个字节\n……\n3.2 指针变量 +- 整数 指针类型决定了指针向前或向后走了多大的距离\n（不改变或不操作 数值）\nint*指针类型+1，向后走了4个字节\nint* pa：pa+1 \u0026lt;==\u0026gt; +1*(sizeof(int))\nchar*指针类型+1，只向后跳=走了1个字节\nchar* pa： pa+1 \u0026lt;==\u0026gt; +1*(sizeof(char))\n示例：\n1 2 3 4 5 6 7 8 int a = 0x11223344; int* pa = \u0026amp;a; char* pc = \u0026amp;a; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a); printf(\u0026#34;%p\\n\u0026#34;, pa); printf(\u0026#34;%p\\n\u0026#34;, pc); //上面三个打印出的结果相同 输出结果如下：\n也就是 \u0026amp;a，pa，pc 拿到的起始地址的值相同\n如果分别对它们 +1 ，代码如下：\n1 2 3 4 5 6 7 int a = 0x11223344; int* pa = \u0026amp;a; char* pc = \u0026amp;a; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a + 1);//向后跳过4个字节 printf(\u0026#34;%p\\n\u0026#34;, pa + 1);//向后跳过4个字节 printf(\u0026#34;%p\\n\u0026#34;, pc + 1);//向后跳过1个字节 输出结果为：\n由于在十六进制中 C 表示12,所以从 DC 到 E0 是跳过了4个字节\n示意图如下：\nint* pa：\npa+n 本质上为向后跳过 n*(sizeof(int))个字节\nchar* pa：\npa+n 本质上为 向后跳过 n*(sizeof(char))个字节\n减法同理，只是是向前偏移\n4.指针运算 可以把指针类比成日期，整数类比成天数\n1.指针+-整数 日期+-天数 = 日期\n2.指针-指针 日期-日期 = 天数\n3.指针+指针 日期+日期 没意义\n4.指针的关系运算 指针大小的比较\n4.1指针 +- 整数 指针类型决定了指针 +- 整数时的步长，还决定了指针解引用时一次能访问几个字节\n应用场景：如 打印数组里的每一个元素\n由于数组在内存中连续存放，所以只要拿到第一个元素的地址，就可以通过解引用访问一个元素，+1跳过一个元素，来完成数组中每一个元素的打印\n代码如下：\n1 2 3 4 5 6 7 8 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };//int类型的数组，里面每个元素都是int类型 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组有几个元素 int* p = \u0026amp;arr[0];//取出数组首元素的地址存到 p 里面 for (int i = 0; i \u0026lt; sz; i++) { printf(\u0026#34;%d \u0026#34;, *p);//解引用向后访问4个字节，也就是访问了数组里的一个元素 p++;//p+1--向后跳过4个字节，即跳过数组里的一个元素 } 示意图如下：\n编辑\n4.2指针-指针 前提：两个指针指向的是同一块空间\n指针 - 指针的绝对值是指针和指针之间元素的个数\n示例：\n1 2 3 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; printf(\u0026#34;%d\\n\u0026#34;, \u0026amp;arr[9] - \u0026amp;arr[0]);//9 printf(\u0026#34;%d\\n\u0026#34;, \u0026amp;arr[9] - \u0026amp;arr[0]);//-9 示意图如下：\n编辑\n4.3指针的关系运算 指针的关系运算就是让指针进行大小的比较\n每一个字节都有自己的地址，地址就有大和小之分\n应用场景：如打印数组里的每一个元素\n原因：在内存中，数组的地址是由低到高变化的\n示例：\n1 2 3 4 5 6 7 8 9 10 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int sz = sizeof(arr) / sizeof(arr[0]);//计算数组有几个元素 int* p = \u0026amp;arr[0];//取出数组首元素的地址存到 p 里面 //打印数组里的每个元素 while (p \u0026lt; \u0026amp;arr[sz])//两个地址相比较 { printf(\u0026#34;%d \u0026#34;, *p); p++; } 上面代码中，当p里面存放的地址小于下标为10的元素的地址时，就找到p所指向的内容并打印\n示意图如下：\n5.二级指针 二级指针：用来存放一级指针变量的地址\n代码示例：\n1 2 3 int a = 10; int* pa = \u0026amp;a;//pa是一级指针变量 int** ppa = \u0026amp;pa;//ppa是二级指针变量，存放是pa的地址 int 的含义：*\n（1）* 说明是指针变量\n（2）int 表示指针指向的对象是 int 整型的\nint** 的含义：\n（1）* 说明是指针变量\n（2）int* 表示指针指向的对象是 int* 整型指针类型的\n示意图：\n**ppa = *pa = a\n二、指针基础 1.基本类型指针 1.1指针与字符 字符指针\n1.字符指针变量 存放的是字符串中首字符的地址\n1 2 3 char* p = \u0026#34;abcdef\u0026#34;;//a b c d e f \\0 //把字符串首字符的地址赋给p printf(\u0026#34;%c\\n\u0026#34;, *p);//a 2.字符指针变量 存放的是常量字符串,**不能被修改，**使用const修饰\n1 const char* p = \u0026#34;abcdef\u0026#34;;//const放在 * 的左边，限制的是*p 3.使用%s打印字符串的时候，只需提供首字符的地址\n1 2 3 char* p = \u0026#34;abcdef\u0026#34;;//把字符串首字符的地址赋给p //%s打印字符串时，只需要提供首字符的地址 printf(\u0026#34;%s\\n\u0026#34;, p);//abcdef 4.内容相同的常量字符串只用存一份（只读数据区，可以用，但不能改）\n1 2 3 4 const char* str1 = \u0026#34;haha\u0026#34;; const char* str2 = \u0026#34;haha\u0026#34;; //str1 与 str2 存放的地址相同 //内容相同的常量字符串，只用存一份 对比字符数组存放数据：\n1 2 3 4 char str3[] = \u0026#34;hehe\u0026#34;; char str4[] = \u0026#34;hehe\u0026#34;; //\u0026amp;str3[0] 与 \u0026amp;str4[0]不相同 //数组str3与数组str4虽然存放的内容相同，但是二者是两块不同的空间 1.2 指针与数组 \\1. 数组指针 本质上是指针；指针数组 本质上是数组\n\\2. [ ] 的优先级高于 *\n例如：int* arr[6] 是指针数组 ，int(*) arr[6] 是数组指针， （）提高优先级\n数组指针\n1. 数组名的理解\n（1）数组名是数组首元素的地址\n​ 例如：arr ， \u0026amp; arr[0] 都表示数组首元素的地址，类型 int*，指针类型\n（2）\u0026amp;数组名：其中数组名表示整个数组；数组的地址与数组首元素的地址值相同\n1 2 3 4 5 int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr[0]);//数组首元素的地址 printf(\u0026#34;%p\\n\u0026#34;, arr);//数组首元素的地址 printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr);//数组的地址 //打印结果相同 （3）数组名+1，跳过数组里的一个元素 ； \u0026amp;数组名+1，跳过的是整个数组\n指针类型决定了指针+-整数跳过几个字节\narr \u0026mdash; int* \u0026amp;arr[0] \u0026mdash; int* \u0026amp;arr \u0026mdash; int ( * )[ ] 数组指针类型\n（4）arr[ i ] 等价于 *(arr + i) arr[ i ] 等价于 i[ arr ]，[ ] 只是操作符\n（5）sizeof (数组名) ：计算整个数组的大小（字节）\n1 2 int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; printf(\u0026#34;%zd\\n\u0026#34;, sizeof(arr));//40 计算的是整个数组的大小 2. 数组指针变量\n数组指针变量：用于存放 数组的地址\n示例：\n1 2 3 int arr[10] = { 1,2,3,4,5 }; int(*p)[10] = \u0026amp;arr;//p是数组指针，p里面存放的是数组的地址 //p的类型是 int(*)[] int(*p)[10] 的含义：\n（1）( *p )：p先与 * 结合，说明 p是指针变量\n（2） [10]：p指向的数组的元素是10\n（3）int：p指向的数组的元素类型是整型的\n*p等价于arr\n3. 数组传参\n数组传参的本质上传递的是数组首元素的地址\n数组传参，形参可以写成指针，也可以写成数组，但本质上还是指针\n一维数组传参\n示例，使用指针计算数组里有多少个元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void test(int* arr)//形参还可以写成 int arr[] { int sz2 = sizeof(arr) / sizeof(arr[0]);//指针变量的大小只与环境有关 //32环境下：4 / 4 64位环境下：8 / 4 printf(\u0026#34;%d\\n\u0026#34;, sz2);//输出 1 或 2 } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int sz1 = sizeof(arr) / sizeof(arr[0]);//40 / 10 printf(\u0026#34;%d\\n\u0026#34;, sz1);//输出 10 test(arr);//传的是数组首元素的地址 return 0; } 二维数组传参\n因为数组名是数组首元素的地址，而二维数组的每个元素是一个一维数组\n所以 二维数组的数组名表示的是二维数组里的第一个一维数组的地址\n示例，使用指针打印二维数组：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void print(int(*arr)[5], int row, int col)//用数组指针接收一维数组的地址 { for (int i = 0; i \u0026lt; row; i++)//拿到每个一维数组 { for (int j = 0; j \u0026lt; col; j++)//拿到一维数组里的每一个元素 { printf(\u0026#34;%d \u0026#34;,*( *(arr + i) + j));//等价于arr[i][j] } printf(\u0026#34;\\n\u0026#34;); } } int main() { int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} }; print(arr, 3, 5);//将arr数组的内容打印 return 0; } *(arr +i) ：拿到每个一维数组，等价于 arr[ i ] == \u0026amp;arr[ i ][ 0 ]\n*( (*arr+i) + j) ：拿到一维数组里的每一个元素，等价于arr[ i ][ j ]\n示意图：\n指针数组\n指针数组：用来存放指针 的数组，数组的每个元素是指针类型\n例如：\n1 2 3 4 5 int a = 10; int b = 20; int c = 30; //[ ]的优先级高于* int* arr[3] = { \u0026amp;a, \u0026amp;b, \u0026amp;c };//整型指针数组 注意：指针数组要指定数组的大小\n1.3指针与函数 函数的传参机制 函数定义里的参数是形参，函数调用里传的参数是实参\n形参是实参的一份拷贝，对形参的修改不会影响到实参\n形参和实参是两块独立的空间\n（1）传值调用（把变量本身传过去）：\n把实参拷贝给形参，形成两块独立的空间（例如求两个数的和）\n（2）传址调用（把变量的地址传过去）：\n传实参的地址给形参，形参操作的内存空间是实参的内存空间，\n在函数内部可以修改主调函数 （例如通过函数将两个数的值交换）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void swap(int* pa, int* pb)//通过pa能找到a { //解引用pa得到a,解引用pb得到b int z =*pa; *pa = *pb;//a = b *pb = z;//b = z //pa是地址，*pa是pa地址指向的内容 } int main8() { int a = 0; int b = 0; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); swap(\u0026amp;a, \u0026amp;b);//交换a,b的值 return 0; } 函数指针 数组指针，是指向数组的指针\n函数指针，是指向函数的指针，存放函数地址的指针\n\u0026amp;函数名和函数名 都能拿到函数的地址\n1 2 3 4 5 6 7 8 9 10 11 12 int Add(int x, int y){ return x + y; } int main() { //\u0026amp;数组名和数组名都表示函数的地址 int (*pf)(int, int) = Add;//pf是函数指针变量 //int(*)(int, int) 函数指针类型 return 0; } int (*pf) (int, int) 的含义：\n（1）( \\*pf ) ： pf是变量名 ，* 说明 pf 是指针变量\n（2）(int, int)：pf 指向的是函数，该函数有两个int类型的参数，\n​ 只需要交代函数参数的个数和类型，参数名可以不写\n（3）int：说明该函数的返回类型是 int 类型\n通过函数指针调用函数\n对于函数指针，调用的时候可以先解引用一下再调用，也可以不解引用直接调用\n1 2 3 4 5 int (*pf)(int, int) = \u0026amp;Add;//pf是函数指针变量 //通过函数指针调用函数 (*pf)(4, 5);//写法1 pf(4, 5);//写法2 两段有趣的代码\n1 2 //代码1 (*(void(*)())0)(); void(*)()是一个函数指针类型\n( 函数指针类型 )0 是强制类型转换，也就是把0强制类型转换成函数指针类型，0就是一个函数地址\n(*(函数指针类型)0)( ) 表示将0强转后再解引用找到这个函数，再调用这个函数\n注意：（类型）是强制类型转换\n1 2 //代码2 void (*signal(int, void(*)(int)))(int); signal是一个函数声明\nsignal函数有两个参数，分别是整型的和函数指针类型的，该函数指针指向的函数参数是int，返回类型是void\nsignal函数的返回类型是void(*)(int)，也就是函数指针类型：该函数指针指向的函数参数是int，返回类型是void\n函数声明是告诉我们函数名，函数参数，函数返回类型，所以这是一个函数声明\ntypedef给类型重命名 我们发现上面的代码中，函数的返回类型是函数指针类型，这样不仅繁琐，而且可读性差\n所以我们可以使用typedef来给该类型重命名\n1 typedef void(*pfunc_t)(int); 上面这段代码意思为将类型 void(*)(int) 重命名为 pfunc_t\n这时，代码2就可以简化成下面这种写法了\n1 pfunc_t signal(int, void(*)(int)); **注意：**重命名的类型要放在*后面，这和我们重命名其它类型有所不同\n对于其它类型，我们是直接将重命名的类型放在原类型的后面\n1 typedef unsigned int uint; 意思为给unsigned int这个类型重命名为uint\n函数指针数组 指针数组，是一个数组，里面存放的是相同类型的指针\n函数指针数组，是一个数组，可以用来存放多个同类型的函数指针\n例如：\n1 2 3 4 5 6 int (*pf1)(int, int) = Add;//Add加法函数 int (*pf2)(int, int) = Sub;//Sub减法函数 int (*pf3)(int, int) = Mul;//Mul减法函数 //函数指针数组 int(* pf[3])(int, int) = {pf1, pf2, pf3}; int(* pf[3])(int, int) = {Add, Sub, Mul};//也可以这样写 pf 先与[ 3 ] 结合：表示pf是数组\nint (*) (int, int) ：表示pf这个数组里的每个元素的类型是函数指针类型\n通过函数指针数组来调用函数：\n1 2 3 pf[0](6, 4);//调用加法函数 pf[1](6, 4);//调用加法函数 pf[2](6, 4);//调用加法函数 函数指针数组的用途-转移表 例子（计算器）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 void menu() { printf(\u0026#34;*************************************\\n\u0026#34;); printf(\u0026#34;********** 1. add 2. sub ********\\n\u0026#34;); printf(\u0026#34;********** 3. mul 4. div ********\\n\u0026#34;); printf(\u0026#34;********** 0.exit ********\\n\u0026#34;); printf(\u0026#34;*************************************\\n\u0026#34;); } int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } int main() { int input = 0; int x = 0, y = 0; //pfArr是一个函数指针数组 int (*pfArr[])(int, int) = {0, Add, Sub, Mul, Div}; do { menu(); printf(\u0026#34;请选择:\u0026gt;\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if (input \u0026gt;= 1 \u0026amp;\u0026amp; input \u0026lt;= 4) { printf(\u0026#34;请输入操作数:\u0026gt;\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); int ret = pfArr[input](x, y); printf(\u0026#34;ret=%d\\n\u0026#34;, ret); } else if (input == 0) { printf(\u0026#34;退出\\n\u0026#34;); } else { printf(\u0026#34;选择错误，请重新选择\u0026#34;); } } while (input); return 0; } 指向函数指针数组的指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { //函数指针 int (*pf)(int, int); //函数指针数组 int (*pfArr[4])(int, int);//pfArr是一个数组，每个元素是函数指针 //指向函数指针数组的指针 int (*(*ppfArr)[4])(int, int) = \u0026amp; pfArr; //ppfArr是一个数组指针，指针指向的数组有4个元素， //每个元素的类型是函数指针 int(*)(int, int) return 0; } 回调函数 回调函数就是通过函数指针调用函数。\n把函数指针(地址)作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，\n我们就说这是回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 void menu() { printf(\u0026#34;*************************************\\n\u0026#34;); printf(\u0026#34;********** 1. add 2. sub ********\\n\u0026#34;); printf(\u0026#34;********** 3. mul 4. div ********\\n\u0026#34;); printf(\u0026#34;********** 0.exit ********\\n\u0026#34;); printf(\u0026#34;*************************************\\n\u0026#34;); } int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } void Calc(int (*pf)(int, int)) { int x = 0, y = 0; printf(\u0026#34;请输入两个操作数:\u0026gt;\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); printf(\u0026#34;%d\\n\u0026#34;, pf(x, y)); } int main() { int input = 0; do { menu(); printf(\u0026#34;请选择:\u0026gt;\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); switch (input) { case 1: Calc(Add); break; case 2: Calc(Sub); break; case 3: Calc(Mul); break; case 4: Calc(Div); break; case 0: printf(\u0026#34;退出\\n\u0026#34;); break; default: printf(\u0026#34;选择错误，请重新选择\u0026#34;); break; } } while (input); return 0; } 2.特殊类型指针 2.1 Void 无具体类型的指针 void* 类型的指针可以接收任意类型的地址\n示例：\n1 2 3 4 5 int a = 10; char ch = \u0026#39;a\u0026#39;; void* pv1 = \u0026amp;a;//\u0026amp;a类型为int* void* pv2 = \u0026amp;ch;//\u0026amp;ch类型为char* 上面的代码中，void* 类型的指针既可以接收 int* 类型的地址，也可以接收 char* 类型的地址\n（1）注意 void*类型的指针不能直接进行解引用操作，也不能进行+-运算\n（2）应用场景：当不清楚别人会传什么类型的地址给程序时，可用void*类型的指针接收\n（3）如果需要对void*类型的指针进行解引用操作或进行+-运算，那么需要先将接收到的void*类\n​ 型的指针强制类型转换成所需要的类型，再进行操作\n2.2 野指针 概念\n指针指向的空间是随机的，不正确的\n这块空间不属于当前程序所占有的，当前程序没有权限去访问这块空间\n造成野指针的原因\n产生原因：1.指针未初始化 （如：int* p;）\n​ 2.指针越界访问\n​ 3.指针指向的空间已被销毁\n1.指针未初始化\n一个局部变量如果不初始化，它的值是随机的\n1 2 int* p;//指针未初始化，随机值 *p = 20;//p就是野指针 上面这段代码中，p 是局部变量，但是没有初始化，它的值是随机的，如果将p中存放的值当成地址，就会形成非法访问\n2.指针越界访问\n当解引用到非法空间时，就是野指针\n1 2 3 4 5 6 7 int arr[10] = { 0 }; int* p = \u0026amp;arr[0];//取出数组arr的第一个元素的地址 for (int i = 0; i \u0026lt;= 10; i++) { *p = i;//当 i = 10 ，p 越界访问arr[10]这块空间的时候，p就是野指针 p++; } 示意图：\n编辑\n3.非法访问\n主函数调用函数，该函数返回一个局部变量的地址（局部变量进函数创建，出函数就销毁）给主函数里的指针，此后指针若进行解引用操作，就会形成非法访问\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int test() { int n = 100;//n是局部变量，进入函数，开辟一块空间存放n return \u0026amp;n;//n的地址返回 }//出函数，n的空间被销毁 int main() { int* p = test();//调用test函数，p得到n的地址，此时n对应的那块空间已经被销毁 printf(\u0026#34;%d\\n\u0026#34;, *p);//非法访问 return 0; } 如何避免野指针？\n（1）指针初始化（赋明确的地址 或 赋 NULL）\n（2）小心越界\n（3）指针变量不再使用时，及时置NULL，指针使用 之前检查有效性\n（4）避免返回局部变量的地址\n(1) 指针初始化\n当有明确的指向时，直接给指针对应的赋地址；当没有明确的指向时，给指针赋NULL\nNULL：是空指针，值为 0 ，是地址，读写该地址会 报错\nC语言中NULL的定义：（void*)0\n0是整型，强制转换成指针类型\n1 2 3 int a = 10; int* p = \u0026amp;a;//有明确的指向，赋值a的地址 int* p2 = NULL;//没有明确的指向，赋值NULL （2）小心越界\n对指针进行解引用操作前，要先确保指针指向的空间是当前程序所占有的\n（3）指针变量不再使用时，及时置NULL，指针使用 之前检查有效性\n1 2 3 4 5 6 7 int a = 10; int* p = \u0026amp;a; p = NULL;//当不再使用指针变量时，将其置为NULL if (p != NULL)//对指针进行解引用操作前，先检查指针的有效性 { *p = 200; } （4）避免返回局部变量的地址\n局部变量：进入作用域，变量创建，出作用域，变量就被销毁\n返回局部变量的地址，此后指针若进行解引用操作，会形成非法访问\n3.指针代码的优化 3.1 const修饰 3.1.1 const 修饰变量\n常量：值是固定的，不能更改\n变量：值可以改变\n比如下面这段代码中的num就是变量，num的值先是20，后面被修改为30\n1 2 int num = 20; num = 30; const修饰的变量叫常变量\n这个被修饰的变量本质上还是变量，只是不能被修改\n比如下面这段代码：\n1 2 const int num = 20;//num具有了常量的属性，num的值不能被修改 num = 30;//报错 变量num被const修饰，从而具有了常量的属性 ，当修改变量num的值时，编译器就会报错\n再看一段代码：\n1 2 int n = 10; int arr[n];//报错 这段代码会报错的原因是：\nC99之前不支持变长数组，数组的大小需要 常量或常量表达式 来指定，不能用变量来指定\n当我们用const修饰变量n后：\n1 2 const int n = 10;// n被const修饰后，本质上还是变量 int arr[n];//报错 这段代码还是会报错，原因是const修饰的变量本质上还是变量，只是它的值不能被修改\n3.1.2 const修饰指针变量\n引入\n看一段代码：\n1 2 3 4 5 const int n = 10; //n = 200;//无法直接修改 int* p = \u0026amp;n; *p = 200;//n = 200 可以修改 printf(\u0026#34;%d\\n\u0026#34;, n);//200 在上这段代码中：\nconst修饰变量，虽然变量n不能直接修改，但还是可以通过拿到 n 的地址对n进行修改\n但是如果我们不希望 n 能以任何方式被修改，不管是直接被修改，还是通过地址被修改，那么就需要使用const修饰指针变量\n语法\nconst修饰指针变量有两种形式，一种是const放在 * 左边，一种是 * 放在const右边\n（1）const在 * 左边修饰(两种写法)：\n1 2 3 4 5 int n = 10; //const在*左边修饰 const int* p = \u0026amp;n;//写法一 //int const * p = \u0026amp;n;//写法二 此时，如果通过指针变量 p 修改 变量 n 里的内容，就会报错\n1 *p = 20;//err 原因：\nconst放在 * 的左边修饰，不能更改指针指向的 对象里面的内容\n但是指针可以更改指向的对象，也就是指针可以不指向原来的地址\n比如：\n1 2 3 4 5 int n = 10; int m = 100; const int* p = \u0026amp;n;//const在*左边修饰 p = \u0026amp;m;//ok （2）const在 * 右边修饰：\n1 2 3 4 5 int n = 10; int m = 100; //const在*右边修饰 int* const p = \u0026amp;n; 此时如果更改 p 指向的对象，会报错\n1 p = \u0026amp;m;//err 原因：\nconst在*右边修饰的时候，指针不能更改指向的对象\n但是可以更改指针指向的 变量里的内容\n1 2 3 4 5 int n = 10; int m = 100; int* const p = \u0026amp;n;//const在*右边修饰 *p = 200;//ok （3）如果const在 * 左右两边都修饰：\n1 2 3 4 5 6 7 int n = 10; int m = 100; //const同时在 * 的左右两边修饰 const int* const p = \u0026amp;n; *p = 200;//err p = \u0026amp;m;//err 结论\n当const在 * 左边修饰时，指针指向的 变量的值 不能被修改\n当const在 * 右边修饰时，指针的指向不能变，指针不能更改指向的对象\n3.2 assert断言 可用于检测指针的有效性\n1.使用assert（）宏要包含头文件assert.h\n2.判断括号里的表达式，若为真，程序正常运行； 若为假，在屏幕上写入错误信息，未通过该表达 式，并显示出问题的文件名以及行号\n例如：\n1 2 int* p = NULL; assert(p != NULL);//括号里面的值为假就会报错 编辑\n3.如果不需要再执行assert（），可直接在它的头文件前面定义一个宏NDEBUG\n例如：\n1 2 3 4 5 6 7 8 9 #define NDEBUG #include\u0026lt;assert.h\u0026gt; int main() { int* p = NULL; assert(p != NULL);//定义了NEDBUG宏后，assert失效，不会报错 return 0; } 可以通过注释掉 #define NDEBUG 这条语句，使得 assert 语句可以执行\nassert（）会增加程序的运行时间\nVS中，在release版本下，可选择禁用assert（），默认会优化掉assert（）\n三、指针进阶 1. qsort函数 基本介绍\n冒泡排序，只能排序整型数组\nqsort函数，快速排序，可以排序任意类型的数据\n函数原型\n1 2 3 4 5 6 void qsort(void* base, //待排序数组的起始位置 size_t num, //待排序数组的元素个数 size_t width, //每个元素有几个字节 int(*compare)(const void* elem1, const void* elem2)//函数指针，函数要自己实现 // 要比较的那两个元素的地址 ); 函数参数 void* base 使用void*接收目标数组的起始位置，这样可以排任意类型的数据\nint(\\*compare)(const void* elem1, const void* elem2)\n中compare这个指针可以接收要比较的两个元素的地址，由于不知道要比较的两个元素的类型，\n所以使用void*来接收\n函数的返回值 当第一个元素小于第二个元素时，返回小于0的数字\n当第一个元素大于第二个元素时，返回大于0的数字\n当第一个元素等于第二个元素时，返回等于0的数字\n使用要包含头文件stdlib.h 模拟实现qsort函数(以结构体为例)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 int cmp_stu_by_age(const void* e1, const void* e2) { return ((struct Stu*)e1)-\u0026gt;age - ((struct Stu*)e2)-\u0026gt;age; } int cmp_stu_by_name(const void* e1, const void* e2) { //比较字符串，使用strcmp，要引头文件string.h return strcmp(((struct Stu*)e1)-\u0026gt;name, ((struct Stu*)e2)-\u0026gt;name); } //实现bubble_sort的程序员不知道未来排序的数据类型 //也不知道待比较的两个元素类型 void Swap(char* buf1, char* buf2, int width) { int i = 0; for (i = 0; i \u0026lt; width; i++) { char tmp = *buf1; *buf1 = *buf2; *buf2 = tmp; buf1++; buf2++; } } void bubble_sort(void* base, int sz, int width, int (*cmp)(const void* e1, const void* e2)) { int i = 0; for (i = 0; i \u0026lt; sz - 1; i++)//趟数 { int j = 0; for (j = 0; j \u0026lt; sz - 1 - i; j++)//每一趟比较的对数 { //两个元素的比较 if (cmp((char*)base + j * width, (char*)base + (j + 1) * width) \u0026gt; 0) { //交换 Swap((char*)base + j * width, (char*)base + (j + 1) * width, width); } } } } //测试 struct Stu { char name[20]; int age; }; void test5() { struct Stu s[3] = { {\u0026#34;zhangsan\u0026#34;, 20}, {\u0026#34;lisi\u0026#34;, 30}, {\u0026#34;wangwu\u0026#34;, 10} }; int sz = sizeof(s) / sizeof(s[0]); //使用bubble_sort的程序员一定知道自己排序的是什么数据 //就应该知道如何比较待排序数组中的元素 bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_name); } 2. 指针和数组笔试题解析 2.1 一维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int a[] = { 1, 2, 3, 4 }; printf(\u0026#34;%d\\n\u0026#34;, sizeof(a)); //sizeof(数组名) -- 计算的是整个数组的大小，4*4=16 printf(\u0026#34;%d\\n\u0026#34;, sizeof(a + 0)); //数组名表示数组首元素的地址，+0还是首元素地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*a)); //数组名表示首元素的地址，*a就是首元素，4字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(a + 1)); //数组名表示数组首元素的地址，+1跳过一个元素，是第二个元素的地址，4或8字节 // printf(\u0026#34;%d\\n\u0026#34;, sizeof(a[1])); //第二个元素的大小，4字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a)); //\u0026amp;a取出的是数组的地址，但数组的地址也是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*\u0026amp;a)); //\u0026amp;a数组的地址，数组的地址解引用访问的数组，sizeof计算的就是数组的大小，16字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a + 1)); //\u0026amp;a取出的是数组的地址，+1跳过整个数组，但还是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a[0])); //\u0026amp;a[0]第一个元素的地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;a[0] + 1)); //\u0026amp;a[0]第一个元素的地址，\u0026amp;a[0] + 1第二个元素的地址，4或8字节 数组名是数组首元素的地址\n但有两个例外：\nsizeof(数组名) - 数组名表示整个数组\n\u0026amp;数组名 - 数组名表示整个数组，即取出整个数组的地址\n2.2 字符数组 ==char arr[] = {\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;,\u0026lsquo;f\u0026rsquo;};==\nsizeof\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 char arr[] = { \u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39; }; printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr)); //sizeof(数组名) - 整个数组的大小，6*1=6字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr + 0)); //arr数组首元素地址，arr+0还是首元素的地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*arr)); //arr数组首元素地址，*arr首元素，1字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr[1])); //第二个元素的大小，1字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr)); //\u0026amp;arr取出整个数组的地址，但还是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr + 1)); //\u0026amp;arr整个数组的地址，\u0026amp;arr+1跳过整个数组，还是地址，4或8字节 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr[0] + 1)); //\u0026amp;arr[0]首元素的地址，\u0026amp;arr[0]+1第二个元素的地址，4或8字节 strlen\n1 2 3 4 5 6 7 8 9 10 char arr[] = { \u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39; }; printf(\u0026#34;%d\\n\u0026#34;, strlen(arr));//随机值 printf(\u0026#34;%d\\n\u0026#34;, strlen(arr + 0));//随机值 printf(\u0026#34;%d\\n\u0026#34;, strlen(*arr));//err //*arr是元素\u0026#39;a\u0026#39;，对应ASCII码值为97，strlen把97当做地址，然后向后访问，形成非法访问 printf(\u0026#34;%d\\n\u0026#34;, strlen(arr[1]));//err printf(\u0026#34;%d\\n\u0026#34;, strlen(\u0026amp;arr));//取的是数组的地址，数组的地址也从起始位置开始，随机值 printf(\u0026#34;%d\\n\u0026#34;, strlen(\u0026amp;arr + 1));//跳过整个数组，从数组最后的地址开始访问，随机值-6 printf(\u0026#34;%d\\n\u0026#34;, strlen(\u0026amp;arr[0] + 1));//从第二个元素的地址开始，随机值-1 ==char arr[] = \u0026ldquo;abcdef\u0026rdquo;;==\nsizeof\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { char arr[] = \u0026#34;abcdef\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr));//7，包括\\0 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr + 0));//4/8，地址 printf(\u0026#34;%d\\n\u0026#34;, sizeof(*arr));//1，char类型元素的大小 printf(\u0026#34;%d\\n\u0026#34;, sizeof(arr[1]));//1，第二个元素的大小 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr));//4/8，取出整个数组的地址，还是地址 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr + 1));//4/8，跳过整个数组后的地址 printf(\u0026#34;%d\\n\u0026#34;, sizeof(\u0026amp;arr[0] + 1));//4/8，第二个元素的地址 return 0; } strlen\n==char *p = \u0026ldquo;abcdef\u0026rdquo;;==\nsizeof\nstrlen\nstrlen 和 sizeof区分\n1.strlen是求字符串长度的，只能针对字符串求长度，目的是找到\\0 \u0026ndash;是库函数，得引头文件\nstrlen的参数要的是地址，通过对该地址解引用，如果不是\\0就长度+1\n2.sizeof计算变量、数组、类型的大小 \u0026ndash; 单位是字节 \u0026ndash;是操作符\n2.3 二维数组 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-pointer-basic/04_hu_fe9626df7516d3fb.png","permalink":"https://Amarantos-Arrebol.github.io/p/c-pointer-basic/","title":"【C语言基础】指针入门"},{"content":"前言 C语言中字符函数和字符串函数是非常重要的，可以方便我们对字符和字符串进行处理。本文中主要介绍几种常见的字符函数和字符串函数。\n一.strlen求字符串长度 1. strlen函数 strlen函数的介绍\n1 size_t strlen ( const char * str ); 字符串的结束标志是 \\0 strlen 函数是用来求字符串的长度的，是从字符串的第一个字符开始往后统计字符个数， 遇到 \\0 就停止统计，如果没有遇到 \\0 ,就会一直往后统计，直到遇到 \\0 才会停止统计 所以strlen是用来统计字符串 \\0 之前的字符个数的函数 需要注意的是strlen函数返回的是无符号整型 strlen函数返回的无符号整型的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { if (strlen(\u0026#34;abc\u0026#34;) - strlen(\u0026#34;abcdef\u0026#34;) \u0026gt; 0) { printf(\u0026#34;hehe\\0\u0026#34;);//输出结果为hehe } else { printf(\u0026#34;haha\\n\u0026#34;); } return 0; } 分析：\nstrlen返回的是无符号整型，两个无符号整型相减的结果也应为无符号整型 所以应该将strlen(\"abc\") - strlen(\"abcdef\")的到的结果 -3 转为无符号整型，\n由于整型在内存中是以补码方式进行存储的，所以要先得到-3的补码，\n然后再将补码的符号位改为0。\n-3的原码为 10000000 00000000 00000000 00000011\n-3的反码为 11111111 11111111 11111111 11111100\n-3的补码为 11111111 11111111 11111111 11111101\n转成无符号数 01111111 11111111 11111111 11111101\n可以看出，-3转为无符号整型后的结果是一个非常大的数，\n因此，上面代码的输出结果为hehe\n实现strlen函数的三种方法\n方法一：计数器\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;assert.h\u0026gt; size_t my_strlen(const char* str) { int count = 0; assert(str != NULL); while (*str != \u0026#39;\\0\u0026#39;)//while(*str) { count++;//统计个数 str++; } return count; } 定义一个变量count来统计字符个数，如果该字符不是 \\0 ，则count++，最后返回count的值\n方法二：指针-指针\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;assert.h\u0026gt; size_t my_strlen(const char* str) { assert(str != NULL);//检测指针的有效性 char* start = str;//记录起始地址 while (*str != \u0026#39;\\0\u0026#39;) { str++; } return str - start; } 指针-指针的绝对值是指针和指针之间元素的个数\n要统计字符串中的字符个数，首先要得到该字符串的起始地址和结束地址（\\0前的地址），然后将两地址相减，得到的就是字符串之间的字符个数\n方法三：递归方式\n1 2 3 4 5 6 7 8 9 10 11 size_t my_strlen(const char* str) { if (*str != \u0026#39;\\0\u0026#39;) { return 1 + my_strlen(str + 1); } else { return 0; } } 因为统计字符串的长度是先从首字符开始的，所以如果首字符是 \\0 ,那么该字符串长度就为0，如果首字符不是 \\0 的，那么该字符串中至少有1个不为 \\0 的有效字符，字符串的长度就是1+后面字符的个数，依次类推\n假设求的是字符串 “abcd” 的长度，那么用递归求解的具体步骤如下：\n首字符是 a ，不是 \\0 ，字符串 “abcd\\0” 的长度为 1 + “bcd\\0”的长度 “bcd\\0”首字符是 b ,不是 \\0 ,字符串 \u0026ldquo;bcd\\0\u0026rdquo; 的长度为 1 + “cd\\0”的长度 “cd\\0”的首字符是 c ，不是 \\0 ，字符串“cd\\0”的长度为 1 + “d\\0”的长度 “d\\0”的首字符是 d ，不是 \\0 ，字符串“d\\0”的长度为 1 + “\\0” 的长度 “\\0”的首字符是 \\0 ，由于字符串统计的是\\0之前的字符个数，因此“\\0”长度为0 最后得出字符串“abcdef”的长度为0+1+1+1+1 = 4 二.长度不受限制的字符串函数 1. strcpy字符串拷贝函数 strcpy 函数的介绍\n1 char * strcpy ( char * destination, const char * source ); strcpy 是字符串拷贝函数\n有两个形参，第一个形参是目标字符串，第二个形参是源字符串，该函数是将源字符串里的内容拷贝到目标字符串，当拷贝完源字符串里的 \\0 后就停止拷贝，并返回目标空间的起始地址\n需要注意的是：\n目标字符串的空间一定要大于源字符串所占的空间大小 目标字符串必须可修改 要拷贝源字符串中的 \\0 模拟实现strcpy\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;assert.h\u0026gt; char* my_strcpy(char* dest, const char* src) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); //拷贝src中的字符串到dest指向的空间，包含\\0 while (*dest++ = *src++)//当\\0拷贝过去后，结果为假，停止循环 { ; } return ret;//返回目标空间的起始地址 } 思路如下：\n1.找到目标字符串的起始地址和源字符串的起始地址\n2.将目标字符串的起始地址存一份\n3.从源字符串起始字符开始，依次拷贝到目标字符串，当拷贝完源字符串中的\\0后就停止拷贝\n4.返回目标字符串的起始地址\n2. strcat字符串追加函数 strcat 函数的介绍\n1 char * strcat ( char * destination, const char * source ); strcat是字符串追加函数，作用是将源字符串拷贝到目标字符串的结束位置处，\n返回的是目标空间的起始地址。\n需要注意的是：\n源字符串的首字符要覆盖目标字符串的 \\0 要拷贝源字符串的\\0 目标字符串要保证可以被修改，并且空间能容纳追加后的字符串 不保障自己给自己追加（ \\0 被覆盖 ） 模拟实现strcat\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;assert.h\u0026gt; char* my_strcat(char* dest, const char* src) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); while (*dest != \u0026#39;\\0\u0026#39;)//找\\0 { dest++; } while (*dest++ = *src++) { ; } return ret; } 1.找到目标字符串中 \\0 的地址并存一份\n2.找到源字符串的起始地址和结束地址（包含\\0）\n3.源字符串的起始字符拷贝时，要覆盖目标字符串中的\\0\n源字符串起始字符之后的字符依次拷贝到目标字符串的结尾处\n当拷贝完\\0后就停止拷贝\n4.返回目标空间的起始地址\n3. strcmp字符串比较函数 strcmp函数的介绍\n1 int strcmp ( const char * str1, const char * str2 ); strcmp是字符串比较函数，用来比较两字符串对应位置上字符的大小\n如果第一个字符串对应位置上的字符大于第二个字符串对应位置上的字符，那么返回的是大于0的数字 如果第一个字符串对应位置上的字符小于第二个字符串对应位置上的字符，那么返回的是小于0的数字 如果第一个字符串对应位置上的字符等于第二个字符串对应位置上的字符，那么返回0 注意：两字符串不能被修改\n模拟实现strcmp，更符合VS的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;assert.h\u0026gt; int my_strcmp(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2); while (*str1 == *str2)//对应字符相等的情况 { if (*str1 == \u0026#39;\\0\u0026#39;)//两字符串相等 { return 0; } str1++; str2++; } //对应字符不相等的情况 if (*str1 \u0026gt; *str2)//大于 { return 1; } else//小于 { return -1; } } 模拟实现strcmp，更符合C语言标准的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;assert.h\u0026gt; int my_strcmp(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2); while (*str1 == *str2)//对应字符相等的情况 { if (*str1 == \u0026#39;\\0\u0026#39;)//两字符串相等 { return 0; } str1++; str2++; } //对应字符不相等的情况 return (*str1 - *str2); } 思路如下：\n1.找到两个字符串的起始地址\n2.从两字符串的起始字符开始比较，比较的结果有三种情况：相等，大于和小于\n（1）如果对应字符相等，那么就继续看这两个字符是否为\\0，如果是，那么两字符串相等，\n​ 如果不是，那么就继续往后比较\n（2）如果对应字符不相等，那么就看两字符相减的结果是否大于0，\n​ 如果结果大于0，那么就说明第一个字符串大于第二个字符串，\n​ 如果结果小于0，那么就说明第一个字符串小于第二个字符串\n三.长度受限制的字符串函数 长度受限制的字符串函数可以指定要操作的字符个数，比如strncpy函数可以指定拷贝源字符串中多少个字符到目标字符串中，而不是一定要找到 \\0 才停止拷贝\n1. strncpy strncpy函数的介绍\n1 char * strncpy ( char * destination, const char * source, size_t num ); strncpy函数可以指定拷贝源字符串中多少个字符到目标字符串中\n不追加 \\0 但是如果指定拷贝源字符串的字符个数如果大于源字符串的长度，那么超出的部分就在目标字符串后面补 \\0 使用该函数要保证目标空间能容纳拷贝后的字符串和目标字符串可修改 strncpy的使用\n1 2 3 4 char arr1[10] = \u0026#34;abcdefgh\u0026#34;; char arr2[] = \u0026#34;hello\u0026#34;; strncpy(arr1, arr2, 5); printf(\u0026#34;%s\\n\u0026#34;, arr1);//输出hellofgh 模拟实现strncpy\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;assert.h\u0026gt; char* my_strncpy(char* dest, const char* src, size_t num) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); //拷贝src中的字符串到dest指向的空间 while (num \u0026amp;\u0026amp; (*dest++ = *src++)) { num--; } //提前遇到源字符串中的\\0 if (num) { while (--num) { *dest++ = \u0026#39;\\0\u0026#39;;//超出的长度用\\0来补 } } return ret;//返回目标空间的起始地址 } 2. strncat strncat函数的介绍\n1 char * strncat ( char * destination, const char * source, size_t num ); strncat函数可以指定追加源字符串的多少个字符到目标字符串的结束位置\n追加完指定个数的字符后，会自动在目标字符串后面再追加一个\\0 可以实现自己给自己追加 使用该函数要保证目标空间能容纳拷贝后的字符串和目标字符串可修改 strncat的使用\n1 2 3 4 char arr1[20] = \u0026#34;hello \u0026#34;; char arr2[] = \u0026#34;world\u0026#34;; strncat(arr1, arr2, 3); printf(\u0026#34;%s\\n\u0026#34;, arr1);//输出hello wor 模拟实现strncat\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;assert.h\u0026gt; char* my_strncat(char* dest, const char* src, size_t num) { char* ret = dest; assert(dest \u0026amp;\u0026amp; src); while (*dest != \u0026#39;\\0\u0026#39;)//找目标字符串的\\0 { dest++; } while (num --) { if ((*dest++ = *src++) == 0) { return ret; } } *dest = \u0026#39;\\0\u0026#39;; return ret; } 3. strncmp strncmp函数的介绍\n1 int strncmp ( const char * str1, const char * str2, size_t num ); strncmp函数，可以指定要比较的字符个数\n如果指定的字符个数大于源字符串的长度，那么就用 \\0 和目标字符串的对应字符相比较\n如果两字符都比较完了，但还没到指定的比较次数\nstrncmp的使用\n1 2 3 4 const char* p1 = \u0026#34;abcdef\u0026#34;; char* p2 = \u0026#34;abckjy\u0026#34;; int ret = strncmp(p1, p2, 4);//比较前4个字符 printf(\u0026#34;%d\\n\u0026#34;, ret);//输出小于0的数 模拟实现strncmp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;assert.h\u0026gt; int my_strncmp(const char* str1, const char* str2, size_t num) { assert(str1 \u0026amp;\u0026amp; str2); while (num--) { if (*str1++ != *str2++) { return (*str1 - *str2);//两字符串字符不相等 } //比较的字符个数大于两字符串的长度 else if (*(str1 - 1) == \u0026#39;\\0\u0026#39;) { return 0;//两字符串相等 } } return 0;//两字符串相等 } 四.字符串查找 1.strstr strstr的介绍\n1 const char * strstr ( const char * str1, const char * str2 ); strstr是用来查找目标字符串中是否存在子串的函数，\n若查找到，则返回目标字符串中第一次出现子串的起始地址，若未查找到，则返回空指针\nstrstr函数的使用\n1 2 3 4 5 6 7 8 9 10 11 char* p1 = \u0026#34;hello world hello world\u0026#34;; char* p2 = \u0026#34;world\u0026#34;; char* ret = strstr(p1, p2); if (ret == NULL) { printf(\u0026#34;子串不存在\\n\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, ret);//输出world hello world } 模拟实现strstr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;assert.h\u0026gt; char* my_strstr(const char* str1, const char* str2) { assert(str1 \u0026amp;\u0026amp; str2);//保证不为野指针 if (*str2 == NULL)//要查找的为空字符串 { return str1;//规定返回str1 } //查找的逻辑 char* s1 = str1; char* s2 = str2; char* cur = str1;//记录有可能匹配成功的地址 while (*cur) { s1 = cur; s2 = str2; while ((*s1 == *s2) \u0026amp;\u0026amp; (*s1 != \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (*s2 != \u0026#39;\\0\u0026#39;)) { s1++; s2++; } if (*s2 == \u0026#39;\\0\u0026#39;) { return cur;//找到子串 } cur++;//未匹配成功，尝试从下一个位置匹配 } return NULL;//找不到子串 } str函数查找部分的思路\n(str1 指向目标字符串的起始地址，str2指向子字符串的起始地址)\n\\1. 创建两个新的字符指针s1和s2分别存放str1 和str2\n\\2. 再创建一个字符指针cur，用于记录有可能匹配成功的地址\n\\3. 将cur 赋给s1，让s1向后查找，看当两字符串的对应字符是否相等\n如果相等，就让两字符串依次向后比较字符（str1++，str2++） 如果在比较的过程中发现两字符串有一个字符不相等那么退出本次查找，下一次则从记录位置的下一个位置开始查找（cur++）\n如果比较过程中发现 *s2 等于 \\0（找到子串），或 *s1 等于\\0（没找到 / 找到），则停止查找，再判断 *s2 是否等于 \\0，如果是 ，则返回 cur 存的第一次出现子串的起始地址\n如果不相等，那么说明本次未匹配成功，需要尝试从下一个位置匹配（cur++） \\4. 当发现 *cur 等于 \\0 时，说明未查找到子串，就停止查找，并返回NULL\n五.错误信息报告 1. strerror strerror 函数的介绍\n1 char * strerror ( int errnum ); 当我们在使用C语言标准库中的函数的时候，如果这些函数出错了，那么就会返回错误码，strerror函数可以将错误码对应的错误信息（字符串）的起始地址返回\nerrno 是记录当前错误码的全局变量 这些错误码一般是放在errno.h这个头文件中说明的 只适用于库函数出错时 编辑\nstrerror函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;errno.h\u0026gt; int main() { //fopen 打开文件 FILE* pf = fopen(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;);//\u0026#34;r\u0026#34;-以读文件形式，打开文件 if (pf == NULL)//如果这个文件不存在，就打开失败，返回空指针 { //只适用于库函数 printf(\u0026#34;打开文件失败，原因是：%s\u0026#34;, strerror(errno)); return 1; } else { printf(\u0026#34;打开文件成功\u0026#34;); //... fclose(pf);//关闭文件 pf = NULL; } return 0; } 2.perror 1 void perror ( const char * str ); perror函数是将 errno 中错误码对应的错误信息打印\n先打印str指向的字符串，打印冒号，再打印一个空格，再打印错误码对应的错误信息\n例如：\n编辑\nstrerror 和perror 的区别： strerror 只是拿到错误码对应错误信息的字符串的地址，而perror是直接将错误码对应的错误信息打印\n六.字符函数 1.字符分类函数 字符分类函数是C标准库中的一组函数，用于对字符进行分类和判断。这些函数返回值为真或假，通常以整数0或 非0表示。\n编辑\n空白字符： 空格\u0026rsquo; \u0026lsquo;，换页 \u0026lsquo;\\f\u0026rsquo; , 换行 \u0026lsquo;\\n\u0026rsquo; , 回车 \u0026lsquo;\\r\u0026rsquo; , 垂直制表符 \u0026lsquo;\\v\u0026rsquo; 等\n数字字符：\u0026lsquo;0\u0026rsquo; ~ \u0026lsquo;9\u0026rsquo; 的字符\n控制字符：控制文本显示或者通信流程的特殊字符，比如：回车 \u0026lsquo;\\r\u0026rsquo;, 制表符\u0026rsquo;\\t\u0026rsquo; , 换页 \u0026lsquo;\\f\u0026rsquo; 等\n十六进制的字符：包括所有十进制的数字字符，字母 af , AF\n1.1 islower函数 ：判断是否为小写字母\n1 int islower ( int c ); 函数的使用\n1 2 3 4 5 int ret = islower(\u0026#39;A\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, ret);//0 int retu = islower(\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, retu);//非0 函数的应用：写一个代码，将一个字符串中的小写字母转大写，其它字符不变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;ctype.h\u0026gt; int main() { char arr[] = \u0026#34;I am a Student.\u0026#34;; int i = 0; while (arr[i] != \u0026#39;\\0\u0026#39;) { if (islower(arr[i])) { arr[i] -= 32; } i++; } printf(\u0026#34;%s\\n\u0026#34;, arr);//输出 I AM A STUDENT. return 0; } **1.2 isdigit函数：**判断是否为数字字符\n1 int isdigit ( int c ); 函数的使用\n1 2 int ret = isdigit(\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;, ret);//0 2.字符转换函数 2.1 toupper 小写转大写函数 1 int toupper ( int c ); 函数的使用\n1 2 char ch = toupper(\u0026#39;a\u0026#39;); printf(\u0026#34;%c\\n\u0026#34;, ch);//A 2.2tolower 大写转小写函数 1 int tolower ( int c ); 函数的使用\n1 2 char ch = tolower(\u0026#39;A\u0026#39;); printf(\u0026#34;%c\\n\u0026#34;, ch);//a ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/c-char-and-string-function/04_hu_fe9626df7516d3fb.png","permalink":"https://Amarantos-Arrebol.github.io/p/c-char-and-string-function/","title":"【C语言基础】字符和字符串函数"},{"content":"一、Linux初识 1、历史 1.1 计算机的历史 时代背景\n1946年2月14号 \u0026ndash; 埃尼阿克 计算机导弹的弹轨迹的（军工） \u0026mdash;\u0026gt; 民用领域 \u0026mdash; \u0026gt; 诞生大量的企业（IBM、苹果、Intel等） ​ \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;把赚的钱投入到\u0026mdash;\u0026mdash;\u0026mdash;-【硅谷模式】\n计算机发展\n硬件方面（早期计算机体积大，价格贵） 大型计算机。IBM 小型化，桌面化发展。苹果，微软，intel等 \u0026mdash;-\u0026gt;智能手机 \u0026mdash;-\u0026gt;现在 软件方面 操作系统 1.2 操作系统的历史 诞生的背景\n随着计算机越来越复杂，在上面并行跑的任务越来越多\n所以必须让操作系统可以自动化地处理各种各样的任务\n同时计算机不仅仅可以做计算任务，还可以做数据保存等更复杂的任务\n这个时候就必须要求有新的一套系统，能把文件进行保存\n计算机在发展的过程中，各种任务都在跑，都要消耗内存\n所以必须把内存管理起来\n后来也必须外接各种硬件设备，比如话筒，键盘，显示器，鼠标，摄像头，外设等\n操作系统的发展\nUnix Ken Thompson用汇编语言编写Unix Dennis Ritchie 发明了C语言 他们两使用C语言重构Unix macOS ，windows+intel 计算机+操作系统 进入校园\n1991年，Linus Torvalds参加GUN计划，贡献Linux的Kernel内核 Linux的含义：Linux Is Not Unix 2、引入Linux 2.1 Linux特点 开源\n源代码是公开的，获取Linux源码\n评价一款操作系统好：稳定的，安全的，高效的\n开源vs闭源\n开源\u0026ndash;\u0026gt;被更多人看到\u0026ndash;\u0026gt;问题就能被更多人发现\u0026ndash;\u0026gt;解决问题，并且人和人之间没有利益冲突\n因此，开源的项目 稳定性，安全性，高效性都更高一些\n闭源\n解决问题效率低，解决方案不一定优质\n命令行+图形界面\n2.2应用场景 企业\n嵌入式\n计算或存储平台\n设备手机，平板，智能电视\n车载系统\n2.3版本 技术线\nLinux内核的版本 2.6.32 5.10.xx 3.10.xx\n主版本号.次版本号.修正次数\n次版本号为偶数：稳定发布版 次版本为奇数：测试版\n商业产品线\nubuntu，centos，debian，redhat，fedora等 2.4 安装问题 双系统（不推荐）\n安装虚拟机\n云服务器\n推荐 云服务器 或者 轻量级应用服务器\ncentos7.6/ 7.8/7.9\n安装云服务器的细节\n记住你的公网IP 地方：就近原则 root重置密码 3、XShell基本操作 XShell是一款可以远程登录云服务器的软件\na. 怎么登录？xshell ssh root@你的公网IP，然后会弹出对话框点接受，然后输密码\n输入uname -r 能看到对应的Linux版本号，就装好了\nb. 进入全屏 alt+enter全屏，重复该快捷键退出全屏\nc. 新建用户 \u0026ndash; 云服务器的其它办法 Linux是一款多用户操作系统\n[root@bite-alicloud ~]# adduser zhangsan 新建一个用户\n[root@bite-alicloud ~]# passwd zhangsan 给新建的用户设置密码(不会显示)\n[root@bite-alicloud ~]# userdel -r zhangsan 删除用户\nd. 查看 Linux 主机 ip 在终端下敲 ifconfig 指令, 查看到 ip 地址.\ne. 使用 XShell 登陆主机 在 XShell 终端下敲 ssh [ip]\nf. XShell 下的复制粘贴 复制: ctrl + insert (有些同学的 insert 需要配合 fn 来按)\n粘贴: shift + insert\n4、(穿插)Linux用户管理，见一见Linux能干什么 LInux可以用指令完成各种任务\n查进程、文本过滤、写C/C++代码\u0026hellip;\n可以在windows当中，用我们自己写的程序，以Linux作为服务器，把我们的数据\n直接推送给Linux\n用window的cmd也可以远程登录Liunx\n输入ssh root@你的公网IP回车，要输密码\n手机下一个登录终端的软件就也可以登Linux\nlogout退出登录\n二、Linux基础指令 1、指令 1.1 快速6~7个指令 pwd 直接查看当前用户在首次登录时，在Linux系统，默认所处的路径\nwhoami\n查看当前Linux所使用的用户是谁（账号名称）\nmkdir 加目录/文件夹名称\nmkdir 创建一个目录/文件夹，例如：创建一个目录/文件夹名字叫114\nls\nls 显示当前路径下，文件名称\nrm -rf 加目录/文件夹名\n删除文件夹 rm就是remove的意思，r是递归的首字母，f是force强制的首字母\ncd 目录名\ncd 进入一个目录里面\ntouch 文件名.文件后缀名\ntouch新建一个文件\nrm 文件名.文件后缀名\nrm 删除文件，rm就是remove的意思\n按下回车后，会问我们是否要移除文件，输入y或者n\n以输入y为例：\nmv改文件名\nmv test.c code.c\n表示将文件名test.c改为code.c\n1.2 详细学习一个一个的指令 1. ls指令 ls 显示当前路径下，文件名称。pwd 查看当前路径\n当前路径下，默认是空的，我们可以使用touch创建一个文件\n还可以使用 mkdir 创建一个目录/文件\nls 可以理解成list的意思，默认显示当前路径下的所有普通文件和子目录\n普通文件\n目录文件\nls 查看文件的文件名，文件名不是文件的内容，是文件的属性\nls -l 显示当前目录下，更详细的文件属性信息\nls -a 显示隐藏文件\nLinux中的选项是可以组合传入的，也可以分开传入\nls -l -a 效果和 ls -la 还有 ls -al 相同\na可以理解成all的意思\nLinux中，以点.开头的目录/文件就是隐藏文件\n默认我们直接ls 或ls -l 是无法显示隐藏文件的，但如果我们带上a也就是 ls -al 就可以显示隐藏文件了\n我们自己也可以创建隐藏目录/文件，只要文件名以点.开头就行了。\n例如 touch .readme.txt 和 mkdir .youcanseeme\nls / 查看根目录下的文件\nls /root 指定查看root目录下的文件\nls -ld /root 查root这个目录本身，而不是进入到这个目录，把这个目录里面的内容查出来\n**ls -ld ** 查看目录本身\n2. pwd指令 可以理解成 process work directory，表示当前用户所处的路径\n在windows中也是以路径的方式来标识的\nwindows中反斜杠\\ ， Linux中的斜杠/叫路径分隔符\n两个路径分隔符之间的，一定是一个目录/文件夹 末端文件也可能是一个目录或者是普通文件 最开始的/或\\叫根目录\n特定用户的家目录\nroot用户下：\n普通用户下：\nLinux是一款多用户操作系统，可以创建多个用户，我们新建的用户都在home目录下\nhome目录：保存用户私有信息的目录，默认登录的时候，所处的路径\n我们可以查看有多少普通用户ls /home\n3. cd指令 cd / 切换到根目录\ncd /root/114 切换到114目录下\ncd.. 回退到上一级\ncd ~ 直接进入指定用户的所对应的家目录\nroot用户的家目录就是/root\n普通用户的家目录就是/home/用户名\ncd - 切换到最近的一次路径\n4. touch指令 touch最常用的两个功能：更改时间，创建文件\ntouch 一个文件名后，这个文件的时间就改变了，也就是时间更新了\nstat 文件名可以查看一个文件的详细信息\nACM时间\nAccess（访问时间）、Modify（修改时间）和 Change（改变时间）。\ntouch code(1..100).c 创建100个文件，code1.c code2.c \u0026hellip;. code100.c\n5. mkdir指令 mkdir可以理解成make directory\nmkdir默认只能创建一个空目录/文件夹，不支持一次创建一个路径\n创建一个路径的方法：\n方法一：mkdir创建一个文件，然后cd进去，再mkdir\n方法二：mkdir -p a/b/c/d表示创建一个路径a/b/c/d\n6. rmdir指令 \u0026amp;\u0026amp; rm指令 rmdir 指定目录 删除指定的空目录\n那我们应该如何删除不为空的目录呢？\nLinux中的目录结构是多叉树结构，并且Linux中所有的目录结构是递归式定义的\n所以我们删除的指令要带上r，r就是递归的意思 。rm -r\n但是在root用户下，我们删除目录它会一直问我们是否要删除\n如果我们希望强制删除，就还要带上f，f就是force强制的意思\nrm -rf\n如何删除指定的文件呢？\nrm 文件名\n我们发现它也要问我们是否删除，所以我们同样可以加上f选项来强制删除该文件\nrm -f 文件名\nrm -rf /\n删除整个系统，可以在云服务器上重装\nrm * -rf 删除当前目录下的所有\nrm test{1..100}.o删除多个文件时\n7. man指令 man ls查 ls 指令的使用，q 退出\nman pwd man touch man rm man printf等\nprintf是linux的指令\nman 3 printfman指令还可以查C语言相关的接口\nq退出\n上下键翻页\n/return val 回车，定位到函数返回值的说明\nman 2 fork查系统调用的接口\nman依次按照这9个章节来查，哪一个先查的，就不往后查了\n其中1号为默认手册，查的是可执行程序或命令行的命令\n2号手册查的是系统调用（由内核提供的函数）\n3号手册是查函数调用，一般提供的程序的库\n安装man\nyum install -y man-pages\n8. cp指令-拷贝 拷贝文件 cp src dst\ncp 要拷贝的文件 拷贝到哪里\n拷贝目录cp -rf src_dir dst_dir\n如果要拷贝目录，目录是递归的，所以要使用 r ，同时要拷贝的目录及其子文件，有可能在目标路径下已经存在了，所以我们加上 f 强制删除\n拷贝到的路径指定了新的名称cp src dst_dir/新的名称\n如果拷贝到的路径如果指定了新的名称，那么就会创建\n9. mv指令-剪切/重命名 mv src dst_dir移动文件\nmv指令可以用来移动文件，或给文件重命名。mv就是move\n指令举例 含义 将log.txt移动到上级目录 将test.c重命名为code.c 把code.c移动到上级目录，并改名为myyyycode.c 10. 查看文件的内容 cat指令-查看小文件 打印文件的内容 cat 文件名.文件后缀\ncat -n 文件名.后缀打印时带上行号\ncat -n -s 文件名.后缀名 -s 表示不输出多行空行（合并空行），\n如果文件内容中有连续的多个空行，那么就会把它压缩成一行\ntac指令 tac -n 文件名.文件后缀 将文本内容反向输出\n总结\ncat正向打印，tac反向打印\n作用\n将Linux当中的一些小文件/.c/.cpp/.conf 打印出来，方便用户查看\nmore指令-查看大文件 cat指令比较适合查看较小的文件，原因是如果一个文件里的内容很多，使用cat就会刷屏。\nmore指令more 选项 文件.后缀打印满屏幕后，就不再继续往下显示，如果想看下一行就回车\n**缺点：**more命令无法上下翻页，只能回车往下翻\nless指令 - 【推荐】可以用来查日志 less 选项 文件.后缀\nless指令可以使用上下光标实现上翻和下翻\n总结\nless指令可以查看文本，上下翻，q退出，/ 搜索，n查看下一个匹配项\nhead指令-查看指定行数的内容 head -n 文件名.后缀名显示文件指定行数的内容，从开头开始\n默认显示前10行，可以自己指定数字来代替n\ntail指令 tail -n 文件名.后缀名显示文件尾部指定行的内容\n默认显示后10行数据\n如何查看大文件任意区间的文本内容 例如取行数在[2000,2020]之间的内容\n**方式一：**通过临时文件\n1 2 head -2020 log.txt \u0026gt; temp 拿到前2020行的内容，放到临时文件 tail -21 temp 取临时文件的后20行数据 **方式二：**利用管道\n使用管道，前一个指令的结果通过管道给另一个指令作为输入\n先取该文件的前2020行，把它作为输入，交给tail取后20行\n还可以将得到的内容逆向打印 ，还可以统计字符数wc(word count) ，l 是line\n表示按行统计\n1 head -2020 log.txt | tail -21 | tac | wc -l wc单词计数 在 Linux 中，wc 是 \u0026ldquo;word count\u0026rdquo;（单词计数）的缩写，是一个用于统计文本内容的命令行工具。它可以统计文件（或输入流）中的行数、单词数、字节数等信息\nwc 命令的常用选项：\n-l：仅统计行数（line count） -w：仅统计单词数（word count） -c：仅统计字节数（byte count） 如果不指定选项，默认会同时输出 行数、单词数、字节数 和文件名（如果输入是文件）。 11. 时间相关的指令 date 需求 指令 如果我们只想查看年 可以查看年和月，中间的-也可用其它符号 查看年月日 查看年月日时分秒 如果想在年月日后是空格然后时分秒，可以使用反斜杠转义字符再加空格\n除了月和日是小写，其它都是大写\n后面会学的\n时间戳 1970-1-1凌晨12:00累计到现在的秒数\nCal指令 cal显示日历\ncal -3显示前一个月，当前月和下一个月\ncal -y 年份显示指定年份的日历\ncal -j显示在当年中的第几天\n12. find命令【重要】 find查文件 find 目录 -name 文件在指定目录找名为XX的文件\nfind 目录 -name '*.c'表示找以.c结尾的文件\nfind ~ -name '*.txt'在当前目录下找以.txt结尾的文件\n-name表示按名字查\n*叫通配符\nfind也可以查指令\nfind /usr/bin/ -name ls\nfind /usr/bin/ -name pwd\nwhich和find指令的区别 find系统目录树直接查找，可以查任意文件（可以按照文件名，权限，文件大小等）\n所以可能会比较慢\nwhich只能用来查可执行程序，相当于限定在/usr/bin/路径下\nwhich命令相当于 find /usr/bin -name XXX\nwhereis指令 whereis指令不仅可以查到指令的路径，还会将普通文件的路径查出来\n13. grep指令-行文本进行过滤 grep 按照指定的模式对行文本进行过滤\ngrep '999' log.txt将log.txt中包含999的显示\ngrep \u0026quot;main\u0026quot; ./*同时grep指令也支持通配符，表示在当前路径下找\n常用的选项\n-n显示行号\ngrep -n \u0026quot;main\u0026quot; *.c将文件中包含main的，后缀为.c的显示，并带上行号\n-v反向匹配\ngrep -v \u0026quot;main\u0026quot; oper_tty.c将oper_tty.c中包含main的不显示\n-i 忽略大小写\ngrep -i \u0026quot;main\u0026quot; oper_tty.c将oper_tty中包含main的无论大小写都显示（i是ignore的简写）\ngrep还可以查进程\n例如：ps ajx | grep corond查名字中含有corond的进程\n14.打包压缩 安装\nyum install -y zip\napt install -y zip\n14.1 打包压缩是什么 ​\t使用特定的算法，文件进行合并或者压缩，减少体积，\n​\t打包压缩作为一个整体\n14.2 为什么要打包压缩 ​\ta.文件体积减少，节省资源，磁盘空间，减少网络传输的成本 \u0026ndash; 压缩\n​\tb.多个文件转一个文件，可以提高文件传输的 容错性\n14.3 怎么打包压缩 zip/unzip 压缩的常用格式：.zip，.tgz\n打包压缩目录：zip -r test.zip test将test目录打包压缩为test.zip 打包压缩普通文件zip 文件名.zip 要压缩的文件 解压目录：unzip 文件名.zip 默认是解压到当前路径的，如果我们要解压到指定路径（-d）\nunzip test.zip -d ../lesson3表示将test.zip解压到上级路径的lesson3中\n14.4 实现windows和Linux机器互传 先要安装lrsz：yum install -y lrzsz\n发送到windows 指令sz test.zip表示将test.zip发送到我们的windows机器上\n会弹出叫我们选择路径，即你想把该文件放到windows哪个路径下\nLinux机器接收windows的文件，rz\n也可以直接将windows中的文件拖拽到Xshell中\n14.5实现Linux和Linux机器之间互传 scp test.tgz root@公网IP:路径\nscp远程拷贝\n15. tar指令 还有一种压缩文件.tar.gz\n打包压缩\ntar -czf 目标文件名.tgz 源文件名\nc表示create创建一个文件，z表示要进行压缩，f表示f后面紧跟的就是目标文件\n例如：tar -czf test.tgz test\n此外，-v选项会将打包压缩的过程显示：tar -cvzf test.tgz test\n解压\ntar -xzf test.tgz\nx是解压缩包的意思，z表示解压的的意思\n其它\n展现打包压缩的过程：-cvzf\n展示解包解压过程：-xvzf\n解压解包到指定路径下：tar -xvzf XXX.tgz -C 指定路径\nLinux和Linux机器之间互传\nscp test.tgz dyy@139.9.80.106:/home/dyy/114/lesson4/tar_test\nscp 远程拷贝 test.tgz 当前机器上的压缩文件 dyy@ 表示另一台机器的身份 139.9.80.106 另一台Linux机器的IP地址 :/home/dyy/114/lesson4/tar_test 表示拷贝到另一台机器上的哪个路径下 16.bc指令 bc是Linux下的一个命令行计算器，在bc命令下可以进行浮点数运算\nquit或ctrl+c退出\n应用场景：表达式是不能直接写入到显示器中的，而使用bc就可以\necho 1+2+3+4*8/9%10 | bc\n17. uname指令 uname -a查看当前Linux机器的所有详细信息\n内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称\nuname -r只查看内核版本和体系结构\nCentOS查看当前机器版本 cat /ect/redhat-release\nUbuntu的查看cat /etc/lsb*\n18. 重要热键 tab键，进行命令或路径的补齐 ctrl+c停止异常操作 上下键，可以翻阅历史命令 ctrl+r搜索历史命令，再按左右键就能得到该命令 Linux会记录历史命令\nhistory查看历史输过的指令\n19.关机 语法：shutdown 选项\n-h：将系统的服务停掉后，立即关机\n-r：在将系统的服务停掉之后就重新启动\n-t sec ：-t后面加秒数，即过XX秒后关机\n重启：reboot再回车\n2、基础知识 2.1 命令行 我们在命令行中执行命令时，可以单纯地执行一条指令，也可以指令+选项的形式\n来展示更多的功能 -+-+-+-+-+-+\n例如：\n再比如windows中的关机命令 shutdown -t -s 60 表示60秒后关机\n2.2 文件不等于文件的内容 文件不仅仅包含文件的内容。\n还包含文件名、文件的类型、文件的大小、文件的保存位置文件的修改时间，文件的修改权限等，这些都叫做文件的属性\n文件的属性也是数据。\n我们保存文件，不仅要将它文件的内容存储到内存中，也要将它文件的属性存储到计算机的磁盘中\n在新建文件时，只要是数据，就要被保存起来\n所以，即使我们新建了一个空的文件，它的大小为0，指的是文件的内容是空的，\n但是不代表它所占磁盘空间的大小为0\n对文件的操作：\n​\t**a.对文件内容的操作 **\n​\tb.对文件属性的操作\n2.3 隐藏文件 ==Linux中，以点.开头的目录/文件就是隐藏文件==\n默认我们直接ls 或ls -l 是无法显示隐藏文件的，但如果我们带上a也就是 ls -al 就可以显示隐藏文件了\n我们自己也可以创建隐藏目录/文件，只要文件名以点.开头就行了。\n例如： touch .readme.txt 和 mkdir .youcanseeme\n2.4 普通文件和目录文件 1. 目录在电脑里面相当于文件夹 windows中反斜杠\\ ， Linux中的斜杠/叫路径分隔符\n两个路径分隔符之间的，一定是一个目录/文件夹\n末端文件也可能是一个目录或者是普通文件\n2.Linux中以d开头的叫目录，以-开头的叫普通文件 文本文件，二进制可执行程序，动静态库，视频，音频，图片\u0026hellip;等都叫普通文件\nLiunx系统中，文件类型与文件后缀无关。系统不等于gcc（软件），建议带上后缀\nfile 跟文件名 识别到准确的文件类型\n.和..都是目录 ..表示上一级路径，.表示当前路径 根目录的.和..都指向自己 cd ..表示切换到上一级\ncd 目录/文件名进入一个路径\ncd 跟一个完整的路径可以直接切换到该目录下\n例如：cd /root/114 表示切换到root路径下的114目录下\n3.根目录 我们可以使用cd ..回退到上一级，但也是不能无限回退的，但当我们一直回退到不能再回退时，发现此时我们是在/或\\路径下。\n==最开始的/或\\目录叫根目录==\nLinux的所有文件的系统结构是一个多叉树结构。\n它的非叶子结点一定是一个一个的目录，而它的叶子结点要么是空目录要么是普通文件\n访问一个文件\n前提：找到它（定位或找到任何一个文件的方式是通过路径），操作它\n路径具有唯一性（多叉树结构，每个子结点只有一个父节点，可以有多个子节点）\n**绝对路径：**从根目录开始定位文件的路径\n**相对路径：**以相对于我自己的当前路径为参照点，查找定位目标的路径\n如何选择？\n操作中一般使用：相对路径\n配置文件，系统级配置文件，可以采用绝对路径\n4、在任何一个目录中都有.和.. 无论是自己新建的目录还是系统自带的目录，里面都有.和..\n.和..都是目录 ..表示指向上一级的路径，.表示相当于指向自己的路径 根目录的..和.都指向自己 执行一个C程序：\n把一个程序运行起来，前提是先把文件添加到内存，而添加到内存之前要先找到它\n而我们默认，即便在当前路径下，我们也找不到它，所以我们./a.out\n因为.表示当前路径，所以./a.out意思就是执行当前路径下的 a.out\n除了这种方式外，我们还可以通过决对路径来执行程序。例如：/root/114/a.out\n2.5 tree命令 tree+指定目录，以树形结构，展示文件和目录结构\ntree 指定目录\ntree . 当前路径\ntree /从根目录开始，所有的Linux文件全部整理出来\n命令行中，阻止非法或者刷屏操作，ctrl+c\nLinux中tree命令默认是没有安装的，需要我们自己安装\nroot用户下\nCentOS输入：yum install -y tree\nUbuntu输入：apt install -y tree\n卸载：yum remove -y tree\n2.6 cp指令 Linux下，一切皆文件 \u0026mdash;\u0026ndash; 显示器就是文件\n打印到显示器-\u0026gt;显示器也是文件-\u0026gt;写入到显示器文件 从键盘读取数据-\u0026gt;键盘也是文件-\u0026gt;从键盘文件读取数据 2.6.1向文件中写入数据 echo指令\necho指令可以将跟在echo后的内容当做字符串写入到显示器文件当中\n可以将echo后的内容用单引号或双引号括起来\n使用cat 文件名（包含后缀）就可以查看文件里的内容\necho 默认是向显示器文件写入，如果带上\u0026gt;就会向指定文件写入 -\u0026gt;重定向操作\n如果文件不存在，就新建。重定向操会将文件先清空再写入\n==\u0026gt;是输出重定向操作==\necho \u0026lsquo;内容\u0026rsquo; \u0026gt; 文件名.后缀名 ，那么就会向指定文件写入，如果文件不存在，就新建\n如果文件存在，就先将里面的内容清空，然后再写入\n如果直接\u0026gt;加文件名（带后缀名）\n\u0026gt;可以将文件里的内容清空 文件不存在，\u0026gt;可以新建文件 ls写入\nls默认也是向显示器文件写入\n我们也可以使用\u0026gt;将其在其它文件中写入\n例如：ls -l \u0026gt; log.txt 就是把当前目录下文件的详细信息写入到log.txt文件中\n==\u0026gt;\u0026gt;追加重定向操作==\necho \u0026quot;要写入的内容\u0026quot; \u0026gt;\u0026gt; 文件名（带后缀的）就可以不清空就写入\n向指定的目标文件中，不断新增内容\n2.6.2向文件中读取数据 cat后面什么都不跟，默认从键盘中读，把从键盘中读到的内容打印到显示器上\n输入什么内容，他就打印什么内容，ctrl+c退出\ncat \u0026lt; 文件名.文件后缀 读取文件里的内容 -\u0026gt; ==\u0026lt;输入重定向==\n从log.txt里面读，把读到的内容打印到屏幕上\n2.6.3 终端文件 我们打开Linux，默认会显示一个黑框框，这个黑框框我们把它叫做终端\n终端的本质是一个文件\nls /dev/tty 终端文件\nls /dev/pts 远程登录对应的登录终端\n如果我们再打开一个Linux机器，此时我们在第一个Linux机器中输入ls -l /dev/pts\n就会发现多出了一个叫1的文件，也就是这代表我们新打开的Linux机器\n如果我们在第一个机器中向1中输入数据echo helloworld \u0026gt; /dev/pts/1\n就会发现在新机器中显示出来了\n第一个机器 新机器 我们再向0这个文件中输入，发现0就代表当前这个终端\n我们也可以在新打开的机器中向我们当前的这个机器写入数据\n总结\n我们的登录终端，在我们登录的时候，就会在/dev/pts这个目录下，形成一个以c开头\n文件，我们可以向该文件中写入数据（本质上就是向显示器上写）\nnano \u0026ndash; 文本编辑器\n​\tnano 文件名.文件后缀名就相当于打开了Linux下的记事本\n​\tctrl + x退出\n2.7 指令是什么 2.7.1 指令本质上就是程序 我们平时操作的指令都在 /usr/bin路径下。\nusr就是user用户的意思，bin就是binary二进制的意思\n我们可以只查其中的某个指令\n我们发现指令本质上就是程序\n所以我们既可以直接输入指令（比如 ls），也可以/usr/bin/ls来执行指令\n指令就是Linux特定路径下的二进制文件\n2.7.2 which命令 which命令可以帮我们快速找到指定的命令文件\n2.7.3 alias 对指定的命令和选项组合起别名 我们使用which命令找到 ls ，就会发现它上面多了一行\n如果我们直接执行ls 有些文件是不带颜色的\n如果我们执行/usr/bin/ls --color=auto就会发现选项带颜色了\nalias是别名的意思，我们可以把某些指令取别名，然后用别名操作\n我们既可以用ll也可以用ls的原因就是ll是ls -l的别名\n2.8 日志的介绍 什么是日志？\n在程序正常工作之前，程序员自己需要打开日志文件，在程序运行期间，\n你以前写代码调试时，在代码中所有出现printf的地方，都要让它转而向\n文件里写入，让程序的执行痕迹写到日志里。这个文件就叫日志文件\n这个行为就叫写日志\n日志的基本信息\n报错还是警告，报错的内容是什么，警告的内容是什么，时间\n查看日志\n2.9 时间戳 时间戳是指1970年1月1日凌晨12点到现在的秒数\nC语言中time返回的就是时间戳\n格式化显示时间戳\n@后面跟时间戳\n@0 时显示的是1970-1-1的8点而不是凌晨12点原因是系统里把时区转过来了\n3、shell命令以及运行原理 广义上操作系统是：内核+外壳程序\nLinux严格意义上说的是一个操作系统，我们称之为“核心（kernel）“ ，但我们一般用户，不能直接使用kernel。而是通过kernel的“外壳”程序，也就是所谓的shell，来与kernel沟通\n外壳程序\n外界输入指令 \u0026mdash;\u0026gt; 外壳程序解析 \u0026mdash;如果合法\u0026ndash;\u0026gt; 内核执行\n外界 \u0026lt;\u0026mdash;\u0026mdash; 外壳程序显示 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n这个外壳程序 Linux下叫：命令行解释器\n​\twindows下叫：图像化界面\nshell外壳就是包裹在操作系统外面的一层软件层\n核心工作就是命令行解析和保护内核\nshell会进行创建子进程的方式进行命令解析\n每一个用户在登录时，系统都会为这个用户专门分配一个bash\n外壳程序：ps ajx | grep bash\n三、Linux权限 1. 什么是权限 a.权限是限制人的。人 = 真实的人+身份角色\nb.目标事物的属性也会影响权限\n==权限=角色+事物属性==\n权限最终就是影响你能还是不能做一件事情\n2.认识人，人切换 2.1用户 root：超级管理员，几乎不受权限的约束\n普通用户：Linux使用者，受权限的约束\n2.2切换用户的方式 普通用户切换到管理员用户：su\n需要输入root密码，密码不会显示出来\n退回到普通用户：ctrl+d 或exit\n切换到其它普通用户su 用户名\n以root的身份重新登录su -\n**注意：**普通人之间切换，需要输入对方的密码；root可以切换成为任何人\n2.3如何在不切换身份的情况下，执行更高权限命令呢？(场景) 指令提权\n只要在要执行的指令前加上sudo，就可以以超级用户的身份来执行后续的命令\n输密码时输入普通用户的密码\nsudoers 类似一张用户白名单\n场景\n安装软件时，在Linux下安装软件只能在root身份下安\n3. 文件属性，文件的权限属性，Linux角色划分 3.1 文件属性 字符设备文件：显示器，键盘\n块设备文件：磁盘\n管道文件：分为匿名管道和有名管道（用来进程间通信）\n创建管道文件\n​\t管道文件\n链接文件：\n3.3Linux中的角色划分 Linux中角色分三类\n文件拥有者\n一个文件是谁的，谁就是拥有者\n文件所属组\n如果没有所属组，那么一个文件要么是拥有者，要么是other，我想要让某个人看该文件，，就只能将权限放开至other，那么我不想给某些人看到该文件也不行。\n而有了所属组后，你就可以只让那个组里的人看该文件\nother\n既不是拥有者，也不是所属组\n人 = 真实身份 + 身份角色\n具体用户：root，普通账号\n角色：拥有者，所属组，other\n具体的人可以扮演某种角色\n3.2 文件权限属性 r 可读，w 可写，x 可执行\n4.操作：有权限VS无权限 如何修改权限？ 取消权限\n改为不能读\nchmode u-w 文件 文件不能写\nchmode u-x 文件改为文件不可执行\n增加权限\nchmode u+r 文件改为可读\nchmode u+w 文件改为可写\nchmode u+x 文件改为可执行\n改拥有者权限 u\n改所属组的权限，就将u换成g\n改other的权限，就将u换成o\n给所有人加上某权限，就将u换成a\n结论：\n只有文件的拥有者和root可以修改文件的权限\nLinux下能执行 = 真的是一个可执行文件 + 可执行权限\nuser,group,other和我自己进行身份对比的时候，依次只对比一次\n如果你既是拥有者又是拥有组，那么匹配到拥有者后就不再匹配，也就是就算拥有者没有读或写或可执行而拥有者有，你也是不能读或写的\n使用八进制增加权限 r/- w/- x/- 三个分别为读，写，可执行，-表示没有该权限\n我们可以用0来表示没有该权限，1表示有该权限\n那么可读可写可执行就可以表示为111也就是7\n如果我们要设置拥有者，所属组，other的权限分别为\n​\trwx rw- r\u0026ndash;\n用二进制表示 111 110 100\n也就是 7 6 4\n那么我们就可以用 chmod 764 text.txt 指令修改\n同样，如果我们希望给所有角色加上所有权限：chmod 777 text.txt\n​\t给所有角色去掉所有权限：chmod 000 text.txt\n拥有者和所属组可读可写，other只读 chmod 664 test.txt\n修改角色 修改拥有者chown 新拥有者 要修改的文件不能直接修改拥有者\n只有超级用户或者指定提权\n修改所属组chgrp 新拥有者 要修改的文件\n同时更改拥有者和所属组\n对于一个文件，如果没有r权限，用任何工具都不能查看文件的内容。权限限制的是人\n5.关于权限的三个问题 1.目录权限 如果我要进入一个目录，需要什么权限？x权限\nr对目录是什么意思？有无权限查看指定目录下的文件信息\n![73140979480](assets/1731409794803.png) w对于目录？有无权限在指定目录内部，新建文件，删除，修改文件名等修改=\n文件操作，都不行\n2. 缺省权限 知识点\n普通文件，起始权限666；目录文件，起始权限777\numask的权限掩码\n最终权限（缺省权限）：664,775\n结论：\n==最终权限（默认）= 起始权限 \u0026amp; （~umask）==\n只看后3位，实际是000 000 010\n修改权限掩码，达到修改Linux文件缺省权限的问题\n修改成777umask 777那么此时umask按位取反结果为全0，任何数和0按位与\n结果都为0。那么默认创建的文件权限是全是-\n修改成0umask 0那么此时umask按位取反结果为全1,任何数和1按位与结果都是\n它本身。此时创建文件的默认权限就是666和777\n3.沾滞位 1. Linux多用户下，对于文件的访问，是隔离的\n2. 需求：我们想让Linux下不同的账号用户，共享文件呢？\n共享文件不能在任何一个普通账号的家目录里面，只能在其它目录下，比如根目录下\n但是根目录也是一个目录，所以新建时需要以超级用户身份来创建sudo，或者root用户来新建\n默认下other是没有创建文件的权限的，所以需要sudo添加w\n3. 问题：我们想既共享文件，同时other不能随便删除这个文件\n我们想共享文件，也就是需要让在根目录下建的目录的other的w权限放开，\n这样other就可以在这个共享目录中新建文件了，我们可以修改共享目录文件中新建的文件的属性也就是可以让拥有者和所属组的权限是可读可写可执行，other是不能读不能写不能执行\n但存在一个问题，在目录中，创建删除修改一个文件是由目录的w权限决定的，与目标文件无关，也就是如果我们将共享目录的w权限放开了，那么other就可以删除我们共享目录里的文件了\n添加粘滞位：sudo chmod +t /目录名/\n任何用户，在设置了粘滞位的目录下\na. 自己只能删除自己的目录，其他人无法删除\nb. root无视\nc. 粘滞位，只能给目录设置，不需要给普通文件设置\nLinux下默认给tmp目录加了粘滞位\n0.笔记 1.xshell安装和卸载 1.1安装 https://www.netsarang.com/zh/free-for-home-school/\n点击下载即可\n下载完后，双击.exe文件，一直下一步，改安装路径。\n安装好后，打开XShell，第一次打开需要输用户名和邮箱，然后xshell会往你的邮箱发\n认证链接，点击认证链接后就注册成功了\n关掉其它界面，在下面的界面中输入ssh root@你的公网IP回车后输入你的密码\n1.2卸载 在控制面板中选择卸载程序，然后将xshell卸载即可\n2.xshell免密码登录 首先添加一台机器\n然后会弹出对话框\n查看我们添加的机器\n然后可以点击连接\n第一次要求输入用户名，输入后我们点击记住用户名，然后输密码\n免密码登录\n属性中有一个身份验证，输入用户名和密码点击确定后，以后只需要双击我们的机器就\n可以直接登录我们的机器，不用输密码了\n3. 改主题 a. b.把配色方案勾上\nc.然后再点击下图中的图标就可以改主题了\n4. 新建用户及用新建的用户登录 a.新建用户及删除 [root@bite-alicloud ~]# adduser zhangsan 新建一个用户\n[root@bite-alicloud ~]# passwd zhangsan 给新建的用户设置密码(不会显示)\n[root@bite-alicloud ~]# userdel -r zhangsan 删除用户\nb.怎么登录该用户呢？ 首先，需要把xshell关闭，然后将弹出的对话框点叉\n然后如果是下面这个界面\n那么输入你的用户名@你的公网IP回车然后输入密码可以了\n如果是下面这个界面\n那么就需要输入ssh 你的用户名@你的公网IP\n5. 在xshell查看公网IP 右击我们的Linux机器，选择属性，就可以看到我们的公网IP了\n6.登录的状态下，切换Linux机器 就可以打开下面的界面\nlogout可以退出当前账号，再ssh root@你的公网IP\n7.Linux下安装应用 Linux中tree命令默认是没有安装的，需要我们自己安装\nroot用户下\nCentOS输入：yum install -y tree\nUbuntu输入：apt install -y tree\n卸载：yum remove -y tree\n8.伪造10万行代码 9.向自己新打开的另一台Linux机器中写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; int main() { FILE* fp = fopen(\u0026#34;/dev/pts/1\u0026#34;, \u0026#34;w\u0026#34;); if(fp == NULL) { perror(\u0026#34;fopen\u0026#34;); return 1; } char buffer[1024]; while(1) { printf(\u0026#34;Enter# \u0026#34;); scanf(\u0026#34;%s\u0026#34;, buffer); fputs(buffer, fp); fflush(fp); } fclose(fp); return 0; } 然后编译运行\n就可以写入了（ctrl+c退出）\n对应另一台机器\n10. Linux下的退出 nano text.txt后使用contrl+x退出\nvim test.txt 中使用 esc+:wq 退出\n11.xshell看Linux版本 centos下\ncat /etc/redhat-release\nubuntu下\ncat /etc/lsb*\n12.看Linux的内核版本 uname -r\n13.nano的使用 nano \u0026ndash; 文本编辑器\nnano 文件名.文件后缀名就相当于打开了Linux下的记事本\n退出：ctrl+x，y 回车\n指令 说明 shutdown -h now 立刻进行关机 shudown -h 1 “hello，1分钟后会关机了” shutdown -r now 现在重新启动计算机 halt 关机，作用和上面一样 reboot 现在重新启动计算机 sync 把内存的数据同步到磁盘 14.了解bash脚本 1 2 3 4 5 #!/bin/bash touch file mv file myfile i=100 echo $i 执行：bash test.sh\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/linux-basic-instruction/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_b09e032a367fa6ec.png","permalink":"https://Amarantos-Arrebol.github.io/p/linux-basic-instruction/","title":"【Linux】01初始Linux+基础指令"},{"content":"一、Linux环境基础开发工具使用 1. 软件包管理器 1.1什么是软件包管理器 软件包相当于 app\n软件包管理器相当于应用商店\n我的服务器怎么知道，去哪里找软件包？\nLinux机器上，有对应的给yum/apt提供的配置文件！\n记录下来了对应软件包服务器的url或者ip地址\n是在我们的云服务器或操作系统发布的时候和操作系统一起给我们发布出来的\ncentos、ubuntu\u0026hellip;等操作系统都是国外的人做的\n1.软件包服务器在国外，\n2.配置文件里写的都是国外的云服务器\n镜像\n国内的人将国外的软件包服务器里的内容拷贝到国内的服务器上\n同时再给我们国内的用户提供能下载国内的软件包服务器的配置文件\n软件源\n在我们的云服务器上配置对应的这种配置文件\n我们再把软件源由国外的替换为国内的\n云服务器：首先需要将国外的软件包服务器里的软件拷贝，\n​\t然后将国外的配置文件替换为国内的配置文件\n​\t所以我们使用的时候，内置的配置文件已经是国内的了\n1.2 yum 查软件是否存在\n看在软件包服务器中是否存在 yum list可以罗列出我们当前centos所支持的所有软件\n就是将远端的软件包服务器里有的软件的名称和相关的信息全部拉到本地，\n形成一个清单，让我们看到\n我们利用grep查看该清单名字中包含sl的软件\n.x86_64表示该代码是在64位机器下编译的，只能在64位环境下跑\nel7就是centos7，@epel相当于苹果应用商店、小米应用商店等\n看在我们自己的云服务器上是否存在，which 软件名 sl我的云服务器上已经安装了\n安装软件，需要以管理员的身份（安装软件安装到usr/bin路径下）\n安装软件的本质就是将软件的二进制文件下载，然后拷贝到系统指令的目录下\n所以有权限约束，使用root/sudo yum/apt提权\nLinux下安装的软件，是root安装的，其它人都能用能看\nLinux一般而言，软件只要安装一次，都能用。\n除了root外，其他人都是以other的身份进行使用软件的\n安装gcc:\n1 2 3 4 5 # Centos $ sudo yum install -y lrzsz # Ubuntu $ sudo apt install -y lrzsz 总结:\ncentos下\n以超级用户身份sudo\n查软件是否存在 yum list | grep xxx\n安装 yum install (-y) xxxx\n卸载 yum remove (-y) xxxx\n-y表示强制卸载\nubuntu下\n查看ubuntu的机器：cat /etc/lsb*\napt search sl\nsudo apt install -y sl\nsudo apt remove -y sl\nkillall yum\n1.3 安装源 yum源配置文件所在的路径\n有多个\nubuntu下在ls /etc/apt/sources.list下\nbase是标准源，epel就是扩展软件源，扩展软件源可能不止一个\n安装扩展软件源：\n如何切换软件源？\n本质就是更改配置文件，使用AI提供操作清单\nwget www.baidu.com我们就得到了一个网页，默认是index.html\n我们cat index.html就得到了百度的首页\n好玩的命令：https://blog.csdn.net/xiaoxiaosutang/article/details/141053674\n2. 编辑器vim 2.1 vim的介绍 1.vim是一个专注的编辑器\n2.多模式的编辑器\n2.1.1 见一见vim vim本质上也是一条命令，是在Linux磁盘中特定的文件系统里，/usr/bin/下的一个命令\n我们先用vim来编写一个hello world\n可以先创建一个文件，再用vim打开\n默认打开是命令模式，输入i后可以编辑\n如何退出vim？\n直接输入vim时使用 shift+冒号+q退出，\n写了代码后 shift+冒号+wq，如果是插入模式下需要先按esc 退回到命令模式\n如果你没有做任何修改，只是查看了文件并想退出： 确保你处于命令模式（按 Esc 键可以确保你处于命令模式）。 输入 :q 然后按 Enter 键。这将退出 Vim，且不会保存任何修改。 如果你做了修改并希望保存更改然后退出： 确保你处于命令模式。 输入 :wq 然后按 Enter 键。这将写入（保存）文件并退出 Vim。 或者，你可以先输入 :w 然后按 Enter 键来保存文件，之后输入 :q 再按 Enter 键来退出。 如果你做了修改但不希望保存更改并想退出： 确保你处于命令模式。 输入 :q! 然后按 Enter 键。这将强制退出 Vim，且不保存任何修改。 如果你处于插入模式（正在输入文本），并且想退出： 首先按 Esc 键回到命令模式。 然后按照上述步骤之一退出 Vim。 gcc编译，形成a.out\nb.vim多模式 5模式 3种核心 命令模式\n默认打开vim就是命令模式，在该模式下，vim会把我们从键盘上输入的都当成是命令\n目的：提高编辑效率，vim下yy复制粘贴\n插入模式\n正常的编写模式，还可以复制，粘贴，剪切等\n底行模式\n显示行号，想退出vim，保存\u0026hellip;\nset nu调出行号\nset nonu把行号去掉\nwq退出（w就是write写，q就是退出）\n命令模式切换到插入模式:i\n命令模式切换到底行模式：shift+冒号\n底行模式切换到命令模式：Esc\n插入模式切换到命令模式Esc\n总结：\n默认打开是命令模式 命令模式是vim的核心和精华 光标定位，vim下一般不使用鼠标 2.1.2 命令模式 作用 命令 光标定位到第一行 gg 光标定位到文本末尾行 shift + g = G 光标定位到任意一行 n+gg 、n+shift+g 光标定位到行尾 shift+4/$ 光标定位到行首 shift+6/^ ：h左，l右，j(jump)下，k(king)上 h、j、k、l 以单词为单位，向前或向后移动 n+ w/b 复制光标所在行 yy 复制多少行 n+yy 粘贴到当前行的下一行：p\n粘贴多少行n+p\n==撤销：u==\n==反撤销：ctrl+r==\nn+dd剪切或删除，dd+p就是剪切+粘贴\nn + x/X删除光标后/前的字符\nshift+~快速大小写转换\nn + r小范围文本替换，将n个字符替换为输入的字符\n==shift+r = R进入替换模式==，退出替换模式esc\n在命令模式下退出vimshift+zz\n2.1.3 插入模式 i ：进入插入模式\na：进入插入模式并光标向后移动一个\no：进入插入模式并另起一行\n!xxxx：可以在不退出vim的情况下执行命令\n2.1.4 底行模式 命令模式进入底行模式，shift+冒号\nwq保存并退出，w!强制保存，q!强制退出，wq!强制保存退出\nset nu设置行号，set nonu不显示行号\n/xxx 搜索 xxx ，n搜索下一个匹配项\n!+指令，比如!ls，就可以执行ls命令，然后按任意键回去\n%s/把什么/替换成什么/g 例如：:%s/code/proc/g\nvs xxx可以实现分屏，例如在vim code.c中输入vs code.h就可以实现下面的效果\n注意：光标在哪，编辑、保存等就在哪\nctrl+www光标移动到另一个屏幕\n要查看你的所有模式：打开 vim，底⾏模式直接输⼊ help vim-modes 2.1.5 补充 批量化注释：ctrl+v \u0026ndash;\u0026gt; hjkl选择区域\u0026ndash;\u0026gt;shift+i 输入双斜杠（也可以插入其它的文字）\u0026ndash;\u0026gt;Esc\nctrl+v进入视图模式\nshift+i直接切换到插入模式\n全部注释：gg定位到开头\u0026mdash;\u0026gt;ctrl+v\u0026mdash;-\u0026gt;shift+g定位到结尾\u0026mdash;\u0026gt;shift+i后输入//\u0026mdash;\u0026gt;再Esc\n批量化去注释：ctrl+v\u0026mdash;\u0026gt;hjkl选择区域（要将两个斜杠都选择）\u0026ndash;\u0026gt;d\n批量替换：%s/printf/print/g 将所有的printf替换成print，g - global的意思\n如果代码报错，指定行确定，可以使用vim查看时加上+报错的行那么打开vim光标就在指定行\n感叹号+之前执行过的命令首字母，就可以快速执行\n2.2vim的配置 如果希望对当前的用户做配置\n进入到当前用户的家目录cd ~（家目录里一般会有一些隐藏文件）\n在家目录创建一个.vimrc的文件\n打开.vimrc文件vim .vimrc\n添加配置\n设置语法⾼亮: syntax on\n显示行号: set nu\n设置缩进的空格数为4: set shiftwidth=4\n如果是从网上下vim的插件，需要在当前用户的家目录里建一个.vim的文件，将下载的插件\n放到里面并安装，然后在.vimrc文件中引用.vim里的插件\nLinux是一款多用户的操作系统，改自己用户的vim配置是在当前用户的家目录改的，别的用户\n的vim配置不会改，/etc/vimrc是全局的但是建议只改当前用户的，不改全局的\n自动化配置，在除了root用户以外的家目录下执行\ncurl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh \u0026amp;\u0026amp; bash ./install.sh\n3.编译器gcc/g++ 3.1 程序翻译 \u0026mdash; gcc/g++编译选项 gcc和g++都叫做编译器，主要工作就是将我们写的C/C++代码翻译成可执行二进制程序\ngcc只用来编译C g++编译C/C++ g++ code.cpp -std=c++11\n预处理（进行宏替换/去注释/条件编译/头文件展开等) ，还是C语言\n-E表示从现在开始，进行程序的翻译，一旦预处理做完，就停下来\n如果不带-o，会把预处理的结果打印到显示器上。\n所以code.i保存的就是code.c预处理后的结果\n-o 表明-o后面的文件名称 -E 表示从现在开始，进行程序的翻译，一旦预处理做完，就停下来 头文件展开：将要包含的头文件相关内容拷贝到源文件\n​\t因为头文件里可能还包含其它头文件，所以展开类似于递归式展开\n​\t先追到根上的头文件，然后依次拷贝，最后将需要的头文件内容\n​\t拷贝到可执行程序里，最终编译只编译源文件\nLinux中C语言标准头文件在该路径下/usr/include/\n函数的实现在库里\n编译（C语言\u0026ndash;\u0026gt;汇编)\ngcc -S code.i -o code.s：-S表示开始进行程序翻译，编译做完，形成汇编，就停下来\n汇编（生成机器可识别代码即汇编\u0026mdash;\u0026gt;二进制）\ngcc -c code.s -o code.o可重定位目标二进制文件，无法执行\n-c表示开始进行程序的翻译，编译做完，形成汇编，就停下来\n连接（生成可执行文件或库文件)\n将我们的.o文件和库文件进行连接，形成可执行文件\n总结：\n1）-E -S -c 预处理，编译，汇编\n2）.i .s .o 一些镜像文件的后缀\n补充：反汇编指令\n3.2 为什么要编译，为什么汇编、编译器自举，理解条件编译 为什么要编译，汇编 早期：纸带打孔的方式编程 \u0026ndash; 二进制编程\n汇编语言 \u0026mdash; 编译器就要诞生了\n面向过程，面向对象的语言\n为什么需要把我们用其他语言写的代码转成汇编？\n**减少语言开发的成本。**因为汇编语言出现的比较早，已经有编译器可以将汇编语言翻译成\n二进制语言，所以我们只需要考虑把C/C++等语言翻译成汇编语言。\n编译器自举 先有语言，还是先有编译器？\n先有编译器，二进制的编译器，能编译汇编语言所写的软件，编译器自己是软件\n我们可以用汇编语言重构编译器，这个编译器软件先经过二进制编译器，然后形成\n用汇编写的编译器。\n此后，我们就不需要使用二进制编译器了，而是可以使用用汇编写的编译器\n条件编译 版本管理，通过条件编译形成不同版本\n3.3动静态库和静态链接\u0026mdash;操作部分 源文件经过预处理、编译、汇编后形成的二进制文件是不可执行的，还需要和库文件进行连接，形成可执行文件\n库分为：静态库，动态库\nLinux：动态库（libXXX.so），静态库（libXXX.a）\n去掉前缀lib，去掉后缀.so .a ，剩下的就是库的名称。\n例如：libXXX.so 那么库的名字就是XXX\n​ libc-2.17.so库的名字是c-2.17\nWindows：XXXX.dll XXXX.lib\n直接gcc -c code.c就是执行前三步然后停下来，形成同名的.o文件\ngcc链接库\nldd查看依赖哪些库\nlibc-2.17.so就是C标准库，gcc是用来编译c的，所以gcc能自动链接到c标准库\n我们最终形成的可执行程序是依赖c标准库的\n==默认形成的可执行程序采用的是C语言的.so动态库==\n如果我们希望静态链接\n先要看你的Linux系统里是否安装了静态库\n如果没有安装，需要执行下面的指令\n安装好后，我们可以尝试静态链接\n总结\ngcc默认形成的可执行程序是动态链接的 gcc-static：进行静态链接 3.4动静态库和静态链接\u0026mdash;理论部分 动态库是共享的，所以不能丢失，一旦丢失，所有依赖动态库都会运行出错\n**静态链接：**把我们要的库方法实现，直接拷贝到我们的可执行程序中\n​\t一旦形成可执行程序，即使把静态库删了，程序照样能跑\n总结：\n动静态链接，首先系统里要有动态库，静态库，都有的情况下就可以对程序进行链接\n如果链接的是动态库，就是动态链接；如果链接的是静态库，就是静态链接\n静态链接优点：不依赖库\n缺点：浪费空间（磁盘和内存空间）\n4. 自动化构建make/Makefile 4.1make/Makefile是什么？ make是一个命令\nmakefile是一个文件\n4.2 看看make/Makefile 创建一个名为Makefile的文件 打开Makefile 写入下面的内容，保存退出 以后执行make命令就会生成mytest可执行程序，我们只用 ./mytest就可以运行 4.3 核心思想 第一行是依赖关系，第二行是依赖方法\n依赖关系和依赖方法，形成目标文件\n4.4 具体语法 4.4.1 第一部分-依赖关系 冒号左边，比如上图中的clean和mytest都是一个目标文件\n冒号右边，比如上图中的test.c是依赖文件，如果依赖文件有很多个，那么叫依赖文件列表\n而clean没有依赖文件\n目标文件和依赖文件合起来叫依赖关系\nmake会自动向下扫描makefile文件，形成第一个目标文件\n如果想指定形成，make 指定名称\n.PHONY修饰的变为伪目标，==凡是被.PHONY修饰的方法，总是被执行==\n如果不被修饰，那么如果文件没有修改，再次执行make就不会起作用 \u0026mdash;- 提高效率\nmakefile怎么决定源文件到底要不要重新编译的呢？\n先有源文件，然后gcc形成可执行程序。 之后再修改源文件，那么源文件的修改时间就比可执行程序的时间新 再次编译时，发现可执行程序的生成时间比源文件的修改时间晚，说明这是旧的可执行程序 所以这时允许重新编译源文件 结论：通过对比源文件和可执行文件的修改时间（Modify时间）\n4.1.2 文件的ACM时间 文件=内容+属性\n可以通过stat 文件名的方式查看文件的ACM时间\n文件的内容修改，Modify时间变\n文件的属性修改，Change时间变\n修改文件的内容后，Modify时间变了，同时，文件的大小也变了，所以Change时间也会变 如果只修改文件的权限，那么就只有Change时间会变 Access是文件的最新访问时间，cat一个文件后，就会变。\n但是不是每次访问后，这个时间都会变\ntouch一个文件后，这个文件的ACM时间都更新\nmakefile通过对比源文件和可执行文件的修改时间（Modify时间）来决定源文件\n到底要不要重新编译的。\n所以只要我们touch一下源文件，那么源文件的M时间一定比可执行程序的时间新\n这时再make就又可以编译了\n所以.PHONY修饰一个符号后，总是被执行的原因就是忽略对比时间，下面这条命令总是执行\n4.1.3 第二部分-依赖关系推导 Makefile 是#来注释\n实际依赖了下面这些文件\nmake会进行依赖关系推导（栈），直到依赖文件是存在的\n将依赖方法不断入栈，推导完毕，出栈执行方法\n所以Makefile最终会形成一个目标文件\n4.1.4 第三部分-更加通用的makefile 更加通用的makefile\n我们一般喜欢先把源文件 a.c b.c d.c e.c等先变成a.o b.o d.o e.o \u0026mdash;\u0026mdash;\u0026mdash;编译\n然后再和动静态库文件（lib.so lib.a libstdc++.so llibc++.a）统一打包形成可执行程序 \u0026mdash;\u0026mdash;-链接\n优化1：定义变量\n变量：\nBIN 表示生成的可执行程序 SRC 表示源文件 OBJ 表示目标文件 CC 表示用到的编译器 RM 表示要用到的删除命令 访问变量要使用 $(变量名)\n但是如果源文件多了，就不行，比如我们这里创建100个源文件\n优化2：动态获取当前目录下所有的.c\n方式一：\n使用$(shell ls *.c)来罗列出所有以 .c 结尾的文件\n方式二：\nMakefile自己本身包含了一个语法，给我们提供了一个基本的函数wildcard\n同样可以将我们当前目录下所有的.c文件列出来\n优化3：将源文件的.c都替换为同名.o 放到变量OBJ里\n完整：\n依赖关系里的%.c 会依次展开所有以.c结尾的文件，$\u0026lt; 表示将上面展开的多个.c 一个一个交给对应的命令，一个一个地形成.o\n所以$\u0026lt;指的是把一批文件一个个地拿出来，经过该方法，加工形成同名.o\n不想回显就加@\n依赖方法可以跟很多个\nmake是一个命令\n5.Linux第一个系统程序-进度条 5.1补充-回车与换行 \\r ：回车指从该行当前位置到该行最左侧\n\\n：换行表示到下一行\n1 printf(\u0026#34;hello world\\n\u0026#34;) 语言上的\\n实际上是回车+换行\n回车换行是先换到下一行，然后回到该行的最左侧\n新起一行需要做两步：\n​\t**1.回到当前行的开头 **\n​\t2.到第二行\n5.2 行缓冲区 5.2.1引入 当我们在进行printf打印的时候，如果带了\\n，那么默认是往显示器上打印\nLinux下一切皆文件，所以往显示器上打印就叫做往显示器上写入。\n所以带\\n的表现形式就是数据立即显示。\n带了\\n，数据也一定先放到缓冲区，只不过这个缓冲区是给显示器提供的\n不带\\n再执行时，我们发现在显示器上是先卡了两秒，然后才打印\n但是在C语言中，代码是从上到下依次执行的，所以也就是说，我们发现\n显示器卡了两秒（执行sleep(2)）时就已经执行prinf(\"hello bit\")这段代码了\n但是为什么我们没有看到呢，原因是print这段代码里的数据被保存到缓冲区了\n5.2.2显示器的刷新策略是：行刷新 比如如果打印信息碰到的是\\n那么该信息会立即显示到显示器上\n如果不包含\\n，该字符串不做刷新，直到要么程序结束，自动刷新\n要么将来强制刷新\n如果我们希望不带\\n的字符串立即刷新\n可以使用fflush强制刷新\n在C语言中，我在进行printf打印的时候（包括C程序），\n默认会打开3个文件的输入输出流\nprintf打印消息的时候，是把消息写到了stdout标准输出里面\n所以如果消息没有刷出来，我们就fflush刷新一下标准输出,就可以把这个\n字符串立即刷新出来\n5.3练手-倒计时程序 预备知识1：行缓冲区\n预备知识2：往显示器什么位置写入，由光标决定（类比笔尖）\n​\t写一个字符后，光标就会向后移动一位\n倒计时程序的原理\n我们写一个字符后，光标就会向后移动一位。但是我们现在想写一个\n字符后，想办法将光标再移动到开头。过1秒后，再在里面写另一个字符\nprintf打印的时候要做格式化，就是将整数等转成字符。所以我们这里需要限定打印的宽度，%-2d\n5.4进度条 版本1：显示功能 功能1 首先，在内容中预留出100个字符的空位置，进度条每走一个，就多一个#，右侧中括号的位置不变。 功能2 右侧还有一个中括号，用来显示百分比。 功能3 最右侧还有一个中括号做旋转光标，来证明我们的进度条一直在推进 准备3个文件\n实现功能\nusleep：以微秒的时间来休眠\n1秒=1000毫秒，1毫秒=1000微秒，1秒=1000*1000微秒\nprocess.h中：\nmain.c中：\nprocess.c中：\n注意事项：\nprintf打印的时候，需要做格式化，%-100s\n%要输出时，需要写成 %%\n\\要输出时，需要写成 \\\\\n最后需要printf(\"\\n\")，否则就会和下一行命令在同一行\n版本2：根据进度，动态刷新一次进度条 为了让下载业务或上传业务安心做自己的事，而让刷新行为单独来做，所以我们这里将下载的逻辑和进度条刷新的逻辑进行解耦\n这样的话，回调函数不需要知道具体的刷新函数的名称\nprocess.h\nprocess.c\nmain.c\n6.版本控制器Git 6.1如何理解版本控制 git是一个版本控制器软件，既是一个client也是一个server\ngitee||github是基于git的网站或平台\n仓库\u0026ndash;本质上就是一个文件夹\n1.数据安全\n我们每一次做git操作的时候，在当前目录下我们可以新建很多仓库，\n新建好仓库后，我们可以把自己的仓库推送到远端。\n2.协作开发\ngit是去中心化、分布式的版本控制\n两台装了git的机器相互之间可以互相拉取\n6.2Git的历史 git是开源的\n6.3Git的操作 1.新建仓库 2.将远端仓库拉取到本地 在本地先新建一个目录，然后在目录里执行 git clone 加刚刚复制的HTTPS地址\n我们就拉取到了远端的文件\nls -al就可以看到隐藏文件.git，我们把.git称为隐藏的仓库\n我们可以 tree .git ，.git里面是历史上我们每次修改的记录\ngit提交的时候，只会提交变化的部分\n3. 将我们的文件添加到.git里的暂存区 .git所在的目录：当前工作区\ngit add . 默认把当前工作路径下所有的陌生文件全部添加到.git仓库中\n或者如果确定了要添加的文件，也可以 git add 文件名\n还可以 git add *\n但是执行了这个操作，实际上并不算完全添加到仓库里了，而是先添加到.git里的暂存区\n有了暂存区，git就让我们可以在本地多次add，一次提交到git仓库里\n4.将暂存区里的文件提交到git本地仓库 先查看当前的状态：git status\n如果不想要提交某个文件了，可以使用 git reset HEAD 文件名 来将它删掉\n使用 git commit -m \u0026ldquo;日志信息\u0026rdquo; 才能真正将文件添加到本地仓库\ngit log可以查看提交记录\n5.将本地仓库和远端仓库同步 git push\n如果将本地目录全删掉了，但是想获得我历史上的提交信息，\n复制链接，然后执行以下命令就可以将之前的记录重新拉取下来\ngit clone 复制的链接\n总结 将远端仓库拉取到本地：git clone 复制的链接 将当前目录下的文件添加到 .git暂存区：git add . 或 git add 文件名 查看当前的状态：git status 如果不想提交某个文件了：git reset HEAD 文件名 将暂存区里的文件提交到git本地仓库：git commit -m \u0026ldquo;日志信息\u0026rdquo; 查看提交历史记录：git log 将本地仓库提交到远端仓库：git push 把远端仓库和本地仓库做一下同步：git pull 6.4 Git操作\u0026ndash;细节 1.git命令行安装\n1 2 sudo yum install git sudo apt install -y git 查看当前是否已经安装了：git --version 和 which git\n2.首次使用：git输入username，email\n3.git版本管理，只进行管理源文件\n.gitignore进行本地文件后缀过滤的，如果某些特定后缀的文件在这个配置信息里，\n那么在add，commit，push时就不会被提交\n4..gitignore：需要忽略的特定后缀的文件列表\n5.windows上和liux上的人都对该仓库的文件做了修改，此时需要先重新拉取一下\ngit pull 把远端仓库和本地仓库做一下同步 然后再进行 git push 远端仓库，相比较于任何人，都是最新的\n为什么要冲突？提醒本地用户，你要和远端仓库进行同步了\nUbuntu下安装vimplus\n1 2 3 git clone https://github.com/chxuan/vimplus.git ~/.vimplus cd ~/.vimplus ./install.sh 补充：sudo无法执行 切换到超级用户\n添加配置，yy+p\n切换到底行模式执行wq!保存并退出\n再切回普通账号ctrl+d就可以执行sudo了\n二、调试器 - gdb/cgdb使用 2.1 准备知识 软件发布的模式\ndebug\nrelease模式 \u0026ndash; 发布模式\n软件测试工程师，测试就是对release版本进行测试 \u0026ndash; 上线\nLinux下我们编译好的代码无法直接调试\n如何调试？\ngcc/g++默认的工作模式是release模式\n如何改到debug模式？在编译的时候要加上-g选项：\nreadelf读取一个可执行程序的格式：\nreadelf指令会在可执行程序与elf以及动静态库加载的时候深入学习\ngrep -i debug 表示忽略大小写查debug\n我们发现，在编译的时候加上 -g 选项可以给最后形成的可执行程序添加上调试信息\n未来我们再输入 gdb [可执行程序] 命令就可以调试程序了\n结论：\n-g选项，让最后形成的可执行程序，添加调试信息 \u0026ndash; debug模式\n程序要调试，必须是debug模式\n如何调试程序？gdb 携带调试信息的exe\n2.2 快速认识gdb 1）gdb的安装 CentOS下：\n1 sudo yum install gdb Debian 或 Ubuntu下：\n1 2 sudo apt-get update sudo apt-get install gdb 2）gdb如何进行打开，退出，中间如何让程序跑起来 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; int Sum(int s, int e) { int result = 0; for(int i = s; i \u0026lt;= e; i++) { result += i; } return result; } int main() { int start = 1; int end = 100; printf(\u0026#34;I will begin\\n\u0026#34;); int n = Sum(start, end);//求区间的和，闭区间[start, end] printf(\u0026#34;running done, result is: [%d-%d]=%d\\n\u0026#34;,start, end, n); return 0; } 这段代码直接编译会提示不支持在循环体中定义变量，所以要带上-std=c99\n这时如果我们直接gdb mycode会发现提示找不到该命令，原因是默认是release发布模式\n需要在编译的时候带上-g选项\n再次执行 gdb mycode就可以进行调试了\n在调试模式下，我们可能会用到如下的操作\n查看源代码\nlist（可以简写成l）\nl 1，代码从第一行开始显示\n之后直接回车，就会继续显示下面的代码\n打断点： b 行号\n让程序运行起来：r\n让程序直接跑完：c\n退出：quit\n2.3 安装cgdb ，解决gdb难用的问题 安装cgdb\nUbuntu:\n1 sudo apt-get install -y cgdb Centos:\n1 sudo yum install -y cgdb 使用cgdb进行调试，cgdb 可执行程序\n调试界面就会变成：上面是代码界面，下面是debug界面\n2.4 cgdb命令的学习 1）根据文件名查看代码 命令格式：l 文件名:行号\n**例如：**l mycode.c:1\nl表示从第一行开始显示\n2）和断点相关的常用操作 打断点的几种方法：\nb 文件名：行号 b 文件名:函数名，例如：b mycode.c:main b 行号 b是break的简写\n查看当前打的所有断点：info b\n删除断点：d 断点编号\n运行到下一个断点处：c\n跳出循环，到下一个断点：until 代码行号\n3）运行程序 运行程序：r 如果没有断点，则直接跑完\n逐过程：n 或者 next\n在调试的过程中再次输入r就可以重新从断点处开始调试\n逐语句（会进入到函数内部）：s 或者 step\ngdb会自动记录最新的一条输入指令\n例如如果我们在debug期间不想一直输s了，就可以回车\n4）查看栈帧 bt main先入栈，Sum函数先出栈\n5）结束函数调用，回到函数调用处 finish 6）变量相关 临时查看变量的值：p 变量名\n让变量一直显示：dispaly 变量名/\u0026amp;变量名等\n如果不想让变量一直显示：undisplay 编号\n查看整个函数内定义的临时变量：info locals\n查看变量的变化：watch 变量，不用了就 d 编号\n可以在调试的时候手动将变量的值改了，然后再调试：set val 变量=值\n7）断点可以被使能（开关） 默认断点是 Enb y 表示Enable yes\n想让断点不起作用：disable 断点编号\n恢复断点的作用：enable 断点编号\n只有打断点的时候需要行号，其它时候都使用断点编号\n8）查看源代码 cgdb分屏操作，ESC 进入代码屏幕，然后可以通过上下键查看源代码，i回退到命令行，\n2.5调试的本质 找到问题\n断点的本质，是把代码进行块级别划分，以块为单位进行快速定位区域\nc -\u0026gt; 运行到下一个断点处\nfinish -\u0026gt; 快速跑完该函数，可以帮助我们确认问题是否在函数内\nuntil 代码的行号 -\u0026gt; 局部区域快速执行\n查看代码上下文\n我们自己解决问题 2.6条件断点 需求：我们希望在for循环中，只有i=10的时候该断点才会被触发\n可以像下面这样打断点\n表示在第10行打断点，当i=10的时候\n在断点已经存在的情况下新增条件\n给4号断点新增条件：当i=20时\n三、知识点 操作系统的生态问题！ 什么OS是好的OS？生态好 将二进制程序做反汇编，例如：\nobjdump -S mycode \u0026gt; mycode.s\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/linux-basic-permission-development-tool/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_b09e032a367fa6ec.png","permalink":"https://Amarantos-Arrebol.github.io/p/linux-basic-permission-development-tool/","title":"【Linux】02基础权限开发工具"},{"content":"一、进程 创建进程时，要有对应的task_struct来描述进程\n而每一个task_struct最终都要对应一个虚拟地址空间\n1.1进程概念 1.1.1冯诺依曼体系结构 输入设备：键盘，鼠标，话筒，摄像头\u0026hellip;网卡，磁盘\n输出设备：显示器，磁盘，网卡，打印机\u0026hellip;\n在冯诺依曼体系中，统一把输入输出设备称为外设\n输入设备：将外设的数据读到内存里\n输出设备：把内存的数据输出到外设中\n磁盘和网卡 既是输入设备也是输出设备：\n读取文件就是把磁盘中的数据读到内存里；\n写文件就是把内存里的数据写到磁盘上\nInput/Output \u0026mdash;\u0026gt;IO\n站在内存的角度，外设把数据交给我（内存）\u0026mdash;\u0026gt;Input\n我(内存)把数据交给输出设备\u0026mdash;\u0026ndash;\u0026gt;Output\nCPU=运算器+控制器\n算术运算（+-*/等），逻辑运算（真假）\n控制器主要是控制CPU去取指令，分析指令，执行指令\n我们把CPU也叫做中央处理器\n存储器：内存\n磁盘：外存\n1.1.2软件运行，必须先加载到内存 软件运行，必须先加载到内存。程序运行之前，在哪里？\n磁盘。程序就是一个文件，是编译好的在磁盘特定路径下的二进制文件\n为什么程序运行的时候要先将程序加载到内存？ \u0026mdash;\u0026ndash;\u0026gt; 体系结构规定\nCPU获取，写入，只能从内存中来进行\n软件运行 实际上是CPU执行我们的代码，访问我们的数据\nCPU无法直接从外设读取数据，所以必须先将数据加载到内存\n这时，我们的程序才能被CPU访问到\n执行printf的时候是先从CPU处理完后，放到内存的缓冲区里，然后需要的时候再把数据刷新到外设\n数据流动的本质——数据是从一个设备”拷贝“到另一个数据\n体系结构的效率：由设备的拷贝效率决定\n结论：在数据层面，CPU只和内存打交道，外设只和内存打交道\n存储分级：离CPU越近，效率越高，容量越小\n为什么不按照下面的方式设计计算机呢？\n由于CPU处理数据非常快，外设的处理数据比较慢，如果采用这种结构\n那么整个体系结构的效率就完全由外设的效率决定了\n所以引入内存\n内存和CPU，外设都能比较好地适配\n操作系统能提前将输入设备里的数据搬到内存里\n有了内存，使当代计算机，是性价比的产物\n后来，芯片技术+摩尔定律\n1.1.3 理解数据流动 数据流动的本质就是在冯诺依曼体系结构中进行流动\n举例：\n1.QQ聊天\n用户从键盘输入，首先要打开QQ这个软件，需要将QQ这个软件加载到内存，把键盘\n数据搬到内存，你的消息需要经过运算器控制（加密、封包\u0026hellip;），然后由CPU写回内存\n再通过QQ将数据送到自己的体系结构的输出设备（网卡）\n网卡将数据交到网络里，一定会交到朋友的那台机器，由朋友的输入设备（网卡）\n来接收，朋友的QQ也一定得启动起来加载到内存，把数据从外设搬到内存，在QQ\n内部执行所有的代码（将读到的数据交给CPU，比如做解密，然后再交给内存），由\n存储器刷新到输出设备（显示器）\n2.发送文件\n文件是在磁盘上的，当我们将文件拖拽到QQ中，本质上是将磁盘文件拷贝到QQ，即\n搬到内存里，经过CPU的加密封装\u0026hellip;等，然后再写回到存储器（内存），再将我们的\n文件数据刷新到网卡，经过网卡，对方网卡接收，读到内存，经过CPU解包解密，写回\n到内存，打开对应目标文件，然后把数据写入到输出设备（磁盘）\n1.1.4 操作系统 操作系统基本介绍 一个基本的程序集合，称为操作系统（OS）\n操作系统是一款进行软硬件管理的软件\n操作系统包括：\n内核（进程管理，内存管理，文件管理，驱动管理）\n其它程序（例如函数库，shell程序）\n设计OS的目的 为用户程序提供一个良好的执行环境\n硬件部分\n最底层是硬件，而硬件在逻辑上是按照冯诺依曼结构组织的\n每一种硬件都有对应的驱动程序\n驱动程序\n在硬件层面，不同的硬件都有自己个性化的读取方式，所以我们访问各种不同的硬件都要配上驱动程序\n操作系统\n对下，与软硬件交互，管理所有软硬件资源（不是目的，是手段）\n对上，为用户（目的）程序（应用程序）提供一个良好的执行环境\n1.软硬件体系结构层状结构 \u0026ndash; 从硬件一直到用户\n硬件是一层，驱动程序是一层，操作系统是一层\n软件的层状结构：在软件功能上体现高内聚，低耦合\n高内聚：将相同功能相同逻辑的代码数据放到同一层的内部 低耦合：层跟层之间只使用接口来调用 目的：提高代码的可维护性 \u0026ndash;一个模块修改了，不影响另一个模块\n2.访问操作系统，必须使用系统调用\u0026ndash;其实就是函数，只不过是系统提供的\nprinf的本质：把数据写到了硬件!显示器!\n底层封装了系统调用，然后通过操作系统，对驱动进行访问，访问对应驱动，然后才能把数据交到硬件上\n3.我们的程序，只要你判断出它访问了硬件，那么它必须贯穿整个软硬件体系结构\n4.我们平时用的库可能在底层封装了系统调用\n理解操作系统\n核心功能\n在整个计算机软硬件架构中，操作系统是一款进行软硬件管理的软件 如何理解管理？\n事情：1.决策 2.执行\n操作系统拥有决策权，驱动程序来执行，硬件被管理\n1.要管理，管理者和被管理者，可以不需要见面\n2.管理者和被管理者，怎么管理呢？根据数据进行管理\n3.不需要见面，如何得到数据？由中间层获取\n操作系统如何管理硬件？\n1.描述起来，用struct结构体 2.组织起来，用链表或其他高效的数据结构\n每一个硬件都有硬件名，操作系统在内部，先描述，再组织。\n把网卡、硬盘、显卡、键盘、显示器等统一使用struct device定义一个结构\n类里面可以包含每一种硬件的各种属性（硬件名称、状态、相关链接信息..）\n每一个硬件都对应一个struct device对象，把对象管理起来。\n操作系统管理硬件 \u0026mdash;\u0026gt; 对硬件的增删查改\n操作系统怎么对进程进行管理？\n操作系统要对每个进程定义struct结构体结构，然后将进程相关的属性放到\n结构体里，用链接结点全部连起来，转换成对进程管理，转换成对链表的\n增删查改\nC++中：类+STL\n类解决了先描述 STL解决了再组织 理解系统调用\n操作系统要向上提供对应的服务 操作系统，不相信任何用户或者人 我们未来访问操作系统、获取操作系统内的数据、设置自己的信息等都要通过系统调用来完成\nLinux/windows/macos的操作系统都是C语言写的\u0026ndash;\u0026gt;C函数\u0026ndash;\u0026gt;输入参数和返回值\n输入参数：用户给操作系统 返回值：操作系统给用户 系统调用的本质：用户和操作系统之间，进行某种数据交互\n库函数如果访问了硬件，那么底层一定访问了系统调用\n系统调用和库函数\n在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。\n系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。\n1.2 进程 1.2.1 概念 ==进程 = 内核数据结构对象 + 自己的代码和数据==\n==进程 = PCB(task_struct) + 自己的代码和数据==\n操作系统必然要对多个被加载到内存中的程序进行管理\n对进程的管理，就变成了对链表的增删查改 我们把这个结构体叫PCB（process control block )进程控制块\n在Linux中，这个PCB叫task_struct，\n进程的所有属性，都可以直接或者间接通过task_struct找到\ntask_struct - PCB的一种\n在Linux中描述进程的结构体叫做task_struct。 task_struct是Linux内核的一种数据结构类型，它会被装载到RAM（内存）里并且包含着进程的信息 6.2.2 task_struct 在Linux中描述进程的结构体叫做task_struct。\n标志符：描述本进程的唯一标志符，用来区别其它进程 状态：任务状态、退出代码、退出信号 优先级：相对于其它进程的优先级 程序计数器：程序中即将被执行的下一条指令的地址 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针，能真正找到代码和数据 上下文数据：进程执行时处理器的寄存器中的数据 I/O状态信息：包括显示的I/0请求，分配给进程的I/0设备和被进程使用的文件列表 记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等 其他信息 组织进程\n可以在内核源代码里找到它。所有运行在系统里的进程都以task_struct链表的形式存在内核里\n6.2.3 查看进程 sleep需要包含头文件unistd\n我们历史上执行的所有指令，工具，自己的程序，运行起来，全部都是进程\ngetpid()查看进程id getpid获得标志符，谁调用这个函数就获得谁的进程ID\n调getpid本质是让操作系统从PCB里把我的pid拷贝出来，让用户看到我的ID是什么\nman 3号手册是库调用，2号手册是系统调用 task_stuct结构体里有个属性叫pid getpid是系统调用，为了获得进程自己的pid，pid在当前进程task_struct里对应的标志符里 只要是一个进程，就有自己的ID信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; int main() { while(1) { sleep(1); printf(\u0026#34;我是一个进程!, 我的pid:%d\\n\u0026#34;, getpid()); } return 0; } ps axj查看以特定形式显示的所有进程（a表示所有）\nps axj | head -l先将第一行显示（属性列的名字） ps axj | grep myprocess再查我们的进程 在Linux中，如果想同时执行两条命令，可以使用分号或者\u0026amp;\u0026amp;连接\n因为grep命令它自己跑起来也是一个进程，它过滤的关键字中也包含myprocess，所以它自己也会被查出来，如果不想把grep也查出来，可以带-v 反向匹配，也就是包含grep的不查出来\nps ajx | head -1;ps axj | grep myprocess | grep -v grep\n杀掉进程：kill -9 对应PID\n-9表示信号\nctrl+c也可以杀掉进程\n通过文件去查看进程 可以通过文件的方式去查看进程\nproc目录（process的简写）\n进程运行时，proc里的数据已经拷贝到内存了\n例如：\n先将程序运行起来 查proc目录里的pid文件 当我们杀掉这个进程后再查，就发现找不到目录了 看一看进程目录下都有哪些文件\nexe：进程对应的可执行文件\ncwd：current work dir 进程会记录下来自己的当前路径\n更改一个进程的当前路径chdir\ngetppid()查看父进程 getppid()\n1.命令行解释器（王婆）：本质是一个进程\n2.王婆和实习生\n操作系统会给每一个登录用户，分配一个bash\nfork函数创建子进程 fork函数，从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。\nfork的返回值\n如果创建子进程成功了，那么父进程和新创建的子进程都要执行这个函数的return语句，此时\n如果是父进程，那么返回值就是子进程的pid 如果是子进程，那么返回值是0 如果创建子进程失败了，那么返回值就是-1\n现在我们想让父子未来执行不同的代码逻辑\n为什么fork给父子返回各自的不同返回值？\n父：子 = 1：n\n任何一个父进程都可以有多个子进程，任何一个子进程都只会有一个父进程\n所以未来创建子进程的时候，一定要把子进程的pid返回给父进程，因为父进程要通过不同的pid来区分不同的子进程，而子进程不需要获得父进程的pid，因为它自己能getpid()\n为什么一个函数会返回两次？\n当一个函数已经到return xx了，核心工作已经做完了。\nfork函数当执行到return语句的时候，子进程已经被创建，甚至被调度了！\n由于return 也是语句，所以父子进程各执行一次\n返回的本质是在写入变量\n进程调用fork，当控制转移到内核中的fork代码后，内核做：\n分配新的内存块和内核数据结构给子进程 将父进程部分数据结构内容拷贝至子进程 添加子进程到系统进程列表当中 fork返回，开始调度器调度 为什么一个变量，既==0，又大于0？导致if else 同时成立? 写时拷贝\n进程具有独立性\n数据结构独立，进程=内核数据结构对象 + 自己的代码和数据\n代码共享，但是代码是只读的\n数据以写时拷贝的方式，各自私有一份\n写时拷贝\n通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副本\n因为有写时拷贝技术的存在，所以父子进程得以彻底分离离！完成了进程独立性的技术保证！ 写时拷贝，是一种延时申请技术，可以提高整机内存的使用率\n1.3进程的状态 6.3.1进程状态基本介绍 一个进程可以有几个状态（在Linux内核里，进程有时候也叫做任务）\n进程状态就是task_struct内的一个整数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* *The task state array is a strange \u0026#34;bitmap\u0026#34; of *reasons to sleep. Thus \u0026#34;running\u0026#34; is zero, and *you can test for combinations of others with *simple bit tests. */ static const char *const task_state_array[] = { \u0026#34;R (running)\u0026#34;, /*0 */ \u0026#34;S (sleeping)\u0026#34;, /*1 */ \u0026#34;D (disk sleep)\u0026#34;, /*2 */ \u0026#34;T (stopped)\u0026#34;, /*4 */ \u0026#34;t (tracing stop)\u0026#34;, /*8 */ \u0026#34;X (dead)\u0026#34;, /*16 */ \u0026#34;Z (zombie)\u0026#34;, /*32 */ } 进程状态很多，这些状态间可以相互进行转换\n运行\u0026amp;\u0026amp;阻塞\u0026amp;\u0026amp;挂起 一个CPU，一个调度队列。这个队列在Linux内核里叫runqueue\nCPU调度就是在这个队列中，按照顺序，依次选择一个task_struct来选择执行\n**运行：**进程在调度队列中，进程的状态都是running\n**阻塞：**等待某种设备或者资源就绪（键盘，显示器，网卡，磁盘，摄像头，话筒\u0026hellip;.）\n操作系统要管理系统中的各种硬件资源，先描述，再组织\n例子：\nCPU正在运行一个进程，运行的过程中操作系统发现这个进程要scanf进行读取，操作系统就去检查键盘的状态，发现键盘并没有被按下，操作系统就认为这个进程就无法继续往下运行，就把这个进程从CPU上拿下来，并把它从运行队列中移走并链入到特定设备的等待队列中，这个进程就没有在运行队列中，不会被调度，这个进程就处于阻塞状态了（只有在运行队列里的进程才会被CPU调度）\n当键盘被按下了即硬件就绪了，由于操作系统是硬件的管理者，操作系统知道了，于是直接去查看对应就绪设备的节点，将其状态设置为活跃的，并检查等待队列，发现不为空，就将等待队列中的进程设置为运行状态，然后将该进程重新链回运行队列\n从运行队列到变成阻塞的本质其实是把PCB链入到不同的队列结构中\n从阻塞回到运行状态，本质上就是找到PCB，再把PCB链回到运行队列，就变成运行状态了\n进程状态的变化，表现之一就是要在不同的队列中进行流动，本质都是数据结构的增删改查\n**挂起：**本质是把进程换入换出到磁盘的swap交换分区\n在等待队列中，可能不止一个进程，这些进程没有被执行但是都需要占用内存空间，当内存空间严重不足时，操作系统就会将这些在等待队列的进程置换到磁盘中的swap分区中（在等待队列中只存PCB，而将对应的代码和数据唤出到swap分区中，等这些进程要运行了，再把代码和数据还回去），这些进程的状态就叫阻塞挂起\n如果内存特别紧张，操作系统可能把在运行队列中末端的一些进程置换到磁盘中——\u0026gt;运行挂起状态\n理解内核链表 我们以前学的链表，next指针会指向整个Node结点：\nLinux内核中的链表，next指针只会指向目标结构体内部的某一个成员对象：\n==一个PCB在内核里只存在一份，一个PCB可以同时隶属于多个结构==\n我们内核中的数据结构不是单一的数据结构\n进程状态查看的命令 ps aux 和 ps axj\na：显示一个终端所有的进程，包括其他用户的进程。 x：显示没有控制终端的进程，例如后台运行的守护进程。 j：显示进程归属的进程组ID、会话ID、父进程ID，以及与作业控制相关的信息 u：以用户为中心的格式显示进程信息，提供进程的详细信息，如用户、CPU和内存使用情况等 Linux的进程状态 1 2 3 4 5 6 7 8 9 static const char *const task_state_array[] = { \u0026#34;R (running)\u0026#34;,/*0 */ \u0026#34;S (sleeping)\u0026#34;，/*l */ \u0026#34;D）(disk sleep)\u0026#34;，/*2 */ \u0026#34;T(stopped)\u0026#34;，/*4 */ \u0026#34;t(tracing stop)\u0026#34;，/*8 */ \u0026#34;X (dead)\u0026#34;，/*16 */ \u0026#34;Z (zombie)\u0026#34;，/*32 */ }; **R运行状态（running ）：**并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里\n当我们不做IO相关的操作时：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main() { while(1) {} return 0; } 有加号的原因是因为进程是在前台启动的，把\u0026amp;放到运行进程命令的后面就可以让进程在后台运行\n例如 ./myprocess \u0026amp; 表示将myprocess进程放在后台去运行\nS睡眠状态（sleeping)：意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠 (interruptible sleep)，浅睡眠）\n可中断休眠状态：如果一个进程自己处于S状态，我们可以直接杀掉这个进程，这个进程会响应我们杀掉它的动作\n当我们键盘一直没有输入时，进程状态就是S（阻塞状态）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { printf(\u0026#34;我是一个进程，pid：%d\\n\u0026#34;, getpid()); int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); return 0; } 当代码中有printf（有IO操作）时：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { while(1) { printf(\u0026#34;hello\\n\u0026#34;); } return 0; } t和T 暂停状态\nt状态\n当我们调试程序时，给这个程序打上断点再运行，那么这个程序的进程状态就是 t，即进程被暂停了\nT停止状态（stopped）：可以通过发送 SIGSTOP信号给进程来停止（T）进程。这个被暂停的 进程可以通过发送SIGCONT信号让进程继续运行\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { while(1) { printf(\u0026#34;hello\\n\u0026#34;); } return 0; } 当我们按ctrl+Z 将当前进程暂停，是通过用户进行操作将进程暂停了，这时的状态就是 T\n暂停进程的方式二：发送信号\n如果想要进程再次运行\nD磁盘休眠状态（Disk sleep）：深睡眠，也可以叫不可中断睡眠状态（uninterruptible sleep），通常发生在同步I/O操作或某些内核操作（如内存换页）时。在这个状态的进程通常会等待IO的结束。\n处于D状态的进程有权不对任何杀掉的动作做出响应，也就是操作系统或者用户不管什么情况下都杀不死该进程，只能等该进程自己”醒来“\n注意：\n1.正常的用户程序（如复制文件）通常不会长时间处于D状态，因为操作系统使用了缓存。\n2.如果系统中有进程长时间处于D状态，这很可能意味着硬件（如磁盘）出现了故障，或者系统负载过高导致I/O响应极其缓慢（比如在内存不足时大量换页），从而使得进程无法在短时间内完成l/O操作。\n模拟D状态：dd命令\ndd if=/dev/zero of=~/test.txt bs=4096 count=100000\nx死亡状态（dead）：这个状态只是一个返回状态，你不会在任务列表里看到这个状态\nZ僵尸状态（zombie）：子进程退出后，父进程还在运行，但父进程没有读取子进程退出信息，此时子进程就进入Z状态\n总结 运行\nR：运行状态，我们可以把 运行状态、就绪状态、创建状态 都当成运行状态 阻塞：\nS：可中断睡眠，浅睡眠。意味着进程在等待事件完成 D：不可中断睡眠，深度睡眠。和磁盘的读取写入相关（如果被中断，可能会导致数据丢失） 暂停状态 t / T\nt：被debug，断点：进程被暂停了 T：通过用户进行操作将进程暂停，比如通过发送信号 kill -19 结束状态\nX：死亡状态 Z：僵尸状态，子进程退出后，父进程还在运行，但父进程没有读取子进程退出信息 阻塞状态是进程自己等待某种设备或者资源就绪，比如进程等待 I/O 完成\n暂停状态是外部强制让进程停下来，比如调试过程中下断点和用户发送暂停信号\n挂起状态本质是系统内资源严重不足，操作系统为了节省内存，把一个进程的代码和数据换出到交换分区上，等需要调度/运行的时候再换入进来\n6.3.2僵尸进程 Z僵尸状态（zombie）：为了获取退出信息\n在Linux系统里，我们目前所学的所有进程都是某个进程的子进程，我们创建子进程的目的是为了让子进程完成某种事情。所以当一个子进程退出，不能直接退出，子进程退出的结果信息得让父进程知道\n当一个进程退出时，它的代码和数据直接就被释放掉了，但是它的PCB必须一直维持（PCB就是操作系统内部的一个数据结构，父进程可以进行系统调用，获得子进程的信息），直到父进程读取到子进程的退出信息\n如何模拟Z状态？\n1.需要有父子进程\n2.需要让子进程退出\n3.子进程在退出的时候，父进程什么都不干，让子进程一直维持在Z状态\n如果父进程一直不管，不回收，不获取子进程的退出信息，那么Z状态会一直存在\n如果父进程不管，子进程的Z状态一直存在，那么PCB就要一直维护，就要一直占用内存，就会引发内存泄漏问题\n所以父进程未来获取子进程退出信息的时候，除了获取子进程的退出信息，还要把PCB释放掉（解决内存泄漏）\n知识点1：\n进程退出了，内存泄漏问题还在不在？不在\n什么样的进程具有内存泄漏问题，是比较麻烦的？常驻内存进程（一旦启动就不会退出）\n操作系统一旦启动后，就是常驻内存软件\n知识点2：关于内核结构的申请\n6.3.3孤儿进程 父进程先退出，子进程就称为“孤儿进程”\n父子进程关系中，如果父进程先退出，子进程要被init / systemd 进程领养，由init / systemd进程回收，这个被领养的进程（子进程），叫做孤儿进程\nwhile :; do ps ajx | head -1 \u0026amp;\u0026amp; ps ajx | grep myprocess;sleep 1; done\n1号 systemd/init 进程——\u0026gt;操作系统\n为什么要领养？\n如果不领养，子进程进入僵尸之后，就一定会造成内存泄漏而无法解决\n孤儿进程会变成后台进程\n./cmd \u0026amp; 也会变成后台进程\nctrl+c不能杀掉后台进程\n1.4进程的优先级 6.4.1基本概念 进程的优先级是什么？\n是进程得到CPU资源的先后顺序\n为什么要有优先级？\n目标资源稀缺，导致要通过优先级确认谁先谁后的问题\n优先级vs权限\n优先级：能得到资源，先后问题\n权限：是否能得到资源\n操作系统内优先级是如何实现的？\n优先级也是一种数字，task_struct中的一种属性\n值越低，优先级越高，反之，优先级越低\n当代大部分操作系统都是基于时间片的分时操作系统，要考虑公平性，优先级可能变化，但是变化幅度不能太大\n6.4.2查看系统进程 ps -l\nUID：user id PRI：代表这个进程可被执行的优先级，其值越小越早被执行 NI：代表这个进程的nice值 ps -al | head -1 \u0026amp;\u0026amp; ps -al | grep myprocess\n小知识\nLinux是通过用户id来识别用户的\n文件在创建的时候就写入了UID，即这个文件是谁创建的\n进程在启动的时候也会把UID保存起来，表明这个进程是谁启动的\n如何查看用户id？ls -ln\nn表示显示数字\n系统怎么知道我访问文件的时候，是拥有者，所属组，还是other\n当我们 touch ，cat，vim \u0026hellip;访问文件的时候，本质是进程在访问文件\n进程在启动的时候会保存启动它的UID\nLinux系统中，访问任何资源，都是进程访问，进程就代表用户\n识别权限不是识别用户，是识别进程和文件之间的权限的\n6.4.3PRI和NI PRI：进程的优先级，默认：80\nNI：进程优先级的修正数据，nice值，默认为0\n在Linux系统中，我们的进程优先级是可以被动态调整的，不管是进程启动前还是进程运行过程中\n进程真实的优先级=PRI(默认80) + NI\n改进程的优先级，top，再输入 r\n修改Nice值\n还有一些方法可以改进程的优先级：nice，renice命令\n优先级的极值问题：\nrenice -n -100 -p 3092\nrenice -n 100 -p 3092\nnice值的范围是[-10, 19]\n进程优先级PRI默认是：80\nLinux进程的优先级范围 [60, 99]\n因为进程调度要考虑公平性\n进程优先级设立不合理，会导致优先级低的进程，长时间得不到CPU资源，进而导致：进程饥饿\n6.4.4补充: 进程四个特征 由于CPU资源是有限的，所以各个进程之间是具有竞争属性的\n进程之间具有独立性\n进程=内核数据结构(task_struct)+代码和数据\n每个进程都有自己独立的 task_struct，每个进程都有自己的代码和数据\n并行：多个进程在多个CPU下分别，同时进行运行\n并发：多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进\ncat /proc/cpuinfo\n1.5进程切换 6.5.1死循环进程如何运行 a. 一旦一个进程占有CPU，会把自己的代码跑完吗？\n​\t不会，对于每一个进程，系统都会给它分配一个叫时间片的东西\nb. 死循环进程，不会打死系统，不会一直占有CPU\n6.5.2CPU，寄存器 结论：\n寄存器就是CPU内部的临时空间\n寄存器 != 寄存器里面的数据\n​\t寄存器是空间，寄存器里面的数据是内容！\n​\t空间只有1份，内容是变化的，多份的\n6.5.3进程是如何切换的？ a. 故事\n当兵？保留学籍—\u0026gt;当兵—\u0026gt;恢复学籍\n保留学籍的目的就是为了恢复学籍\n​\tb. 具体\n进程切换，最核心的就是保存和恢复当前进程的硬件上下文的数据，即CPU内寄存器的内容！\n1.当前进程要把自己的进程硬件上下文数据，保存起来。保存到哪里了呢？\n保存到进程的task_struc里面\n当代计算机给每个进程一个 TSS：任务状态段，能直接通过task_struct找到TSS\n​\t2.全新的进程vs已经调度过的进程\n可以理解成在task_struct里面再新增一个标记位，比如int isRunning ，进程没有运行就是0，只要一开始调度就直接置为1\n时间片：当代计算机都是分时操作系统，没有进程都有它合适的时间片（其实就是一个计数器)。时间片到达，进程就被操作系统从CPU中剥离下来。\nstruct task_struct* current 记录当前进程结构指针变量\n1.6Linux2.6内核进程O(1)调度队列 调度和切换共同构成了调度器，调度器的作用：1.切换 2.选择进程\n也就是先把当前进程保存下来，再在系统中选择一个进程，把这个进程放上来\nLinux真实调度算法：\n一个CPU，一个运行队列（两个CPU，两个运行队列\u0026hellip;）\nLinux的优先级有140个：\n[0,99] 100个是实时优先级，我们不考虑 操作系统分为两大类：\n分时操作系统：按照时间片公平调度\n现在很多操作系统都支持内核优先级抢占\n实时操作系统：一旦来了一个进程，就必须实时响应，处理完才能处理下一个进程\n实时操作系统一般应用在工业、制造\u0026hellip;等领域，例子：车载操作系统\n普通优先级：[100,139] 活动队列 Linux进程的优先级范围 [60, 99]，在队列中的位置：x-60+(140-40)\n宏观上看优先级，优先级相同的，先进先出\n调度器如何快速地挑选一个进程？\nunsigned int bitmap[5] 位图 ——\u0026gt; 32 * 5 = 160\n比特位的位置和queue[140]的位置是一一对应的\n比特位的内容：1或0，表示是否存在进程\n调度器挑选一个进程：1.挑队列 2.挑进程\n调度器挑队列只需要查看对应的位图\nnr_active: 总共有多少个运行状态的进程\n所以调度的时候先查nr_active，大于0，再查bitmap，确认下标直接索引找到目标队列，从队列头部提取内容，pop_front，把对应节点拿出来，把PCB放入到current指针里，然后执行切换算法，然后让current指向的进程放到CPU上就可以运行了\n过期队列 active指针和expired指针\nactive指针永远指向活动队列 expired指针永远指向过期队列 活动队列上的进程调用完之后，交换active指针和expired指针的内容 总结 在系统当中查找一个最合适调度的进程的时间复杂度是一个常数，不随着进程增多而导致时间成 本增加，我们称之为进程调度0(1)算法\n二、环境变量 1. 引出环境变量 环境变量的概念\n环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数 —\u0026gt;bash用—\u0026gt;用户间接用了\n如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。\n环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性\n1.1命令行参数 我们自己的可执行程序的入口不是main函数，Linux中的入口函数是start函数\nmain函数是有参数的，argv是一个指针数组，argc代表数组中的元素个数\n当我们在命令行输入一个./code 或以空格作为分隔符，其实输入的就是一个长字符串。而当我们在执行某一个C语言程序时，这些字符串会以空格为分隔符切分\n我们平时用的命令本质上就是可执行程序，基本上都是用C语言写的，我们可以给命令后面带很多选项\nmain函数的命令行参数，是实现程序不同子功能的方法（指令带选项）\n我们在命令行输入带选项的命令，本质上是字符串，被bash切分\n进程拥有一张表，argv表，用来支持实现选项功能\n1.2环境变量与命令查找 要执行一个程序，必须先找到它，谁找？bash找，通过PATH(环境变量)找 执行我们自己写的程序，需要带./ 表示在当前路径下，但是为什么执行系统指令不需要带./呢？ 系统中存在环境变量，来帮助系统找到目标二进制文件 系统中存在环境变量PATH，告诉系统去哪查目标二进制文件 我们把自己写的二进制文件拷贝到 /usr/bin 路径下之后，也可以不带路径，直接执行\n但是不建议这样做，因为我们自己写的二进制文件可能有bug，会污染系统本来的指令池\n移除我们拷贝到/usr/bin路径下的二进制文件：\n2.环境变量初识 2.1显示系统中所有环境变量 env\n2.2查看某一个环境变量的内容 echo $某一个环境变量的名字\n例如查看环境变量PATH的内容：echo $PATH\n2.3PATH环境变量 PATH环境变量里记录了多个路径，这些路径之间以冒号作为分隔符\n当系统在搜索某些命令/二进制文件时，默认会按顺序依次在这些路径下查找：\n先在第一个路径下找，如果找到就执行 如果没有找到，就到下一个路径找 如果所有路径都没找到，就报Command not found 比如当我们要执行 ls 命令时，系统默认会去查环境变量PATH，从环境变量PATH中的第一个路径/usr/local/bin下开始找，如果没有找到，就到第二个路径 /usr/bin路径下去找，以此类推，直到遍历完所有路径。如果没有找到，就报 Command not found；如果找到了，就执行该命令\n所以，如果我们想要不带路径，直接运行自己写的二进制文件，就有两种方法了\n方法1： 将我们的二进制文件拷贝到PATH环境变量里的路径下\n比如我们把自己写的二进制文件拷贝到 /usr/bin 路径下之后，可以不带路径，直接执行\n方法2： 把我们自己二进制文件所在的路径添加到环境变量PATH\n直接覆盖添加环境变量：PATH=路径\n这种方式会覆盖原有的PATH，导致系统命令无法使用，不推荐\n不覆盖添加环境变量：PATH=$PATH:要添加的路径\n这种方式会将新路径追加到原PATH末尾，不影响系统原有命令\n注意：以上两种方式只是临时生效，关闭终端重新登录后会失效\n2.4设置一个新的环境变量 export 环境变量名=值 export 环境变量名 取消环境变量\nunset 环境变量名 2.环境变量的理解 2.1如何理解环境变量 1.如何理解环境变量(存储的角度)？环境变量的值是被bash保存起来的，由bash来执行这些命令\n当我们登录系统时，系统会创建一个bash进程，bash会从配置文件中读取所有环境变量信息，并在其内部构建一张环境变量表\n环境变量表其实就是一个指针数组，数组中的每个元素都指向一个key-value形式的长字符串，我们使用 env 命令看到的所有环境变量，都存储在这张表中\nbash进程在运行时，内部维护着两张表：命令行参数表和环境变量表\n环境变量表：启动时从配置文件读取构建，存储所有环境变量（如PATH、HOME等 命令行参数表：每次执行命令时动态构建，存储当前命令的程序名和参数 bash执行命令的流程\nbash进程在启动时，会从配置文件中读取环境变量信息，并在内部构建环境变量表。\n当用户输入命令（如 ls -a）时\nbash首先接收这个字符串，然后按空格将其拆分成程序名和参数，构建出命令行参数表。\n接下来，bash从环境变量表中取出PATH，按照PATH中的路径顺序依次查找：\n将每个路径与程序名拼接（如 /usr/bin/ls），检查该位置是否存在可执行文件 如果找到了，bash就使用 fork() 创建子进程来执行该程序，并将命令行参数表传递给子进程 如果所有路径都查找完还没找到，就报错 Command not found 2.2环境变量从哪来？ 2.环境变量，最开始从哪里来的呢？是从系统的相关配置文件中来的\n系统给每一个用户的家目录里存在两个隐藏文件，一个是.bash_profile，一个是.bashrc\n.bash_profile要求用户去加载.bashrc，而.bashrc 会要求用户去加载 /etc/bashrc\n系统登录，bash拷贝配置文件，形成一张表\n我们把自己的路径加到配置文件中，那么登录时默认使用配置文件\n如果Linux系统中有10个用户登录，就有10个bash，这10个bash进程都要从对应的配置文件中读到bash自己的上下文里，所以每一个bash都有存在两张表，命令行参数表和环境变量表\n3.常见环境变量 常见环境变量\nPATH：指定命令的搜索路径 HOME：指定用户的主工作目录（即用户登陆到Linux系统中时,默认的目录) SHELL :当前Shell,它的值通常是/bin/bash 为什么我们输入 cd ~ 就能切换到当前用户的家目录呢？HOME环境变量表示当前用户所对应的家目录\necho $SHELL 表示用户在登录时用的是哪一个版本的shell\necho $USER\nuser\nlogname\necho $HISTSIZE\nLinux只会记录最新的HISTSIZE条历史命令\nctrl+r历史命令搜索\necho $HOSTNAME\nHOSTNAME主机名\necho $PWD\nPWD记录当前的工作路径\necho $OLDPWD\n为什么我们cd - 的时候可以回到上一次的路径下，原因是OLDPWD记录下来了\n4.获取环境变量 方式1：获取环境变量 获取的是父进程（bash）的\n环境变量可以被子进程继承\n环境变量在系统中通常具有全局特性\n方法2(推荐)：getenv getenv 会根据环境变量的名字获取环境变量的内容\n如果获取成功了，就返回环境变量内容字符串的起始地址，否则就返回NULL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; //main有参数吗？有 //最多可以有几个？3个 //是父进程传递给我们的 int main(int argc, char* argv[], char* env[]) { (void)argc; (void)argv; (void)env; char* value = getenv(\u0026#34;PATH\u0026#34;); if(value == NULL) return 1; printf(\u0026#34;PATH-\u0026gt;%s\\n\u0026#34;, value); return 0; } 如果我们想写一个程序，只有我自己可以用\n整个系统中，只有bash知道登录用户是谁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; //main有参数吗？有 //最多可以有几个？3个 //是父进程传递给我们的 int main(int argc, char* argv[], char* env[]) { (void)argc; (void)argv; (void)env; const char* who = getenv(\u0026#34;USER\u0026#34;); if(who == NULL) return 1; if(strcmp(who, \u0026#34;zhangsan\u0026#34;) == 0) { printf(\u0026#34;这是程序的正常执行逻辑\\n\u0026#34;); } else { printf(\u0026#34;只有zhangsan可以执行\\n\u0026#34;); } return 0; } 方法3：environ 全局变量 environ\n1 2 3 #include \u0026lt;unistd.h\u0026gt; extern char **environ; 环境变量表是 char* []类型的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; extern char** environ; //main有参数吗？有 //最多可以有几个？3个 //是父进程传递给我们的 int main(int argc, char* argv[]) { (void)argc; (void)argv; for(int i = θ; environ[i]; i++) { printf(\u0026#34;env[%d]-\u0026gt; %s\\n\u0026#34;， i, environ[i]); } return 0; } 5.本地变量与环境变量 环境变量具有全局特性\n本地变量\n在命令行定义本地变量\n取消本地变量也是 unset 变量名\n显示本地定义的shell变量和环境变量：set\nbash会记录两套变量：1.环境变量 2.本地变量\n本地变量不会被子进程继承，只在bash内部被使用 我们的环境变量在谁里面？bash\n1 export i 像export这种命令，我们叫做 内建命令，内建命令在执行时不需要创建子进程，而是bash自己亲自执行\nbash自己调函数，或者系统调用完成\n6. 程序地址空间初识 代码是只读的，string常量也是只读的 程序地址空间不是内存\n进程地址空间（虚拟地址空间），是一个系统概念，不是语言层的概念\n子进程和父进程都会读取全局变量，但是只有子进程修改了这个变量，子进程修改了这个变量，父进程能看到吗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int gval = 100; int main() { pid_t id = fork(); if(id == 0) { while(1) { printf(\u0026#34;子: gaval:%d, \u0026amp;gval: %p, pid:%d, ppid: %d\\n\u0026#34;, gval, \u0026amp;gval, getpid(), getppid()); sleep(1); gval++; } else { while(1) { printf(\u0026#34;父gaval: %d, \u0026amp;gval: %p, pid: %d, ppid: %d\\n\u0026#34;, gval, \u0026amp;gval, getpidC), getppid()); sleep(1); } } } } C/C++指针用到的地址，全部都是虚拟地址\n三、进程地址空间 1.引入新概念 虚拟地址空间不是物理内存\n1.1 一个进程，一个虚拟地址空间 创建进程时，要有对应的task_struct来描述进程，而每一个task_struct最终都要对应一个虚拟地址空间\n虚拟地址\n虚拟地址空间对应的宽度单位是1字节 在32位机器下，虚拟地址空间的范围是2^32^个地址 * 1字节 = 能表示的总的地址空间的容量是4GB 03GB 叫用户空间，34GB 叫内核空间 在64位机器下，虚拟地址空间的范围是2^64^个地址 用户空间和内核空间\n用户空间，用户拿到地址就可以直接访问该空间 1.2一个进程，一套页表 我们定义一个变量，该变量一定存放在内存中，同时，在虚拟地址空间上也要有对应的这个变量\n也就是任何一个变量，在内存中存在一个物理地址，在虚拟地址空间上存在一个虚拟地址，并且操作系统在每一个进程创建的时候，要为其构建一张页表\n1.3页表是用来做虚拟地址和物理地址映射的 一个进程，一套页表 ——\u0026gt;子进程也有自己的虚拟地址空间和页表\n子进程的task_struct是拷贝的父进程的，虚拟地址空间、页表也是拷贝的父进程的\n子进程对变量要进行修改？写时拷贝\n进程具有独立性，子进程会重新给这个变量开辟一块空间，并修改虚拟地址和物理地址的映射\n2.虚拟地址与进程地址空间 2.1虚拟地址空间是什么？ 操作系统让每一个进程都认为自己有4GB的物理内存（每一个进程都认为自己在独占物理内存），操作系统需要管理虚拟地址空间\n虚拟地址空间本质是一个数据结构（结构体）\n1.我们可以不加载代码和数据，只有task_struct, mm_struct，页表\n2.创建进程，先有task_struct, mm_struct等，还是先加载代码和数据？\n3.如何理解进程挂起？\n2.2如何描述虚拟地址空间 区域划分——\u0026gt;只需要确认区域的开始和结束即可\n调整区域——\u0026gt;只需要对整数变量进行加或减\n物理地址转化成为虚拟地址，虚拟地址提供给上层用户使用\n在虚拟地址空间中申请指定大小的空间\n加载程序，申请物理空间\n​\t1\u0026lt;\u0026ndash;\u0026gt;2-\u0026gt;页表进行映射\n2.3为什么要有进程地址空间 1.将地址从无序变有序\n可执行程序未来可以加载到物理内存的任意位置，通过页表的映射关系把无序的物理地址变有序（虚拟地址空间）\n2.转化过程中，也可以对你的地址和操作进行合法性判定，进而保护物理内存\n页表里面除了保存了物理地址和虚拟地址的映射关系，还有这个区域的权限\na.什么是野指针\nb.char* str = \u0026ldquo;hello world\u0026rdquo;; str = \u0026ldquo;H\u0026rdquo;\n为什么在字符常量区写入，就会崩溃？查找页表的时候，权限拦截了\n3.让进程管理和内存管理，进行一定程度的解耦合\n缺页中断\n3.地址空间的扩展知识 堆区不止一个起始虚拟地址\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/linux-process-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_b09e032a367fa6ec.png","permalink":"https://Amarantos-Arrebol.github.io/p/linux-process-basic/","title":"【Linux】03进程的概念"},{"content":"一、.进程创建 1.1fork函数初识 fork创建一个子进程\n1 2 #include \u0026lt;unistd.h\u0026gt; pid_t fork(void); 返回值：自进程中返回θ，父进程返回子进程id，出错返回-1\n进程调用fork，当控制转移到内核中的fork代码后，内核做\n分配新的内存块和内核数据结构给子进程\n将父进程部分数据结构内容拷贝至子进程\n添加子进程到系统进程列表当中\nfork返回，开始调度器调度\n子进程从fork()之后的代码开始执行\n1.2写时拷贝 fork创建的子进程要拷贝父进程的代码和数据，是浅拷贝，也就是子进程和父进程共要享数据。当子进程要修改数据的时候，子进程再重新开一块空间做修改\n为什么要有写实拷贝？\n1.减少创建时间\n2.减少内存浪费\n1.3fork常规用法 我们创建一个子进程，是希望这个子进程帮我们完成一些事情\n我们创建子进程，想让子进程帮我执行我自己代码的一部分\n让子进程通过if-else分流，让父和子各自执行后序代码的一部分\n创建子进程，希望子进程去执行全新的程序\n比如我们在命令行输入命令，其实相当于bash创建子进程，但是我们子进程不是执行bash，而是执行我们新启动的命令/程序 1.4fork调用失败 系统中有太多进程 实际用户的进程数超过了限制 创建子进程可能会失败，进程=内核数据结构+代码和数据\n情况1：操作系统创建内核数据结构失败，PCB地址空间和页表对应的物理内存申请不出来了\n情况2：加载内存失败，比如加载代码和数据失败\n二、.进程终止 创建进程是要占用系统资源的，进程终止要释放系统资源（内核数据结构和对应的代码和数据）\n僵尸进程一旦终止，它的PCB会维持，方便获取信息\n2.1进程退出的场景 代码运行完毕，结果正确 代码运行完毕，结果不正确 代码异常终止 子进程也是进程 \u0026ndash;\u0026gt; 父进程创建 \u0026ndash;\u0026gt; 子进程执行结果\n子进程执行的结果要让父进程知道\n2.2退出码 int main()\n2.2.1程序执行的三种情况 main函数也是函数，也要被调用，main函数的返回值返回给谁了？\nmain函数的返回值，通常表明你的程序的执行情况\n三种情况：\n代码运行完毕，结果正确 代码运行完毕，结果不正确 代码异常终止 通常是前两种情况\n2.2.2代码运行完毕 main函数的返回值代表什么含义？\n一般都是代码运行完毕的情况，结果正确返回0，结果错误返回非0\n为什么结果正确返回0，结果错误返回非0？\n代码运行结果不正确，要知道原因 非0有1 2 3 \u0026hellip;等不同的值，表明不同的出错原因 返回值一般是返回给父进程的，代码运行完毕后的结果由进程的退出码决定\n我们自己写的进程的父进程是bash，父进程需要得到子进程运行的结果，通过得到退出码\n如何查看退出码？echo $? 打印最近一个程序(进程)退出时的退出码\nmain函数的返回值我们叫进程退出码，退出码会写到你的进程的task_struct内部 指令也是程序 得到退出码后，我们如何知道退出码的含义？\nman strerror，strerror可以把错误码转成对应的字符串错误描述\n以fopen为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int i = 0; for(; i\u0026lt; 200; i++) { printf(\u0026#34;%d-\u0026gt;%s\\n\u0026#34;,i， strerror(i)); } return 0; } 运行结果如下： ​\n2.2.3代码异常终止 一旦代码出现异常，退出码无意义\n一旦进程出现异常，一般是进程收到了信号\n2.3 exit和_exit函数 2.3.1exit函数 main函数结束，进程结束，其它函数，只表示自己函数调用完成，返回\n进程退出的时候，除了main函数return，我们也可以在代码的任意地方调用exit()，表示进程结束，并返回给父进程bash，子进程的退出码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void func() { printfC\u0026#34;func begin!\\n\u0026#34;); exit(40); printfC\u0026#34;fun end!\\n\u0026#34;); } int main() { funC(); printfC\u0026#34;main\\n\u0026#34;); return 0; } 注意：\n在代码的任何地方调用exit，表示进程结束。1.函数后续代码不再执行 2.函数不返回\nreturn n 等同于执行 exit(n)，因为调用main的运行时函数会将main的返回值当做 exit的参数\n2.3.2_exit函数 _exit函数，终止一个调用进程，哪个进程调 _exit函数，就把哪个进程终止\nexit是C语言提供的，_exit是系统提供的\n进程如果exit退出，exit()，进程退出时，会进行缓冲区的刷新\n进程如果_exit退出，_exit()，进程退出时，不会进行缓冲区的刷新\n库函数和系统调用之间是上下层关系，即库函数会调用相关的系统调用来完成任务\n库函数封装了系统调用\n**我们之前谈论的缓冲区，应该在哪里？**库缓冲区，C语言提供的缓冲区\n**或者一定不在哪里？**一定不是操作系统内部的缓冲区\n三、.进程等待 3.1基本介绍 为什么要进程等待？\n解决内存泄漏的问题 父进程派给子进程任务，需要知道子进程运行完成的结果对还是不对 1.父进程通过进程等待的方式回收子进程资源（重要）\n2.获取子进程退出信息(可选)\n3.2wait 和 waitpid 父进程通过 接口 wait 或 waitpid 的方式来等待子进程\n3.2.1wait wait，等待任意一个退出的子进程\n父进程如果创建多个子进程，wait就会阻塞，直到其中的任意一个子进程退出\n输出型参数，需要传一个整型变量的地址，未来调成功这个函数之后，这个接口会把子进程的退出信息放到status里，让父进程拿到\nwait的返回值\n成功的时候，表示回收成功的子进程的pid，即目标Z进程的pid 失败，返回-1 等待子进程，子进程没有退出，父进程会阻塞在wait调用处（类比scanf）\n3.2.2waitpid 等待子进程，改变子进程的状态\n返回值：成功，返回子进程的pid；失败，返回-1\n参数1：pid\n​\t如果传大于0的数，表示你要等哪个子进程，就把哪个子进程的pid传进去\n​\t如果传-1，表示等待任意一个子进程\n参数2：status输出型参数\n参数3：options进行阻塞控制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; void func() { printfC\u0026#34;func begin!\\n\u0026#34;); exit(40); printfC\u0026#34;fun end!\\n\u0026#34;); } int main() { pid_t id = fork(); if(id == 0) { //子进程 int cnt = 5; while(cnt) { printf(\u0026#34;我是一个子进程，pid：%d，ppid：%d\\n\u0026#34;，getpid()，getppid()); sleep(1); cnt--; } exit(0); } sLeep(10); //父进程 /1.子进程退出 //2.子进程没退出呢? pid_t rid = waitpid(-1, NULL, 0); if(rid \u0026gt; 0) { printf(\u0026#34;wait success，rid：%d\\n\u0026#34;，rid);//rid应该等于子进程的pid } sleep(10); return 0; } 3.2.3status参数 通过status输出型参数，获取子进程的退出码(退出信息)\nstatus可以当做位图来查看，低16位的次低八位表示退出状态\n(status\u003e\u003e8)\u0026amp;0xFF\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; void func() { printfC\u0026#34;func begin!\\n\u0026#34;); exit(40); printfC\u0026#34;fun end!\\n\u0026#34;); } int main() { pid_t id = fork(); if(id == 0) { //子进程 int cnt = 5; while(cnt) { printf(\u0026#34;我是一个子进程，pid：%d，ppid：%d\\n\u0026#34;，getpid()，getppid()); sleep(1); cnt--; } exit(0); } //父进程 /1.子进程退出 //2.子进程没退出呢? pid_t rid = waitpid(id, NULL, 0); if(rid \u0026gt; 0) { printf(\u0026#34;wait success, rid: %d，status：%d\\n\u0026#34;, rid, (status\u0026gt;\u0026gt;8)\u0026amp;0xFF);//rid应该等于子进程的pid } else { printf(\u0026#34;wait failed: %d: %s\\n\u0026#34;, errno, strerror(errno)); } return 0; } 代码异常终止\nLinux系统里，存在很多信号，kill -l 可以查看Linux里所有的信号\nvim /usr/include/asm/signal.h\n没有0号信号\n一个进程一旦异常终止，那么它的status的低7位会保存异常时对应的信号编号\n没有异常呢？低7个比特位，0\n一旦低7个比特位非0，表示异常退出，退出码无意义\n1 printf(\u0026#34;wait success, rid: %d，exit code：%d, exit signal: %d\\n\u0026#34;, rid, (status\u0026gt;\u0026gt;8)\u0026amp;0xFF, status\u0026amp;0x7F); wait和waitpid是从哪拿到的信息？\n当一个子进程退出，它自己要进入僵尸，僵尸最终是把代码数据、地址空间、页表释放，但PCB不能释放\n子进程的退出信息只能放在僵尸的task_struct\nstatus我们自己做位图来查看子进程的退出码，比较麻烦，系统有对应的宏可以帮助我们直接提取\nWIFEXITED(status)：若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）\n其实就是检测信号的值为0就是真，否则就是假\nWEXITSTATUS(status)：若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）\n其实就是用宏封装了位操作\n1 printf(\u0026#34;wait success, rid: %d，exit code：%d, exit signal: %d\\n\u0026#34;, rid, WEXITSTATUS(status), status\u0026amp;0x7F); 3.3阻塞与非阻塞等待 option参数\n默认为0，表示阻塞等待\n如果设置成WNOHANG，就表示 如果子进程还没有结束，我们立即返回。我们把这种特性叫做非阻塞调用\nW：wait\nNO：不要\nHANG：如果计算机卡死了，我们输什么都没反应，那么我们就称这台计算机被夯住了\n所以，WNOHANG 表示等待的时候不要夯住，即非阻塞\n阻塞调用和非阻塞调用\n非阻塞(Non Block)调用\n张三给李四打多个电话，问李四下楼了没有\n非阻塞调用可以让等待方，做做自己的事情\n阻塞调用：一调用，必须把它调用完才会返回\n张三给李四打一次电话，让李四不要挂电话，直到李四说我要下楼了再挂断电话\nwaited返回值\n大于0，表示等待结束（子进程退了） 等于0，表示waited调用结束，但是子进程没有退出 小于0，表示等待失败 非阻塞调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main() { pid_t id = forkC); if(id == 0) { //子进程 int cnt = 3; while(1) { sleep(3); printf(\u0026#34;我是一个子进程，pid：%d，ppid：%d\\n\u0026#34;，getpidC)，getppid()); sleep(1); cnt--; } exit(10); } //父进程 while(1) { int status = 0; pid_t rid = waitpid(id, \u0026amp;status, WNOHANG); if(rid \u0026gt;0) { printf(\u0026#34;wait success，rid：%d，exit code:%d，exit signal：%d\\n\u0026#34;，rid，WEXITSTATUS(status)，status\u0026amp;ox7F);//rid应该等于子进程的pid break; } else if(rid == 0) { printf(\u0026#34;本轮调用结束，子进程没有退出\\n\u0026#34;); sleep(1); } else { printf(\u0026#34;等待失败\\n\u0026#34;); break; } } } 非阻塞调用可以让等待方，做做自己的事情\n如何让父进程做其它事情呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; //函数指针类型 typedef void (*func_t)(); #define NUM 5 func_t handlers[NUM + 1]; //任务 void DownLoad() { printf(\u0026#34;我是一个下载的任务...\\n\u0026#34;); } void Flush() { printf(\u0026#34;我是一个刷新的任务...\\n\u0026#34;); } void Log() { printf(\u0026#34;我是一个登录的任务...\\n\u0026#34;); } //注册 void registerHander(func_t h[], func_t f) { int i = 0; for(; i \u0026lt; NUM; i++) { if(h[i] == NULL] break; } if(i == NUM) return; h[i] = f; h[i+1] = NULL; } int main() { registerHander(handlers, DownLoad); registerHander(handlers, Flush); registerHander(handlers, Log); pid_t id = forkC); if(id == 0) { //子进程 int cnt = 3; while(1) { sleep(3); printf(\u0026#34;我是一个子进程，pid：%d，ppid：%d\\n\u0026#34;，getpid(），getppid()); sleep(1); cnt--; } exit(10); } //父进程 while(1) { int status = 0; pid_t rid = waitpid(id, \u0026amp;status, WNOHANG); if(rid \u0026gt; 0) { printf(\u0026#34;wait success， rid:%d， exit code: %d， exit signal:%d\\n\u0026#34;,rid, WEXITSTATUS(status)， status\u0026amp;ox7F);//rid应该等于子进程的pid break; } else if(rid == 0) { //函数指针进行回调处理 int i = 0; for(; handlers[il; i++) { handlers[i](); } printf(\u0026#34;本轮调用结束，子进程没有退出\\n\u0026#34;); sleep(1); } else { printf(\u0026#34;等待失败\\n\u0026#34;); break; } } return 0; } 四、进程程序替换 fork（）之后，父子各自执行父进程代码的一部分如果子进程就想执行一个全新的程序呢？\n进程的程序替换来完成这个功能！\n程序替换是通过特定的接口，加载磁盘上的一个全新的程序(代码和数据)，加载到调用进程的地址空间中！\n4.1快速见一见效果 程序替换的接口 execl\n通过我们自己写的程序，可以把系统指令跑起来\n4.2进程替换原理 - fork 进程=内核数据结构+代码和数据\n当我们的程序跑起来后，执行的是我们自己的代码，但是当执行到 execl 这个函数时，新的程序(代码和数据)会覆盖当前进程的代码和数据（没有创建新进程）\n在程序替换的过程中，并没有创建新的进程\n4.3认识全部接口 接口1\n1 int execl(const char* path, const char* arg, ...); // ...是可变参数 要执行谁 要怎么执行它 为什么没有影响父进程呢？\n进程具有独立性 数据和代码都要发生写实拷贝 程序要跑，就是进程，只要是进程，就能进行程序替换\n接口2\n1 int execlp(const char * file, const char* arg, ...); p \u0026mdash; PATH，只能执行系统指令\nfile 只需要告诉需要执行的文件名，因为execlp会自动在环境变量中查找指定的命令\n接口3\n1 int execv(const char* path, char* const ) 接口4\n1 2 int execvpe(const char* file, char* const argv[], char* const envp[]); // 环境变量 五、自主Shell命令行解释器 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/linux-process-control/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_b09e032a367fa6ec.png","permalink":"https://Amarantos-Arrebol.github.io/p/linux-process-control/","title":"【Linux】04进程控制"},{"content":"Linux作业 01 基础指令 题目1：\nA 全称Linux extended file system, extfs,即Linux扩展文件系统，ext2为第二代\nD XFS一种高性能的日志文件系统，2000年5月，Silicon Graphics以GNU通用公共许可证发布这套系统的源代码，之后被移植到Linux 内核上。XFS 特别擅长处理大文件，同时提供平滑的数据传输\nE UFS是UNIX文件系统的简称，它来源于4.3Tahoe发行版中提供的BSD Fat Fast File System（FFS）系统，属于FFS的演化版本\nABCD\n题目2:\nuname -r 查看linux内核版本信息\nvmstat 报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息\nsar\t主要帮助我们掌握系统资源的使用情况，特别是内存和CPU的使用情况\nstat\t用于显示文件的状态信息\nA uname -f\n题目3:\n​ A\tcat 打印文件内容到终端显示\n​ B\tmore\t分页显示文件内容，但是通常向上翻页不好使\n​ C\tless\t分页显示文件内容，可以灵活上下移动光标和翻页\n​ D\tmenu\t没有这个指令（至少centos7上默认没有这个命令）\nC\n题目4:\n​ A\t-m\t在创建目录的同时设置权限\n​ B\t-d\t没有这个选项\n​ C\t-f\t没有这个选项\n​ D\t-p\t在创建多层级目录的时候若上级目录不存在则创建\nD\n题目5:\ngrep:Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，\n并把匹配的行打印出来。grep全称是Global Regular Expr ession Print，表示全局正则表达式版本，它的使用权限是所有用户。\ngrep选项中，-E选项可以用来扩展选项为正则表达式；\n\\$表示匹配文件末尾，字符需要在$之前表示以字符结尾 a$表示以a结尾 ​\t^表示匹配文件起始，字符需要在 ^之后表示以字符起始 ^a表示以a起始\nD\n题目6:\n​ A\ttop 查看cpu资源使用状态\n​ B\tnetstat\t查看网络连接状态\n​ C\tfree\t查看内存资源状态\n​ D\tdf\t查看磁盘分区资源状态\nA\n题目7:\nA\trm *.c *通配符，表示匹配任意字符任意次\nB\tfind . -name \u0026ldquo;*.c\u0026rdquo; -maxdepth 1 | xargs rm\n​ find . -name \u0026ldquo;*.c\u0026rdquo; -maxdepth 1 找到当前目录下.*结尾的文件，目录深度为1\n​ xargs是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令，用于很多不支持|管道来传递参数的命令\n​\t相当于将前边命令的执行结果，也就是查找到的文件名，传递给后边的rm指令进行删除\nC\tfind . -name \u0026ldquo;*.c\u0026rdquo; | xargs rm 没有进行深度控制，删除的不仅是当前目录下的文件，会将子目录下的文件也删除\nD\t以上都不正确\nAB\n02Linux权限 题目1：\nC\n题目2：\nC\n题目3：\nB\n题目4：\nA\n03yum理解 题目1：\nAC\n题目2：\nABC\n04make/makefile 题目1：\nC\n题目2：\nA\n题目3：\nA\n题目4：\nABC\n题目5：\nBD\n05冯诺依曼理解等 题1： A\tCPU 运算器与控制器\nB\tCache\t缓存（一种技术）\nC\tRAM\t内存（存储器）\nD\tROM\t磁盘（输入输出设备）\n题2： D\n计算机就是为了完成指定的数据处理，而通过指令按指定流程完成指定功能，指令的合集就是一段程序。\n说白了计算机就是按照指定的指令执行流程完成对指定数据的处理\n题3： 系统调用是操作系统向上层提供的用于访问内核特定功能的接口。\nA正确，应用程序通过系统调用将自己需要完成的功能传递给内核，进行执行完成 B错误，系统调用的运行过程是在内核态完成的，操作系统并不允许用户直接访问内核，也就是说用户运行态并不满足访问内核的权限。 C正确，因为系统调用就是想上层提供用于完成特定内核服务或功能的。 D正确， E正确，用户只需要将自己的请求以及数据通过系统调用接口传递给内核，内核中完成对应的设备访问过程，最终返回结果正确 F正确，系统向上层提供系统调用接口用于访问内核服务或功能的很大原因也是因为这样可以最大限度的保护内核的稳定运行。 题4： D\n库函数是用户对系统调用接口的进一步封装接口 printf函数是glibc中封装的用于实现格式化输出的接口 scanf函数是glibc中封装的用于实现格式化输入的接口 fgetc函数是glibc中封装的用于实现从输入流中获取字符的接口 read是系统提供的用于从输入设备获取数据的接口 print_s以及scan_s这两个函数不存在，至少在C语言的常见典型的跨平台移植代码库中不存在。 题5： A\t僵尸进程指的是进程退出后不会完全释放资源，会造成系统资源泄漏；\nB\t孤儿进程在父进程退出后，父进程成为init进程，进程退出，孤儿进程的资源将被init进程释放\nC\t操作系统通过pcb实现对程序运行调度控制\nD\tfork系统调用通过复制父进程创建一个子进程，父子进程数据独有，代码共享（在数据不发生改变的情况下父子进程资源指向同一块物理内存空间（写时拷贝技术））\n题6： A\t所有cpu寄存器的内容\tcpu上正在处理的数据\nB\t全局变量 程序内的数据（并不一定正在被处理）\nC\t页表指针 程序切换时会将页表起始地址加载到寄存器中\nD\t程序计数器 下一步程序要执行的指令地址\n题7： 程序是静态的指令集合，保存在程序文件中，\n进程是程序的一次运行过程中的描述。\n作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合\n根据以上概念理解：\nA选项错误，因为一个程序可以同时运行多次，也就有了多个进程 B选项错误，因为一个作业任务的完成可由多个进程组成，且必须至少由一个进程组成 C选项错误，因为程序是静态的，而进程是动态的 D选项正确 题8： B\n进程是操作系统对于程序运行过程的描述，而这个描述学名叫做进程控制块-PCB，它是操作系统操作系统管理以及调度控制程序运行的唯一实体。\n根据进程的理解分析：\nA选项错误，因为进程ID只是进程的标识符，是系统能够找到特定进程的标识而已 C选项错误，进程管理器只是对大量PCB进行管理的一个程序而已 D选项错误，进程本质上来说没有名字，它有所调度管理运行的程序的名称，它的标识是进程ID，可以理解进程ID是它的名字 因此只有B选项正确，在系统角度看来，进程就是对于程序运行的描述，就是PCB进程控制块。 06孤儿进程的理解等 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/linux-exercises/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%9F%8E%E5%B8%82-%E5%A4%95%E9%98%B3_hu_b09e032a367fa6ec.png","permalink":"https://Amarantos-Arrebol.github.io/p/linux-exercises/","title":"【Linux】Linux作业"},{"content":"基础语法 说明：标题带*号的为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code 本地生效, 在大多数平台上并不认可.\n1. 标题[用 \u0026ldquo;#\u0026rdquo; ] 1 2 3 4 5 6 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 在Typora中建议开启严格模式\t模式，即不应为#标题，应为# 标题\n井号和标题之间应该用空格隔开，使得Markdown语法在其它文本编辑器上兼容\n2. 强调[用 “**“ 或 ”__“ 包围] 1 2 **强调的文字会被加粗** __强调的文字用两条下划线包围__ 快捷键：选中想要强调的文字，按下ctrl+B\nE.G.\n我是被强调的文字\n3. 斜体[用 \u0026ldquo;*\u0026rdquo; 或 \u0026ldquo;_\u0026rdquo; 包围] 1 2 *变斜体用一个*号包围* _变斜体用一个下划线包围_ 快捷键：选中想要强调的文字，按下ctrl+I\n（补充：斜体并加粗强调，用\u0026quot;***\u0026ldquo;或\u0026rdquo;___\u0026ldquo;包围）\nE.G.\n我是斜体文字\n4. 删除线[用\u0026rdquo;~~\u0026ldquo;包围] 1 ~~这段文字删掉~~ E.G.\n这段文字删掉\n5. *高亮[用\u0026rdquo;==\u0026ldquo;包围] (注意：此为扩展语法)\n1 \u0026lt;mark\u0026gt;我被高亮显示了\u0026lt;/mark\u0026gt; 更通用的是\n1 \u0026lt;mark\u0026gt;我被高亮显示了\u0026lt;/mark\u0026gt; E.G.\n我被高亮显示了\n我被高亮显示了\n6. 代码[用\u0026rdquo;`\u0026ldquo;包围] 1 \u0026#39;sudo rm -rf /*\u0026#39; E.G.\nsudo rm -rf /*（没事别乱敲这个）\n7. 代码块[按三个\u0026rdquo;`\u0026ldquo;并敲回车] 1 2 3 4 5 6 7 8 9 10 11 ```` C ​``` //这里就可以开始输入你的代码了 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello world\\n\u0026#34;); return 0; } ​``` ​```` （如果想要显示行数的话，一般在Typora的偏好设置中勾选显示行号）\n代码块里可以选择语言，四个\u0026rdquo;`\u0026ldquo;加对应的语言\n8. 引用[\u0026quot;\u0026gt;\u0026rdquo; 加空格] 1 2 \u0026gt; 我是被引用的文字 \u0026gt;\u0026gt; 引用可以嵌套使用 E.G.\n我是被引用的文字\n引用可以嵌套\n9.无序列表[\u0026quot;_\u0026quot; 或 \u0026ldquo;+\u0026rdquo; 加空格] 1 2 - 一颗枣树 + 一颗梨树 可在Typora设置中调整补全的符号，敲回车后按下Tab会缩进一级，\n缩进一级后按两下回车就会继续使用列表\nE.G.\n一颗枣树 两颗枣树 一颗是幼苗 一颗是成年树 三颗枣树 10. 有序列表[数字加 “.” 加空格] 1 2 3 4 今日待办 1. 待办1 2. 待办2 3. 待办3 敲回车会自动补齐，敲回车后按下Tab会缩进一级\nE.G.\n今日待办\n待办1 待办2 分支1 分支2 待办3 11. *上标[用\u0026quot;^\u0026ldquo;包围] （注意：此为扩展语法）\n1 C语言中int的上限是 2^31^ - 1 = 2147483647 E.G.\nC语言中int的上限是 2^31^ - 1 = 2147483647\n12. *下标[用\u0026rdquo;~\u0026ldquo;包围] （注意：此为扩展语法）\n1 H~2~O 是剧毒 ！ E.G.\nH2O 是剧毒！\n13. *注释[\u0026rdquo;[^]\u0026quot;] （注意：此为扩展语法）\n1 2 \u0026gt; 这是正文[^1] [^1]: 这是注释语句 E.G.\n这是正文1\n14. 链接[常用 \u0026ldquo;[文本] (链接)\u0026rdquo; ] 1 2 [github官网](https://github.com/) [基础语法：8. 引用](#8. 引用[\u0026#34;\u0026gt;\u0026#34; 加空格] ) 支持网页链接与文内跳转，按住ctrl并单击鼠标左键，即可跳转\nE.G.\ngithub官网\n[基础语法：8. 引用](#8. 引用[\"\u003e\" 加空格] )\n15. 任务列表[ \u0026ldquo;-空格[空格]\u0026rdquo; 再加空格] 1 2 3 4 ToolList: -[] 补回放 -[] 学英语 -[x] 起床 用x代替[]中的空格，来勾选任务列表。在Typora中，可以直接鼠标左键单击勾选框\nE.G.\nToolList:\n补回放 学英语 起床 16. 表格[用\u0026quot;|\u0026ldquo;绘制表格边框] 1 2 3 4 | 学号 | 姓名 | 年龄 | | :--- | :---: | ---: |(引号的位置代表着 左对齐 居中对齐 右对齐) |114514|田所|24| |1919810|浩三|25| 第一行为表头，并由第二行分割线决定对齐方式与长度，第三行及之后即表格数据\nE.G.\n学号 姓名 年龄 114514 田所 24 1234567 张三 25 17. 图片[直接拖进来或者复制粘贴] 1 ！[图片](图片的位置) 在Typora的设置里可以更改图片的存储方式\n18. 分割线[按三个 \u0026ldquo;*\u0026rdquo; 或 \u0026ldquo;-\u0026rdquo; 或\u0026rdquo;_\u0026ldquo;并敲回车] E.G.\n19. Emoji表情[\u0026rdquo;:\u0026quot;] （注意：英文输入为扩展语法）\n1 2 3 4 :sweat_smile: :drooling_face: :clown_face: //敲回车或者鼠标点击，后置的:一般不需要手动输入 这个功能需要记得各个Emoji的英文名\nE.G.\n:sweat_smile: :drooling_face: :clown_face:\n进阶教程 1.目录[自动生成] 1 [TOC] //此为Typora特有的，如本文的开头 如果使用VS Code 搭配Markdown All in One 扩展，可在VS Code的命令面板\n（即 VS Code Command Palette）输入 create Table of Contents自动生成目录\n且可在扩展设置中细调目录参数\n2. 内联 HTML 代码[用 \u0026ldquo;\u0026lt;\u0026gt; \u0026lt;/\u0026gt;\u0026rdquo; 包围] 1 2 3 4 5 6 \u0026lt;div style=\u0026#34;text-align:center\u0026#34;\u0026gt; \u0026lt;font style=\u0026#34;color\u0026#34;:red\u0026gt; HTML中的文字 \u0026lt;/font\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;center\u0026gt;文字居中\u0026lt;/center\u0026gt; \u0026lt;u\u0026gt;下划线\u0026lt;/u\u0026gt; 可以把Markdown当做HTML来写\n同时，.md文件可以直接导出一个网页\n下划线的快捷键：ctrl+u\nE.G.\nHTML中的文字 文字居中 下划线 3. 内联$\\LaTeX$ 公式[用 \u0026ldquo;$\u0026rdquo; 包围] （注意：部分编译器会不识别部分符号）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $\\LaTeX$ 是最好用的论文排版语言! 不信你看! $a^n+b^n=c^n$ $$ %\\usepackage{unicode-math} \\displaystyle \\ointctrclockwise\\mathcal{D}[x(t)] \\sqrt{\\frac{\\displaystyle3\\uppi^2-\\sum_{q=0}^{\\infty}(z+\\hat L)^{q} \\exp(\\symrm{i}q^2 \\hbar x)}{\\displaystyle (\\symsfup{Tr}\\symbfcal{A}) \\left(\\symbf\\Lambda_{j_1j_2}^{i_1i_2}\\Gamma_{i_1i_2}^{j_1j_2} \\hookrightarrow\\vec D\\cdot \\symbf P \\right)}} =\\underbrace{\\widetilde{\\left\\langle \\frac{\\notin \\emptyset} {\\varpi\\alpha_{k\\uparrow}}\\middle\\vert \\frac{\\partial_\\mu T_{\\mu\\nu}}{2}\\right\\rangle}}_{\\mathrm{K}_3 \\mathrm{Fe}(\\mathrm{CN})_6} ,\\forall z \\in \\mathbb{R} $$ 用$包围为单条公式，按下两个$并敲回车即生成公式块\nE.G.\n$\\LaTeX$ 是最好用的论文排版语言! 不信你看!\n$a^n+b^n=c^n$\n$$ %\\usepackage{unicode-math} \\displaystyle \\ointctrclockwise\\mathcal{D}[x(t)] \\sqrt{\\frac{\\displaystyle3\\uppi^2-\\sum_{q=0}^{\\infty}(z+\\hat L)^{q} \\exp(\\symrm{i}q^2 \\hbar x)}{\\displaystyle (\\symsfup{Tr}\\symbfcal{A}) \\left(\\symbf\\Lambda_{j_1j_2}^{i_1i_2}\\Gamma_{i_1i_2}^{j_1j_2} \\hookrightarrow\\vec D\\cdot \\symbf P \\right)}} =\\underbrace{\\widetilde{\\left\\langle \\frac{\\notin \\emptyset} {\\varpi\\alpha_{k\\uparrow}}\\middle\\vert \\frac{\\partial_\\mu T_{\\mu\\nu}}{2}\\right\\rangle}}_{\\mathrm{K}_3 \\mathrm{Fe}(\\mathrm{CN})_6} ,\\forall z \\in \\mathbb{R} $$4. *网络图床 可以将Markdown里用到的图片直接加载到服务器上，共享后，所有人都可以拿到那张图片\n分享一个 Typora 搭配腾讯云COS/阿里云OSS图床的例子. 新用户免费试用6个月, 另外还可选择七牛云或者路过图床.\n5. *Typora的常用快捷键 按键 效果 按键 效果 Ctrl + D 选中当前词 Ctrl + L 选中当前句/行 Ctrl + E 选中当前一整段 Ctrl + F 搜索当前选中 Ctrl + B 加粗当前选中 Ctrl + H 替换当前选中 Ctrl + I 倾斜当前选中 Ctrl + U 下划当前选中 Ctrl + K 将当前选中生成链接 Ctrl + J 滚动屏幕将选中滚至顶部 Ctrl + W 关闭当前窗口 Ctrl + N 打开新窗口 Ctrl + O 打开文件 Ctrl + P 搜索文件并打开 Ctrl + 回车 表格下方插入行 Ctrl + , 打开偏好设置 Ctrl + . 切换全角/半角标点 Ctrl + / 切换正常/源代码视图 Ctrl + Shift + - 缩小视图缩放 Ctrl + Shift + + 放大视图缩放 教程2 Typora可以自己定义CSS\n比如这样\n在偏好设置中，打开主题文件，更改里面的CSS文件，就可以在任意地方打开都是该样式\n这时注释语句\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-markdown/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%AD%A4%E7%8B%AC%E6%91%87%E6%BB%9A-%E8%93%9D%E8%89%B2_hu_5bd2ee9e38d81299.png","permalink":"https://Amarantos-Arrebol.github.io/p/learning-markdown/","title":"【Markdown语法】Md语法学习"},{"content":"一、C++入门 0.C++历史 C++是在C语言的基础上进行扩展的，C++完全兼容C\n1. C++入门 1.1 打印hello world C++的源文件的后缀名为.cpp 是c plus plus 的缩写，意思是C++是C的进阶\n首先，我们先写一个C++程序，在屏幕 上打印：hello world\n1 2 3 4 5 6 7 8 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 在DevC++中\nF9 编译，F10运行，F11编译运行\n1.2 main 函数 main函数是程序的入口，也就是不管你前面写了多少行代码，运行时都是从main函数开始执行\nmain函数也叫主函数\nint 表示main函数最后会返回一个int类型的值（int也就是整型），对应{ } 中的 return 0 ，也就是\n我们的main函数如果正常运行，最终会返回0\nmain函数的固定模版\n1 2 3 4 5 int main() { return 0; } 注意：\nmain函数是程序的入口\nmain函数在一个项目中有且只能有一个，也就是程序的入口只能有一个\n一个项目中允许有多个源文件(.cpp)，但是如果你在多个源文件中写了main函数，那么\n程序到底执行哪一个呢？这样就会有问题\n1.3 字符串 在C/C++中，我们用单引号括起来一个字符，表示字符字面值，双引号括起来多个字符，表示字符串\n1 2 3 4 5 6 7 8 9 //字符 \u0026#39;a\u0026#39;; \u0026#39;1\u0026#39;; \u0026#39;x\u0026#39;; //字符串 \u0026#34;abc\u0026#34;; \u0026#34;hello world\u0026#34;; \u0026#34;\u0026#34;;//空字符串 \u0026ldquo;hello world\u0026rdquo; 被双引号包裹，所以是字符串\n1.4 头文件 在我们写的第一个C++程序中，第一行是下面这样的\n1 #include\u0026lt;iostream\u0026gt; #include\u0026lt;\u0026gt;\n#include\u0026lt;\u0026gt;表示包含，#include\u0026lt;iostream\u0026gt;也就是说包含一个文件，这个文件叫iostream\n我们把#include\u0026lt;\u0026gt;这种形式的叫头文件\niostream\niostream是intput output stream的缩写，是输入输出流的头文件\n程序中只要涉及输入输出操作的都要包含这个头文件\n头文件\n一个头文件可以理解为一个工具箱，工具箱中包含了很多的工具，想要使用这些工具\n就得包含头文件\nC++手册\n注意\nC语言中的头文件扩展名是.h，C++自己的头文件没有扩展名，C++对老式C的头文件\n保留了扩展名.h\n有些C的头文件被转换成C++头文件，这些文件名被重命名，去掉了.h扩展名，并在\n文件名的前面加上了前缀c 表示来自C语言\n例如C语言中和数学有关的头文件名字是math.h，在C++中就是cmath\n但是有时头文件的C语言版本和C++版本相同，而有时候新版本做了一些修改\n头⽂件类型 约定 实例 说明 C++旧式⻛格 以.h结尾 \u0026lt;iostream.h\u0026gt; C++程序可以使⽤，⼀些新的IDE可能不再⽀持 C旧式⻛格 以.h结尾 \u0026lt;math.h\u0026gt; C、C++程序可以使⽤ C++新式⻛格 没有扩展名 C++程序可以使⽤，使⽤namespace std 转换后的C 加上前缀，没有扩展名 C++程序可以使⽤，可能包含不是C的特性 1.5cin和cout初识 cout是标准输出流对象，针对的是控制台，也就是屏幕，它要把一些信息打印到屏幕上\ncin是标准输入流对象，\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int num;//num是一块空间 ，可以存放一个整数 cin \u0026gt;\u0026gt; num;//输入操作，输入一个整数 存放到num中 cout \u0026lt;\u0026lt; num;//输出操作，将num里的值打印到屏幕上 return 0; } cin和cout是全局的流对象，cin负责输入数据，cout负责输出数据 endl是C++中一个特殊的操作符，效果是换行和刷新缓冲区，使用时必须包含在iostream头文件 \u0026lt;\u0026lt;是流插入运算符和cout配合使用。\u0026gt;\u0026gt;是流提取运算符，和cin配合使用 C++的输入输出可以自动识别变量类型，而C语言的printf/scanf需要手动输出格式 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { float f; cin \u0026gt;\u0026gt; f;//自动识别f的类型，识别为浮点数 cout \u0026lt;\u0026lt; f; return 0; } 细节\ncin 是⽀持连续读入几个数值的 cout 也是⽀连续输出几个数值的 1.6 命名空间 在我们写的第一个C++程序中有这样一段代码using namespace std;，意思是使用名字空间std\n其中namespace是命名空间的关键字，std就是空间的名字\n那么什么是名字空间呢？为什么要有名字空间呢？\n在C++程序中，如果我们是几个人一起开发，那么可能一个人在程序中定义了一个变量，另一个\n也想用这个变量名，那么就会造成命名冲突。如果我们使用命名空间，让每个人都在自己的命名空间\n中写代码，相当于做了隔离，需要使用的时候，我们就指定命名空间。\n所以，命名空间就是解决命名冲突的问题\nstd\n是C++标准库的名字空间名，C++将标准库的定义实现都放到这个命名空间中，当我们需要使用\n标准库中的内容时，就需要加上： using namespace std\n1.7 注意事项 编写C++代码的语法细节\n注意main函数的写法，大括号的匹配，中英文标点符号的使用，包含头文件 OJ - online judge 在线判题\n算法竞赛 \u0026ndash; OJ\nOI型 \u0026ndash; 从0开始写代码，包括main函数，编写所有代码，有输入输出 核心代码模式 - 编写核心代码 OJ题⽬输出的结果有严格的检查，代码输出的结果必须和题⽬要求的统⼀才是可以的。\n2.数据类型 数据类型可以用来描述生活中的各种数据。\n类型，就是相似数据所拥有的共同特征。编译器只有知道了数据类型，才知道怎么操作数据\n简单的数据类型分为：字符型，整型，浮点型，布尔型\n2.1 字符型 C/C++中，我们通常把字符用单引号引起来，例如 'a' ，1，@，我们给他们抽象出\n一种数据类型，就是字符型 char\n1 char ch = \u0026#39;w\u0026#39;; ASCII\n我们知道，在计算机中所有的数据都是以二进制的形式存储的，那么字符在内存中是\n怎样以二进制方式存储的呢？我们把每个字符编一个二进制序列，这个就叫编码。\n美国国家标准学会（ANSI）出台了一个标准ASCII编码\n字符A~Z的ASCII码值从65~90 字符a~Z的ASCII码值从97~122 大小写字符的ASCII码相差32 数字字符0~9的ASCII码值为10 换行字符\\n的ASCII码值为48~57 注意：ASCII码值从0~31 这32个字符是不可打印字符，无法在屏幕上观察\n2.2 整型 short int 短整型\nint 整型\nlong int 长整型\nlong long int 更长的整型\n1 2 3 4 5 6 7 short s = -10; short int s2 = 10; int n1 = 100; long l = 101; long int l2 = 102; long long int ll2 = 1001; 2.3 浮点型 float 单精度浮点型\ndouble 双精度浮点型\nlong double 更长的双精度浮点型\n细节：\n编译器默认会认为小数是double类型的，如果想定义浮点类型的小数，需要在后面加f 1 2 3 float f = 5.5f;// 编译器默认认为是double类型 double d = 3.14; long double ld = 5.5; C/C++中小数的书写形式\n1 2 3 4 5 3.14; // 编译器会默认认为是doble类型 3.14f; //编译器会认为是float类型 1e5; //科学计数法的形式，1*10^5 1e5+10; //1*10^5+10 1.23e5+10; //1.23*10^5+10 2.4 布尔型 布尔类型bool，这种类型只能用来表示true(真)或false(假)。\n在C/C++中，0表示假，非0表示真\n2.5 signed与unsigned signed和unsigned是用来修饰整型和字符的\nsigned修饰一个类型后，就可以表示正负数，比如：温度\nunsigned修饰一个类型后，就只能表示0和正数，比如：年龄\n变量声明为unsigned的后，同样长度的内存能够表示的最大整数值，增大了一倍\n比如16 位的signed short int 的取值范围是-32768~32767，最大是32767；\n而unsigned short int的取值范围是0~65535\n整型默认是有符号的，如果想要表示无符号的整型，需要用unsigned修饰 1 2 int a;// 等价于有符号的，即signed int a; unsigned int b; // 无符号的 char是signed cahr 还是 ungned char 取决于编译器\n大部分编译器上char是有符号的char\n2.6 数据类型的长度 每一种数据类型都有自己的长度，使用不同的数据类型，能够创建出长度不同的变量\n2.6.1 sizeof操作数 sizeof是一个关键字，也是操作符，专门用来计算特定数据类型长度的，单位字节 sizeof操作符的操作数可以是类型，也可以是变量名或表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 100; //sizeof 计算结果的单位是字节 cout \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; // 4 return 0; } sizeof计算的结果是无符号整型size_t类型的，该类型可能是unsigned int、unsigned long\n、unsigned long long，具体取决于编译器\nsizeof后面跟的如果是变量或表达式时，可以不跟小括号\n1 2 3 int a = 100; cout \u0026lt;\u0026lt; sizeof a \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof a+4.0 \u0026lt;\u0026lt; endl; // 8 2.6.2 各种数据类型的长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(bool) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(long) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(long long) \u0026lt;\u0026lt; endl; // 8 cout \u0026lt;\u0026lt; sizeof(float) \u0026lt;\u0026lt; endl; //4 cout \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; endl; //8 cout \u0026lt;\u0026lt; sizeof(long double) \u0026lt;\u0026lt; endl; // 16 return 0; } C/C++标准规定：sizeof(long) \u0026gt;= sizeof(int)\n2.6.3 各种类型的取值长度 类型 取值范围 速记最⼩值 速记最⼤值 char -128~127 CHAR_MIN- 27 CHAR_MAX 27 - 1 unsigned char 0~255 0 UCHAR_MAX 28 -1 short -32878 ~ 32767 SHRT_MIN - 2^15 SHRT_MAX2^15 -1 unsigned short 0 ~ 65535 0 USHRT_MAX2^16-1 int -2147483648 ~2147483647 INT_MIN-2^31 INT_MAX2^31-1 unsigned int 0 ~ 4294967295 0 UINT_MAX2^32-1 long -2147483648 ~ 2147483647 LONG_MIN-2^31 INT_MAX2^31-1 unsigned long 0 ~ 4294967295 0 ULONG_MAX2^32-1 long long -9223372036854775808~ 9223372036854775807 LLONG_MIN- 2^63 LLONG_MAX2^63-1 unsigned long long 0~18446744073709551615 0 ULLONG_MAX2^64-1 为了代码的可移植性和方便记忆，需要知道某种整数类型的极限值\nlimits.h文件中说明了整型类型的取值范围。（C++中头文件为\u0026lt;climits\u0026gt;）\nfloat.h这个头文件中说明了浮点型类型的取值范围。（C++中头文件名为\u0026lt;cfloat\u0026gt;）\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;climits\u0026gt; int main() { cout \u0026lt;\u0026lt; CHAR_MIN \u0026lt;\u0026lt; endl; //-128 cout \u0026lt;\u0026lt; CHAR_MAX \u0026lt;\u0026lt; endl; //127 return 0; } 2.6.4 typedef 有些类型的名字比较复杂，可以用typedef给类型起别名\n1 typedef 旧类型名 新类型名 例如我们可以给unsigned long long起个别名为ull\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; typedef unsigned long long ull; int main() { unsigned long long num1; ull num2; return 0; } 对于复杂的类型都是可以重命名的\n对于复杂的指针类型 对于复杂的自定义类型 一道练习 https://www.luogu.com.cn/problem/B2018\n注意:\n题目中说的是”输入一个整数，即字符的ASCII码值“，\n如果我们使用cin的话就只能用一个int类型的变量来接收输入的值，\n因为对于cin来说，它会根据变量的类型来读取数据。\n如果用char类型的变量来接收输入的值，那么cin就会认为它只需要读一个字符。\n例如我们输入的是97，那么cin就会只读9\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { //输入 int num; // 使用int来接收 cin \u0026gt;\u0026gt; num; //输出 char ch = num; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } 3.变量和常量 3.1 变量的创建 变量就是值是可以变化的，常量就是值是固定的\n变量创建的语法：数据类型 变量名\n1 2 3 int age; double weight; unsigned int height; 变量命名的规则\n变量只能由数字、字母、下划线组成。 变量名不能以纯数字开头，也不能包含特殊字符，如空格、连字符等 变量名不能直接用语言的关键字，例如 int char 这样创建变量是非法的 变量名严格区分大小写，例如myVariable和myvariable被视为两个不同的变量 变量名应该具有实际意义，并且简短明了 3.2 变量的初始化 在创建变量的同时给变量赋值，就叫变量的初始化\n3.3 变量的分类 全局变量：在大括号外面定义的变量\n局部变量：在大括号内部定义的变量\n当局部变量和全局变量同名且都可以使用的时候，局部变量会优先被使用\n但是如果就是想使用全局的变量，可以在变量前加上::\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int m = 100; // 全局变量 int main() { int m = 1; // 局部变量 { int a = 10; // 局部变量 cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; // 1 ，局部优先 cout \u0026lt;\u0026lt; ::m \u0026lt;\u0026lt; endl; // 100 } cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; ::m \u0026lt;\u0026lt; endl; // 100 return 0; } 在定义的时候如果没有指定初始值，\n那么，全局变量的值通常会被初始化为0，局部变量的值是随机的\n建议：局部变量初始化\n在竞赛中：\n能使用全局变量，一般直接使用全局变量，因为\n变量不需要初始化，因为默认会初始化为0，这样写会比较快 很多时候，会避免传参，因为全局变量到处都可以使用 但是在企业里软件开发的工程中一般建议：能使用局部变量的尽量少使用全局变量。\n因为企业级开发，代码量比较大，全局变量在任意地方都可以使用，这样就不可控了\n3.4常量 字面常量 #define定义的常量 语法：#define 常量名 内容\n注意后面没有分号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; #define M 22 #define CH \u0026#39;X\u0026#39; #define PI 3.14159 int main() { //M = 33; // error int m = M; cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; // 22 cout \u0026lt;\u0026lt; M \u0026lt;\u0026lt; endl; // 22 cout \u0026lt;\u0026lt; CH \u0026lt;\u0026lt; endl; // x cout \u0026lt;\u0026lt; PI \u0026lt;\u0026lt; endl; // 3.14159 return 0; } 常量的值不能被修改\n细节：\n使用#define定义常量的时候是不关注类型的，只关注常量的名字叫啥，常量的值是啥\n编译器在处理常量的时候就是直接替换，在出现常量名字的地方，统统替换成常量的内容\n所以，一定要注意#define定义的常量中能否有分号\nconst定义的常量 使用const来定义的常量，这种常量会有具体的类型，比#define定义常量更严谨\n语法：const 类型 常量名 = 常量值;\n注意：\n常量在创建的时候最好给它一个值，因为后面再想给它值就给不进去了\n因为常量不能被修改。\nconst定义常量后面有分号\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { const int n = 10; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; n = 20; // error cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 习惯上，常量的名字一般会全是大写\n使用const常量的好处\n增加了程序的可读性。PI比3.14159更加容易理解和书写、使用\n增加了程序的可维护性。如果改变常量的值，只要在定义的部分修改，使用的地方也就\n随之改变了\n常量是不能被修改的\n4.算术运算 4.1算术操作符 操作符也被叫做运算符\n算术操作符有：+ - * / %\n这些操作符都是双目操作符，也就是有两个操作数\n7 + 2\n操作数为：7和2\n操作符为：+\n需要注意的除号/和取余%\n1 2 3 int c = 7 / 2; // 打印结果为3 而不是3...1 double d = 7 / 2; // 打印结果为3 而不是3...1 cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 取余(取模)操作符，得到的是整除后的余数\n1 2 int e = 7 % 2; cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl;// 1 注意事项和细节：\n/除法操作符，除数不能为0，如果除数为0，程序会崩溃 %取模操作符计算的结果是两个操作数进行除法运算后的余数 取模操作符的操作数只能是整型，不能是浮点型，否则编译器会报错 1 2 3 float f = 0.4f; int n = 2; int d = f % n; //error 4.2 浮点数的除法 如果希望得到浮点数结果，那么除号的两端的操作数至少有一个是浮点数\n1 2 3 4 a = 6; float f1 = a / 4; // 1 float f2 = 6.0 / 4; // 1.5 float f3 = a * 1.0 / 4; // 1.5 4.3 负数取模 取模操作符%计算的结果是两个操作数进行除法运算后的余数。\n负数取模的结果由第一个运算数的正负号决定\n如果第一个运算数是正数，那么取模的结果就是正数 如果第一个运算数是负数，那么取模的结果就是负数 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; 11 % -5 \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; -11 % -5 \u0026lt;\u0026lt; endl; // -1\tcout \u0026lt;\u0026lt; -11 % 5 \u0026lt;\u0026lt; endl; // -1 return 0; } 4.4 数值溢出 根据我们前面学到的，我们了解到每种数据类型都有对应的取值范围，而我们在实际运算\n过程中可能会超出该数据类型所能表示的范围。\n数值溢出就是数值超过了当前数据类型所能表示的范围，部分数据丢失，导致最终存进去\n的不是我们想要的数据\n以char类型为例，char类型的取值范围是-128~127 ，当值为127的字符+1后，字符的取值\n就是-128了\n4.5 练习 1. 时间转换 前提知识：\n60秒 \u0026ndash; 1分钟 60分钟 \u0026ndash; 1小时 3661 / 60 == 61分钟 余 1秒\n61分钟 / 60 == 1小时 余 1分钟\n小时：我们拿到秒数，除以60，看能凑多少分钟；因为每60分钟可以凑一个小时\n​\t所以，我们再将分钟除以60看能凑多少个小时\n分钟：同样，因为每60秒可以凑一分钟，所以我们先将总的秒数除以60，看能凑多少分钟；\n​\t因为60分钟可以凑一小时，所以再除以60后得到的余数就是凑不够一小时的分钟\n秒：因为60秒能凑一分钟，所以总的秒数除以60，得到的整数就是能凑够的分钟\n​\t得到的余数就是没办法凑够一分钟的秒数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int secondes; cin \u0026gt;\u0026gt; secondes; int s = secondes % 60 ; int m = secondes / 60 % 60; int h = secondes / 60 / 60; cout \u0026lt;\u0026lt; h \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; endl; return 0; } 2. 小鱼的游泳时间 思路：\n​\t使用借位的方法算比较麻烦，我们可以将小鱼开始游泳的时间和结束游泳的时间都转换\n成分钟，然后结束游泳的分钟减去开始游泳的分钟，得到的结果/60得到小时，%60得到分钟\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int a, b, c, d; int main() { //输入 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; //计算 //1.a时b分到 0:0的差值单位是分钟 int t1 = a * 60 + b; int t2 = c * 60 + d; int t = t2 - t1; int h = t / 60; // 小时 int m = t % 60; // 分钟 //输出 cout \u0026lt;\u0026lt; h \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 5. 赋值操作符 5.1 连续赋值 初始化和赋值\n初始化：变量在定义的同时给它一个值，这叫变量的初始化。 赋值：使用赋值操作符= ，将=右边的值赋给=右边的变量 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; // 初始化 a = 100; // 赋值 return 0; } 连续赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 3; int b = 0; int c = 0; c = b = a + 2; // 先将 a+2 的结果赋给 b，然后将b的结果赋给a return 0; } 5.2 复合赋值符 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; a += 3;\t// 等价于 a = a + 3; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 除此外，还有-=，*=，/=，%=等\n复合赋值符 样例 ⼀般写法 += a += 10 a = a + 10 -= a -= 10 a = a - 10 *= a *= 10 a = a * 10 /= a /= 10 a = a / 10 %= a %= 10 a = a % 10 \u0026raquo;= a \u0026raquo;= 1 详⻅《第 7 章 操作符》 \u0026laquo;= a \u0026laquo;= 1 \u0026amp;= a \u0026amp;= 10 |= a |= 10 ^= a ^= 10 5.3 练习 6. 类型转换 不同类型的数据进行混合计算的时候，或者赋值时等号两边的类型不统⼀的时候，\n都会发生类型转换 ，这时就需要根据类型的转换规则转换成合适的类型。\n6.1混合运算时的类型 整数，浮点数，字符可以混合运算，在这种情况下首先要将不一致的数据类型进行转换\n类型统一后才能进行计算\n整型提升：表达式中的char和short类型一定会先转换成int类型，然后参与运算\n算术转换：表达式中出现下面的任意两种类型的值进行计算的时候。要先将位于下面\n的类型转换成位于上面的类型\n1 2 3 4 5 6 7 long double double float unsigned long int long int unsigned int int 下面的转换成上面的类型\n6.3赋值时类型转换 当赋值操作符两端的数据类型不一致的时候，就需要类型转换，这种转换是隐式自动发生的\n规则如下：\nfloat和double赋值给 int 直接截断小数部分，保留整数部分 较小的类型转换成较大的类型，直接转换，值不变 较大类型转换成较小类型，一般会发生截断，按照较小类型的长度，保留低位数据给较小的类型。一般编译器会报警 6.4 强制类型转换 根据需要，将某一数据类型转换为指定的数据类型。\n强制类型转换是临时转换，不会影响变量本身\n语法：(类型)表达式\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 0; //int \u0026lt;--- double a = (int)3.14; //将double类型的3.14强制类型转换成int类型 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 3 return 0; } 6.5练习 1. 浮点数向零舍入 题目中说输入一个双精度浮点数，也就是我们需要用一个double类型的变量来接收。\n向零舍入其实就是强制类型转换。\n**正数向下舍入：**12.3 强制类型转换成整数时，舍去小数部分，结果为 12 ，和12.3相比是变小了 负数向上舍入：-2.7 强制类型转换成整数时，舍去小数部分，结果为 -2，和-2.7相比是变大了 注意：题目中说x的取值范围在-10^-15^ 到 -10^15^，不在整数的范围内，因此我们需要把浮点数强转成\n比int类型大的类型（比如long long)\n7. 单目操作符 7.1 ++和\u0026ndash; ++和\u0026ndash;分为：\n前置++，前置\u0026ndash; 后置++，后置\u0026ndash; 前置 ++ 或者 后置 ++ ，都是让操作数⾃增1的\n前置 \u0026ndash; 或者 后置 \u0026ndash; ，都是让操作数⾃减1的\n对于前置的++，都是先使用，再自增1；对于前置的\u0026ndash;，都是先使用，再自减1\n对于后置的++，都是先自增1，再使用；对于后置的\u0026ndash;，都是先自减1，再使用\n7.2正号和负号 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = -10; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // -10 int b = -a; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; // 10 return 0; } 二、C/C++的输入与输出 1. getchar和putchar getchar()和putchar()是C语言里面的库函数，由于C++兼容C，所以在C++中只要正确包含头文件\n就可以正常使用这两个函数\n1.1getchar() 1 int getchar ( void ); getchar()函数返回用户从键盘输入的一个字符，使用时不需要传参\n需要包含头文件cstdio\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int ch = getchar(); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; // 以整型的形式打印 cout \u0026lt;\u0026lt; (char)ch \u0026lt;\u0026lt; endl; // 以字符的形式打印 return 0; } getchar()总是返回当前读取的第一个字符，无论是否为空格。\n如果读取失败，会返回常量EOF，EOF的值通常是-1，所以返回值的类型要设为int而不是char\n**注意：**我们输入一个字符后回车，其实回车也是一个字符\\n，也就是当我们再次读取字符\n​\t时，会读取 \\n\n如何让 getchar() 函数读取失败返回-1呢？在不输入任何字符之前，按ctrl+z\n1.2 putchar() 1 int putchar ( int character ); putchar() 函数将它的参数字符输出到屏幕，它的原型头文件\u0026lt;cstdio\u0026gt;\n操作成功时，返回输出的字符，否则返回常量EOF\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { int ch = getchar(); putchar(ch); return 0; } getchar和putchar的使用场景：\n当涉及到大量数据的读写时，我们可以封装这两个函数帮助我们快速读写\n2.scanf 和printf 2.1 printf() 占位符 格式输出 可以限定最小宽度\n默认是右对齐（%5d），前面加上负号变为左对齐（%-5d）\n整数限定宽度 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { printf(\u0026#34;%5d\\n\u0026#34;, 123); // %5d 至少打印5位 printf(\u0026#34;%5d\\n\u0026#34;, 44); return 0; } 小数宽度控制\n%f在打印的时候，默认小数点后会打印6位\n1 2 printf(\u0026#34;%f\\n\u0026#34;, 123.45); // 123.450000 printf(\u0026#34;%12f\\n\u0026#34;, 123.45); 限定小数点后面的位数\n%.2f表示小数点后只打印2位\n1 2 3 printf(\u0026#34;%.2f\\n\u0026#34;, 123.45); // 123.45 printf(\u0026#34;%6.2f\\n\u0026#34;, 0.5); // 总宽度至少6位（小数点也算一位），小数点后打印两位 printf(\u0026#34;%*.*f\\n\u0026#34;, 6, 2, 0.5);//等价于%6.2f，但是更灵活 2.2 scanf() 2.2.1基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int i = 0; //输入 scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); // \u0026amp; --- 取地址操作符 printf(\u0026#34;i = %d\\n\u0026#34;, i); return 0; } 特别注意，scanf函数的占位符后⾯⼀般不会加 \\n ， \\n 是换⾏，⼀般在输出的时候才使⽤\n输入时以逗号隔开\n1 2 3 int a, b, c, d; scanf(\u0026#34;%d,%d,%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d %d %d %d\\n\u0026#34;, a, b, c, d); 输入时，以空格隔开\n1 2 scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%d %d %d %d\\n\u0026#34;, a, b, c, d); scanf() 处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。\n小数有时候在内存中无法精确保存\n2.2.2 占位符 %[]只能匹配数字字符\n1 2 3 char ch = 0; scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); // 输入空格 printf(\u0026#34;---%c---\\n\u0026#34;, ch); // --- --- 如何强制跳过%c前面的空格呢？在%c前加空格\n1 2 3 char ch = 0; scanf(\u0026#34; %c\u0026#34;, \u0026amp;ch); printf(\u0026#34;%c\\n\u0026#34;, ch); 2.2.3 scanf返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a = 0, b = 0; while(scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b) == 2) { printf(\u0026#34;a = %d, b = %d\\n\u0026#34;, a, b); } return 0; } 练习 1 2 3 4 5 6 7 8 #include\u0026lt;cstdio\u0026gt; int main() { int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%.3lf%%\\n\u0026#34;, b * 100.0 / a); return 0; } 3. cin和cout 3.1基本介绍 cin是C++提供的标准输入流对象，一般针对键盘，读取键盘上输入的字符流\n一般和\u0026gt;\u0026gt;（流提取运算符）配合使用\ncout是C++提供的标准输出流对象，一般针对的控制台的窗口，将数据以字符流的形式输出到控制台窗口显示。一般和\u0026lt;\u0026lt;（流插入运算符）配合使用\n3.2连续输入输出 使用 cout 进行变量的输出，实质上是将变量插入到 cout 对象里，并以 cout 对象作为返回值返回。因此我们还可以用 \u0026laquo; 在后面连续输出多个内容\n3.3（选学）cin和cout控制输出格式 控制整数的输出\nsetw()括号里填字符的最小宽度\nsetfill()括号里填当宽度不够的时候以什么字符来填充\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;iomanip\u0026gt; int main() { int a = 123; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//宽度5个字符 cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//宽度5个字符 return 0; } 控制小数的格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;iomanip\u0026gt; int main() { double pi = 31.4159265358; cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; scientific \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; return 0; } 左右对齐\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;iomanip\u0026gt; int main() { int a = 123; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 默认是右对齐 cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; left \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 题目 题目1\n输入输出的都是字符流，可以把输入的123.4看做由字符1、字符2、字符3、字符.、字符4组成\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a,b,c,d,e; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; e; cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; d \u0026lt;\u0026lt; c \u0026lt;\u0026lt; b \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 写法2\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;cstdio\u0026gt; int main() { char a,b,c,d; scanf(\u0026#34;%c%c%c.%c\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); printf(\u0026#34;%c.%c%c%c\\n\u0026#34;, d, c, b, a); return 0; } 题目2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { //输入 double a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt;c; //计算 double p = (a + b + c) / 2.0; double area = sqrt(p * (p - a) * (p - b) * (p - c)); //输出 cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(1) \u0026lt;\u0026lt; area \u0026lt;\u0026lt; endl; return 0; } 4、string 1.string的概念 2.string的操作 string的创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 空字符串 string s2 = \u0026#34;abc\u0026#34;; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; string s3(\u0026#34;hello world\u0026#34;); string s4 = s3; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; return 0; } C++中的string创建的字符串对象可以直接复制，而char类型的数组所表示的字符串不行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { char arr1[] = \u0026#34;hello world\u0026#34;; char arr2[] = \u0026#34;hello\u0026#34;; arr1 = arr2; // error 数组名是数组首元素的地址 ，地址是一个常量值 string s1(\u0026#34;hello world\u0026#34;); string s2 = \u0026#34;hello\u0026#34;; s1 = s2; // ok return 0; } string对象的输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; //输入 cin \u0026gt;\u0026gt; s1; //输出 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 注意：cin读取数据的时候，遇到空格就不再读取了\n三、条件判断与循环 1. if-else 题目1：求绝对值\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; #include\u0026lt;cmath\u0026gt; int main() { float n; cin \u0026gt;\u0026gt; n; n = fabs(n); printf(\u0026#34;%.2f\\n\u0026#34;, n); return 0; } fabs是专门用来求浮点数绝对值的\n库函数 fabs 是用来求⼀个浮点数的绝对值的，需要的头文件是 cmath\u0026gt;\nabs是专门用来求整数绝对值的\n要包含头文件cstdlib\n题目2 奇偶数判断\n注意：取模运算符如果前面的数是负数，那么结果也为负数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; if(n % 2 == 1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else if(n % 2 == -1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;even\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 2.关系操作符 关系表达式的结果要么是1要么是0，关系操作符是从左向右计算的\n注意：关系操作符不宜连用\n1 2 i \u0026lt; j \u0026lt; k; // 实际执行的是(i \u0026lt; j) \u0026lt; k; //(i \u0026lt; j)返回的是0或1 如果想表示j在i和k之间，需要使用下面的写法\n1 (j \u0026gt; i \u0026amp;\u0026amp; j \u0026lt; k) 浮点数比较大小\n在⽐较浮点数时，由于浮点数在计算机中是以有限精度表⽰的，也就是说有些浮点数在内存中其实⽆法精确保存，这可能导致浮点数⽐较中的⼀些精度误差问题。如果直接使⽤ == 来⽐较两个浮点数，很可能会由于这些微⼩的误差导致不准确的结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int main() { double a = 0.1; double b = 0.2; double c = 0.3; if(fabs((a + b) - c) \u0026lt; 0.0000001) // 1e-6 是允许的 cout \u0026lt;\u0026lt; \u0026#34;a + b == c\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;a + b != c\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 题目 题目1 思路1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //1.定义一个变量count，依次判断成绩是否合格 //合格就count++ //2.判断count，如果count=2那么就输出1，否则输出0 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int count = 0; int a; //输入+判断+统计 for(int i = 0; i \u0026lt; 3; i++) { cin \u0026gt;\u0026gt; a; if(a \u0026gt;= 60) count++; } //判断count + 输出 if(count == 2) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } 思路2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //思路2 //关系表达式的结果要么是1要么是0 //如果(s1 \u0026lt; 60) + (s2 \u0026lt; 60) + (s3 \u0026lt; 60) 的结果是1那么就输出1 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int s1, s2, s3; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2 \u0026gt;\u0026gt; s3; //判断 if(((s1 \u0026lt; 60) + (s2 \u0026lt; 60) + (s3 \u0026lt; 60)) == 1) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } 题目2 分析： 1.n是大于0，小于等于1000的 1)a1和a2最大取值是100，最小取值是-100，所以它们两者的差最大是200 差最大是200，项数最大是1000，int能存下 2)n可以取1或2，如果是1或2，那么第一项和第二项的结果已经有了 2.找规律 1)第1项和第2项之间的差值是x 2)第2项和第3项之间差值是x \u0026mdash; (3-2)x 第2项和第4项的差值是2个x \u0026mdash; (4-2)x 第2项和第5项的差值是3个x \u0026mdash; (5-2)x 3)推出第n项和第2项的差值是(n-2)x 3.第n项的值为 (n-1)x+第二项的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n1, n2, n; cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2 \u0026gt;\u0026gt; n; if(n == 1) cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; endl; else if(n == 2) cout \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; (n-2) * (n2-n1) + n2 \u0026lt;\u0026lt; endl; return 0; } 3.条件操作符 也叫三目操作符\n题目1 思路：过去了s分钟 / 吃一个苹果需要花费的时间t = 现在已经吃了的苹果个数 总的苹果个数m - 已经吃了的苹果个数 = 剩下的苹果个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int m, t, s; int r; // 剩余苹果数 cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s; //特殊情况：吃一个苹果需0分钟 if(t == 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } //计算 ，注意：要考虑计算出的剩下苹果为负数的情况 if(s % t == 0) r = ((m - s / t) \u0026lt; 0) ? 0 : m - s / t;\telse r = ((m - s / t) \u0026lt; 0) ? 0 : m - s / t - 1; cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } 题目3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if((a + b \u0026gt; c) \u0026amp;\u0026amp; (a + c \u0026gt; b) \u0026amp;\u0026amp; (b + c \u0026gt; a)) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } 注意是任意两条边之和大于第三边，要用且\n题目4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i; cin \u0026gt;\u0026gt; i; if(i % 3 == 0) cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if(i % 5 == 0) cout \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if(i % 7 == 0) cout \u0026lt;\u0026lt; 7 \u0026lt;\u0026lt; endl; if(i % 3 != 0 \u0026amp;\u0026amp; i % 5 != 0 \u0026amp;\u0026amp; i % 7 != 0) cout \u0026lt;\u0026lt; \u0026#34;n\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 题目5 注意：条件表达式的结果是1或0\n题目中小B喜欢符合一个性质的，等价于两个条件相加等于1\n正妹喜欢不符合这两个性质的整数，等价于两个条件相加等于0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x; cin \u0026gt;\u0026gt; x; //小A if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) \u0026amp;\u0026amp; (x % 2 == 0)) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //Uim if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) || (x % 2 == 0)) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //小B //条件表达式的结果是1或0 if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) + (x % 2 \u0026lt;mark\u0026gt; 0) \u0026lt;/mark\u0026gt; 1) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //正妹 if((x \u0026gt; 4 \u0026amp;\u0026amp; x \u0026lt;= 12) + (x % 2 \u0026lt;mark\u0026gt; 0) \u0026lt;/mark\u0026gt; 0) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 4.switch语句 基本语法：\n1 2 3 4 5 6 7 8 9 10 11 12 switch(整型表达式) { case value1: ... break; case value2: ... break; default: ... break; } case语句决定分支的入口，break语句决定分支的出口\n注意/细节：\nswitch后面必须跟的是整型表达式(字符本质也是整型)，不能跟浮点型 case后面必须跟的是整型常量表达式 case和后面的值之间必须要加空格 注意不要忘加break switch语句中case和default是没有顺序要求的 题目 两种方式\nC语言的方式，scanf在读的时候可以指定读取的位数 C++的方式，一个数模上100剩下的就是0~99的数字 C语言的方式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int y,m; scanf(\u0026#34;%4d%2d\u0026#34;, \u0026amp;y, \u0026amp;m); switch(m) { case 3: case 4: case 5: cout \u0026lt;\u0026lt; \u0026#34;spring\u0026#34; \u0026lt;\u0026lt; endl; break; case 6: case 7: case 8: cout \u0026lt;\u0026lt; \u0026#34;summer\u0026#34; \u0026lt;\u0026lt; endl; break; case 9: case 10: case 11: cout \u0026lt;\u0026lt; \u0026#34;autumn\u0026#34; \u0026lt;\u0026lt; endl; break; case 12: case 1: case 2: cout \u0026lt;\u0026lt; \u0026#34;winter\u0026#34; \u0026lt;\u0026lt; endl; break; } return 0; } C++的方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int m; cin \u0026gt;\u0026gt; m; m = m % 100; switch(m) { case 3: case 4: case 5: cout \u0026lt;\u0026lt; \u0026#34;spring\u0026#34; \u0026lt;\u0026lt; endl; break; case 6: case 7: case 8: cout \u0026lt;\u0026lt; \u0026#34;summer\u0026#34; \u0026lt;\u0026lt; endl; break; case 9: case 10: case 11: cout \u0026lt;\u0026lt; \u0026#34;autumn\u0026#34; \u0026lt;\u0026lt; endl; break; case 12: case 1: case 2: cout \u0026lt;\u0026lt; \u0026#34;winter\u0026#34; \u0026lt;\u0026lt; endl; break; } return 0; } 使用if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int m; cin \u0026gt;\u0026gt; m; m = m % 100; if(m \u0026gt;= 3 \u0026amp;\u0026amp; m \u0026lt;= 5) cout \u0026lt;\u0026lt; \u0026#34;spring\u0026#34; \u0026lt;\u0026lt; endl; else if(m \u0026gt;= 6 \u0026amp;\u0026amp; m \u0026lt;= 8) cout \u0026lt;\u0026lt; \u0026#34;summer\u0026#34; \u0026lt;\u0026lt; endl; else if(m \u0026gt;= 9 \u0026amp;\u0026amp; m \u0026lt;= 11) cout \u0026lt;\u0026lt; \u0026#34;autumn\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;winter\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 5.循环 5.1 while循环 题目 注意数据类型的选取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n, i = 1; long long sum = 0; cin \u0026gt;\u0026gt; n; while(n) { sum += i; i++; n--; } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } 使用等差数列公式：（首项+尾项）*项数 / 2\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long n; long long sum = 0; cin \u0026gt;\u0026gt; n; sum = (1 + n) * n / 2; cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } 题目 注意：\n​\t1. 这道题虽然给的数据不会超过int，但是如果一直是奇数，那么一直\n​\t乘三+1可能就会超出能表示的范围，最好使用long long\n​\t2.printf打印long long类型的数据时，要使用%lld\n​\t3. 使用了printf最好包头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { long long n; cin \u0026gt;\u0026gt; n; while(n != 1) { if(n % 2 == 0) { printf(\u0026#34;%lld/2=%lld\\n\u0026#34;, n, n/2); n /= 2; } else { printf(\u0026#34;%lld*3+1=%lld\\n\u0026#34;, n, n * 3 + 1); n = n * 3 + 1; } } cout \u0026lt;\u0026lt; \u0026#34;End\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 题目 1 + 1x + x * x^1^ + x * x^2^+\u0026hellip;+x(x^(n-1)^)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { double x; double d = 1, sum = 1;//初始化为1 int n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; while(n--) { d *= x; sum += d; } printf(\u0026#34;%.2f\\n\u0026#34;, sum); return 0; } for循环 题目 注意局部变量如果不初始化，它的值是随机的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { //读取n int n; cin \u0026gt;\u0026gt; n; //读取n个年龄 int age; int sum = 0; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; age; sum += age; } double avg = sum * 1.0 / n; printf(\u0026#34;%.2f\\n\u0026#34;, avg); return 0; } 题目 时间：\n去的时间 \u0026ndash; 距离 回来的时间 \u0026ndash; 距离 上船的时间 \u0026ndash; 人数 下船的时间 \u0026ndash; 人数 每一个屋顶都是单独营救的，总时间和屋顶的个数有关\n向上取整\n6.1 \u0026mdash;-\u0026gt; 7\n6.5 \u0026mdash;-\u0026gt; 7\n6.0 \u0026mdash;-\u0026gt; 6\n我们可以将小数部分取出来，如果小数部分大于0.0那么整个数+1之后再强转\n反之就直接强转\n1 2 3 4 5 6 7 double d = 6.5; int q = (int)d; double p = d - p; //6.5-6 == 0.5 if(p \u0026gt; 0.0) (int)(d + 1); else (int)d; 库函数中有\nceil \u0026ndash; 向上取整\nfloor \u0026ndash; 向下取整\n头文件cmath\n思路\n1. 输入n 2. 循环n次 每次处理一个屋顶 x,y,m (1)计算距离 (2)计算时间 (3)时间累加 3.输出时间 - 向上取整 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; //\t1. 输入n //\t2. 循环n次 //\t每次处理一个屋顶 x,y,m //\t(1)计算距离 //\t(2)计算时间 //\t(3)时间累加 //\t3.输出时间 - 向上取整 #include \u0026lt;cmath\u0026gt; double x,y; // 坐标 int m; // 人数 double t; int main() { int n; //输入屋顶数 cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; m; //计算距离 double dis = sqrt(x * x + y * y); //计算时间 t += dis / 50 * 2 + m * 1.5; } //输出时间 -- 向上取整 cout \u0026lt;\u0026lt; (int)ceil(t) \u0026lt;\u0026lt; endl; return 0; } 题目 使用pow函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; #include \u0026lt;cmath\u0026gt; int main() { int n; double sum = 0; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) { sum += pow(-1, i-1) * 1.0 / i; } printf(\u0026#34;%.4f\\n\u0026#34;, sum); return 0; } break和continue 题目 分析：\nn = m1 * m2，m1 != m2 m1和m2是质数 什么是质数？\n质数就是只能被1和它本身整除的数\n我们只需要在2~n-1之间找到m1，m1就是较小的那个质数\n然后n/m1就是m2\n因为m1和m2都是质数，所以m1和m2都只能被1和本身整除\nn又可以通过m1*m2得到，所以实际上n只能被0,m1,m2,n整除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int i; for(i = 2; i \u0026lt; n; i++) { if(n % i == 0) { cout \u0026lt;\u0026lt; n / i \u0026lt;\u0026lt; endl; break; } } return 0; } 题目 思路分析 1.输入n 2.sum=1 3.循环n次\u0026ndash;解决n项求和 1)算出阶乘 2)1/阶乘 3)求和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { double sum = 1; int n; cin \u0026gt;\u0026gt; n; //n项 long long fac = 1; for(int i = 1; i \u0026lt;= n; i++) { //求i的阶乘 -- n!=(n-1)!*n fac *= i;\tsum += 1.0 / fac; } printf(\u0026#34;%.10f\\n\u0026#34;, sum); return 0; } 第n小的质数 分析：\n质数又称为素数。\n质数只能被1和它本身整除。比如7,7能被1和7整除，但是2,3,4,5,6都不能整除7\n第n小的质数，就是从小到大的第n个质数\n写题思路：\n1.输入n 2.从2开始向后，找到n个质数，第n个质数就是第n小的质数\n​\t判断i是否为质数 ​\t试除法：产生2到i-1之间的数字\n​\t如果i是素数，count++\nTLE超出时间限制\n**优化思路：**如果n有一个因子a，那么必然存在另一个因子b，使得n=a*b。如果a和b都\n大于根号n，那么ab的结果将会大于n，这与n=ab矛盾。因此至少有一个因子不会超过根号n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; //分析 //1.输入n //2.从2开始向后，找到n个质数，第n个质数就是第n小的质数 int main() { int n; cin \u0026gt;\u0026gt; n; int count = 0; int i = 2; while(1) { //\t判断i是否为质数 //\t试除法：产生2到i-1之间的数字 int flag = 1; // 假设i是素数 for(int j = 2; j \u0026lt;= sqrt(i); j++) { if(i % j == 0) { //不是质数 flag = 0; break;\t}\t} //如果i是素数，count++ if(flag == 1) count++; if(count == n) break; i++; } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } 水仙花数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; //分析 //1.产生100~999中的数字 -- 循环 //2.判断i是否是水仙花数 //\t1)得到每一位%10 /10，立方相加 //\t2)和原数相比较 int main() { int temp, sum; for(int i = 100; i \u0026lt;= 999; i++) { sum = 0; temp = i; while(temp) { sum += pow(temp % 10, 3); temp /= 10; } //判断是否为水仙花数 if(sum == i) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } 补充：\n自幂数 \u0026ndash; 一个n位数，你的每一位的n次方之和等于你自己\n3位的自幂数是水仙花数\n总结做题时的注意事项 输出格式，注意许多题要求输出时中间有空格，\n有些还指定了宽度位（需要用printf）,要包含对应头文件#include \u0026lt;cstdio\u0026gt;\n例如：\n这道题目的输出只要求了按5位宽度输出，没要求空格\n实数就是小数\nscanf在读的时候可以指定位数\n一定要注意整数是使用int还是long long，如果是单个数字满足int，但是可能会有\n两个数相加/相乘等，那么结果可能会超出int所能表示的范围\n比如下面这道题，题目要求计算的是从1加到n的结果，需要使用long long\n使用printf 时如果是long long类型的数据，要使用%lld\nlong double类型的数据要使用%Lf\n使用scanf时，整数使用%d，float类型的使用%f，double类型的使用%lf\nlong double类型的使用%Lf\n比较大的数组最好声明为全局变量，且最好多开辟一点空间\n原因：局部变量是存储在栈区的，空间有限；全局变量存储在静态区，空间较大\n注意输出的标点，比如中间有逗号，但是结尾没有\n可以把第一个单独打印，后面,数字为一组\nint类型最大可以表示到10的9次方\n算不明白数据范围就用 long long\n注意：结构体最后要加上分号\n注意 if() 后面不要把 == 写成了 =\n子串是连续的一部分，子序列是可以不连续的\n处理负数取模\n除留余数法：hash(key) = key % N\n但是需要注意，key有可能是负数，取模之后会变成负数\n负数补正的操作为：加上模数即可 但是正数加上模数会变大，所以统一再取一次模 最终就是**（key % N + N) % N ，简称 模加模**\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-io-and-circulation/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-io-and-circulation/","title":"【从零开始学C++】01输入输出+循环"},{"content":"一、 数组 1.一维数组 数组是一组相同类型元素的集合\n数组中存放1个或多个数据，但是数组元素个数不能为0\n1.1范围for 范围for是C++11引入的新特性\n语法\n1 2 for(类型 变量名 : 数组名) 语句 //多条语句使用大括号 范围for会将数组里面的元素依次放到变量里面，然后通过循环可以打印变量\n例如：使用范围for打印数组里的每一个元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; //范围for int main() { int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; for(int e : arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 使用范围for不会修改数组里元素的值\n因为变量e和数组是两块独立的空间\n注意：范围for一定会将整个数组遍历完\n1.2auto关键字 auto作用：让编译器自动推导出变量的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //auto自动推导类型 for(auto e : arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 1.3memset设置数组内容 memset是用来来设置内存的，将内存中的值以字节为单位设置成想要的内容\n需要包含头文件\u0026lt;ctring\u0026gt;\nmemset会一个字节一个字节地设置内存里的值\nptr：指向要设置的内存块的起始位置\nvalue：要设置的值\nnum：设置字节的个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //memset int main() { char arr[] = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; //将字符串从第2个字符开始的后五个字符设置为字符x memset(arr + 2, \u0026#39;x\u0026#39;, 5); // 数组名是数组首元素的地址 cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; //将字符串的前五个字符设置为字符x //\tmemset(arr, \u0026#39;x\u0026#39;, 5); //\tcout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; return 0; } 注意：如果是整型数组，一般使用memset将数组设置为0\n因为memset是一个字节一个字节设置内存的\n例如下面这段代码不会将数组里的每个元素设置为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { int arr[5] = {1, 2, 3, 4, 5}; //将数组里的每个字节改为1 memset(arr, 1, 20); for(auto e : arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 1.4memcypy拷贝数组内容 destnation：目标空间的起始地址\nsource：源数据空间的起始地址\nnum：拷贝的数据的字节个数\n将源数据空间里的内容拷贝到目标数据空间\n使用场景：\n将a数组中的内容拷贝到b数组\n如果我们使用下面这种方式是无法实现的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //memcpy int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[10] = {0}; //数组名是地址，地址是常量的值，常量不能被修改 // 例如 5=3这种写法是错误的 b = a; // 报错 return 0; } 需要使用memcpy函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //memcpy int main() { int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int b[10] = {0}; //数组名表示数组首元素的地址 memcpy(b, a, 10 * sizeof(int)); for(auto e : b) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //数组名是地址，地址是常量的值，常量不能被修改 // 例如 5=3这种写法是错误的 //b = a; // 报错 return 0; } 题目 思路分析： 1.创建一个数组，保存患者就诊的年龄，数组大小110 0-18、19-35、36-60、61及以上的人数分别为a,b,c,d 2.循环遍历数组N次，输入每个患者的年龄，并判断 该患者是在0-18、19-35、36-60、61及以上的哪个区间内 从而确定是a++还是b++还是c++还是d++ 3.计算百分比，该年龄段的患者人数/总人数 1)注意保留小数点后两位 2)注意是百分比，计算结果还要乘以100\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; //思路分析： //1.创建一个数组，保存患者就诊的年龄，数组大小110 //\t0-18、19-35、36-60、61及以上的人数分别为a,b,c,d //2.循环遍历数组N次，输入每个患者的年龄，并判断 //\t该患者是在0-18、19-35、36-60、61及以上的哪个区间内 //\t从而确定是a++还是b++还是c++还是d++ //3.计算百分比，该年龄段的患者人数/总人数 // 1)注意保留小数点后两位 // 2)注意是百分比，计算结果还要乘以100 const int N = 110; int arr[N]; int a, b, c, d; int main() { //输入患者人数 int n; cin \u0026gt;\u0026gt; n; //输入患者年龄 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; arr[i]; if(arr[i] \u0026gt;= 0 \u0026amp;\u0026amp; arr[i] \u0026lt;= 18) a++; else if(arr[i] \u0026gt;= 19 \u0026amp;\u0026amp; arr[i] \u0026lt;= 35) b++; else if(arr[i] \u0026gt;= 26 \u0026amp;\u0026amp; arr[i] \u0026lt;= 60) c++; else d++; } //计算输出 printf(\u0026#34;%.2f%%\\n\u0026#34;, a * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, b * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, c * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, d * 1.0 / n * 100); return 0; } **优化：**我们原先是先将数据读到数组里面，然后对数组里的每个数据进行分析\n​\t其实我们可以读一个数据，然后分析一个数据，也就是不将数据存起来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int a, b, c, d; int main() { int age; //输入患者人数 int n; cin \u0026gt;\u0026gt; n; //输入患者年龄并判断 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; age; if(age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 18) a++; else if(age \u0026gt;= 19 \u0026amp;\u0026amp; age \u0026lt;= 35) b++; else if(age \u0026gt;= 26 \u0026amp;\u0026amp; age \u0026lt;= 60) c++; else d++; } //计算输出 printf(\u0026#34;%.2f%%\\n\u0026#34;, a * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, b * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, c * 1.0 / n * 100); printf(\u0026#34;%.2f%%\\n\u0026#34;, d * 1.0 / n * 100); return 0; } 题目 //思路分析： //1.n盏灯的每盏灯的状态都需要存下来，使用数组 //2. 灯开启用1表示，灯关闭用0表示 //3. 灯的编号从1开始 // 即灯的状态信息从数组下标为1的地方开始向后存 //4.n个人遍历数组n次 // n个人都是对这n盏灯进行处理\n//具体实现：定义两个变量 int j 表示第几盏灯\n//第一个人一上来就把灯全部关闭，相当于全局数组的初始状态 //我们从第2个人开始处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 5010; int arr[N]; const int N = 5010; int arr[N]; int main() { //2. n盏灯，n个人 int n; cin \u0026gt;\u0026gt; n; //3. 循环处理，共n个人 //但我们从第二个人开始处理灯的状态 for(int i = 2; i \u0026lt;= n; i++) // i表示人的编号 { //1）处理n盏灯，遍历数组 for(int j = i; j \u0026lt;= n; j++) // j表示灯的编号 { //2）判断灯的编号是不是人的编号的倍数 if(j % i == 0) { //3）是i的倍数，开始判断，如果灯是开的就关闭 // 如果灯是关闭的就打开 if(arr[j] == 1) arr[j] = 0; else arr[j] = 1; }\t} } //4.遍历数组，将灯是关着的编号输出，中间用逗号隔开 for(int i = 1; i \u0026lt;= n; i++) { if(arr[i] == 0) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 2.二维数组 行可以省略，列不能省略\n使用memset初始化二维数组\n使用memset函数要包含头文件cstring\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { int arr[10][10]; // 值是随机的 //从哪开始初始化，初始化成什么， 初始化多少个字节 // sizeof()里面直接跟数组名，计算的是整个数组的大小 memset(arr, 0, sizeof(arr)); //打印 for(int i = 0; i \u0026lt; 10; i++) // 行 { for(int j = 0; j \u0026lt; 10; j++) // 列 { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t}\tcout \u0026lt;\u0026lt; endl; } return 0; } 3.字符数组 3.1基础部分 1 2 3 4 //字符串 cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; //string - C++ 字符数组的初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { //1-直接使用字符串初始化 char ch1[10] = \u0026#34;abcdef\u0026#34;;//abcdef\\0 char ch2[] = \u0026#34;abcdef\u0026#34;;//根据初始化的内容来确定个数 cout \u0026lt;\u0026lt; ch2 \u0026lt;\u0026lt; endl; //2-直接使用字符初始化 char ch3[10] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;};//剩下的四个字符默认初始化为0 char ch4[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;};//末尾没有\\0 cout \u0026lt;\u0026lt; ch4 \u0026lt;\u0026lt; endl; return 0; } 3.2 strlen求字符串长度 strlen统计的是字符串中\\0之前的字符个数\nstr \u0026ndash; 指针，存放的是字符串的起始地址，从这个地址开始计算字符串的长度\n使用要包含头文件\u0026lt;cstring\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr[10] = \u0026#34;abcdef\u0026#34;; //abcdef\\0 //strlen统计字符串\\0之前字符的个数 int len = strlen(arr); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; //6 //计算数组的长度（元素个数） int sz = sizeof(arr) / sizeof(arr[0]); // 字符数组可以直接sizeof(arr) // 10 1 cout \u0026lt;\u0026lt; sz \u0026lt;\u0026lt; endl; //10 return 0; } 如果要使用这种方式 char ch4[] = {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;f\u0026rsquo;};\n最好在末尾主动加上\\0 \u0026mdash;\u0026gt; char ch4[] = {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, \u0026rsquo;d\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;f\u0026rsquo;, \u0026lsquo;\\0\u0026rsquo;};\n3.3字符数组的输入 3.3.1输入没有空格字符串 使用printf和scanf\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char arr[10]; scanf(\u0026#34;%s\u0026#34;, arr); printf(\u0026#34;%s\\n\u0026#34;, arr); return 0; } 使用cin和cout\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char arr[10]; cin \u0026gt;\u0026gt; arr; // 会在末尾放\\0 cout \u0026lt;\u0026lt; arr; return 0; } 从指定位置开始输入\n例如：\n1 2 3 4 5 6 7 8 int main() { char arr[10]; scanf(\u0026#34;%s\u0026#34;, arr + 1);//从数组的第二个元素再开始存放 printf(\u0026#34;%s\\n\u0026#34;, arr); return 0; } 3.3.2 输入有空格的字符串 scanf在读取字符串的时候，遇到空格就停止读取\nscanf中的占位符%s，不能简单地等同于字符串，它的规则是：从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止\n%s的读取不会包含空白字符，所以无法用来读取多个单词，除非多个%s一使用。 scanf不适合读取可能包含空格的字符串，比如书名或歌曲名 细节：\nsancf（）遇到%s占位符，会在字符串末尾存储一个\\0字符·\nscanf()将字符串读入字符数组时，不会检测字符串是否超过了数组长度，可能会越界\n使用%[m]s，[m]表示读取字符串的最大长度，后面的字符会被丢弃\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { char arr[20]; scanf(\u0026#34;%10s\u0026#34;, arr); // 最多读10个字符 printf(\u0026#34;%s\\n\u0026#34;, arr); return 0; } 3.3.2.1解决办法 gets和fgets\n最好使用fgets\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20]; gets(arr); cout \u0026lt;\u0026lt; arr; return 0; } gets函数是从第一个字符开始读取，一直读取到\\n为止，但是不会读取\\n\n但是会在读取到的内容后面自动加上\\0\nstr：读到的内容放哪去\nnum：最多读多少个字符\nstream：从哪里读\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20]; fgets(arr, 20, stdin); // stdin 标准输入流 -- 键盘 cout \u0026lt;\u0026lt; arr; return 0; } fgets也是从第一个字符开始读取，最多读num-1个字符，最后一个位置留给\\0，\n如果num的长度远大于输入的字符串长度，就会一直读取到\\n停止，并且会读取\\n，\n将\\n作为读取到内容的一部分，同时在读取到的内容后自动加上\\0\n使用scanf读取\n将%s改成%\\[^\\n]s，表示一直读取，直到遇到\\n\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20]; scanf(\u0026#34;%[^\\n]s\u0026#34;, arr); cout \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; return 0; } 这种方式读取，不会将\\n读进来，但是在读取到的字符串末尾加上\\0\n使用getchar一个一个地去读取字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char arr[20] = {0}; //开始的时候将数组全部初始化为0，读取后就不需要再在末尾补\\0 //abc def\\n int ch = 0; int i = 0; while((ch = getchar()) != \u0026#39;\\n\u0026#39;) { arr[i] = ch; i++; } cout \u0026lt;\u0026lt; arr; return 0; } 3.7 isdigit判断是否是数字字符 如果给的字符是数字，返回非0，如果不是数字，返回0\n3.8 isalpha判断是否是字母 3.4 字符数组的输出 printf+%s cout 循环的方式逐个字符打印 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char a[] = \u0026#34;hello world\u0026#34;; // hello world\\0 int i = 0; while(a[i] != \u0026#39;\\0\u0026#39;) { cout \u0026lt;\u0026lt; a[i]; i++; } return 0; } 使用strlen求字符串长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char a[] = \u0026#34;hello world\u0026#34;; // hello world\\0 int len = strlen(a); // strlen使用要包含头文件cstring int i = 0; for(i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; a[i]; } return 0; } 使用sizeof求数组的长度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;}; int sz = sizeof(arr) / sizeof(arr[0]); int i = 0; for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i]; } retunr 0; } 3.5 strcpy 和 strcat strcpy字符串拷贝\n将源拷贝到目的地\n使用要包含头文件cstring\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr1[] = \u0026#34;hello world\u0026#34;; char arr2[20]; strcpy(arr2, arr1);//字符串拷贝 string copy cout \u0026lt;\u0026lt; arr2; return 0; } strcat在字符串末尾追加一个字符\n在目标字符串后面追加源里面的字符串，包括将源字符串里的\\0追加进去了\n目标字符串所在的数组空间要足够大，能放下源里面的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { char arr1[20] = \u0026#34;hello \u0026#34;; char arr2[] = \u0026#34;world\u0026#34;; strcat(arr1, arr2); cout \u0026lt;\u0026lt; arr1; return 0; } 3.6大小写转换函数 3.6.1 islower和tolower 使用要包含头文件\u0026lt;cctype\u0026gt;\n传一个字符或者整数，如果参数c是小写字母，函数就返回一个非0的数字，\n如果不是小写字母，就返回0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int main() { char c = \u0026#39;x\u0026#39;; //cout \u0026lt;\u0026lt; islower(c) \u0026lt;\u0026lt; endl; // 返回非0的数字 if(islower(c)) cout \u0026lt;\u0026lt; \u0026#34;小写字母\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;大写字母\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; (char)tolower(\u0026#39;X\u0026#39;) \u0026lt;\u0026lt; endl; return 0; } 3.6.2 isupper和toupper 3.7判断子串strstr 在str1字符串中查找str2这个子串第一次出现的位置\n如果找到了，就返回第一次出现的地址 如果没有找到，就返回NULL（0） 题目：找第一个只出现一次的字符 法一：暴力统计\n将输入的字符串用字符数组str保存，用两层循环，外层用变量i遍历str，内层再用变量j\n遍历str，让str[i]和str中所有元素相比较，统计个数，因为题目中说只需要找出第一个\n仅出现一次的字符，所以当str[i]遍历完str后，如果统计个数为1就退出循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1110; char str[N]; int main() { cin \u0026gt;\u0026gt; str; // 末尾放上\\n int flag = 0; // 表示是否有仅出现一次的字符 ，默认为0，表示还没出现 int i = 0; while(str[i]) { //拿str[i]和str数组中所有的元素比较，统计个数 int j = 0; int count = 0; while(str[j]) { if(str[i] == str[j]) count++; j++; } //如果是只出现一次，就退出循环 if(count == 1) { cout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; endl; flag = 1; break; } i++; } if(flag == 0) cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 法二：优化\n思路：\n因为给定的字符串只包含小写字母，所以我们可以定义一个大小为128或26的数组\nint nums[128]，每读一个字符，我们就让nums对应的位置++\n再次遍历字符串中的每一个字符，看nums对应位置的值是不是1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1110; char str[N]; int nums[128]; int main() { //\t//1.输入字符串 //\tcin \u0026gt;\u0026gt; str; // abcabd\\0 //\t//\t//2.遍历字符串，顺便统计每个字符的个数 -- int nums[128];//0~127 //\tint i = 0; //\twhile(str[i]) //\t{ //\tnums[str[i]]++; //\ti++; //\t} //1.2.逐个读取字符，然后统计字符出现的个数 int i = 0; while((str[i] = getchar()) != \u0026#39;\\n\u0026#39;) { nums[str[i]]++; i++;\t} //3.再遍历字符串，看一下，哪一个是只出现1次的字符 int flag = 0; // 表示没找到只出现一次的字符 i = 0; while(str[i]) { if(nums[str[i]] == 1) { cout \u0026lt;\u0026lt; str[i] \u0026lt;\u0026lt; endl; flag = 1; break;\t}\ti++; } if(flag == 0) cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 二、 string 1.string的概念 string字符串是一种更加高级的封装，string字符串串中包含了大量的方法\n在C++中将字符串直接作为一种类型，也就是string类型，使用string类型\n创建的对象就是C++的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 空字符串 string s2 = \u0026#34;abcd\u0026#34;; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } 2.string常见操作 文档\n2.1创建字符串 使用string来创建字符串需要包含头文件\u0026lt;string\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; // 空字符串 string s2 = \u0026#34;hello world\u0026#34;;//末尾不包含\\0 cout \u0026lt;\u0026lt; \u0026#34;s1:\u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s2:\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } string s1表示创建空字符串，相当于创建整型a，但是未给a一个初始值 string s2 = \u0026ldquo;hello world\u0026quot;表示创建一个字符串s2，它的内容是“hello world”，但是==string中字符串不再以\\0作为结束标志了== 除了以上的两种方式创建字符串，还有一些方式可以创建字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s3(\u0026#34;hello world\u0026#34;); string s4 = s3; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; return 0; } string创建的对象可以直接赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1(\u0026#34;hello world\u0026#34;); string s2 = \u0026#34;hehe\u0026#34;; s1 = s2; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // hehe //\tchar arr1[] = \u0026#34;hello world\u0026#34;; //\tchar arr2[] = \u0026#34;hehe\u0026#34;; //\tarr2 = arr1; // 数组名是数组首元素的地址，地址是一个常量值 //\t//3=5//err return 0; } 2.2 string字符串的输入 2.2.1cin的方式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string s(\u0026#34;hello\u0026#34;); //输入 std::cin \u0026gt;\u0026gt; s; //输出 std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; return 0; } cin在读取字符串的时候，如果遇到空格就不会继续读\n2.2.2getline的方式 getline是C++标准库中的一个函数，用于从输入流中读取一行文本，并将其存储为字符串\ngetline函数有两种不同的形式，分别对应着字符串的结束方式\nistream是输入流类型，cin是istream类型的标准输入流对象\nostream是输出流类型，cout是ostream类型的标准输出流对象\ngetline函数是输入流中读取一行文本信息，所以如果是在标准输入流（键盘）中读取\n数据，就可以传cin给第一个参数\n第一种getline函数以换行符\\n作为字符串的结束标志，它的一般格式是：\n1 2 string str; getline (cin, str); // cin 表示从输入流中读取信息，str 是存放读取到的信息的字符串 这种方式getline一直读到\\n才停止（不包含 \\n），然后将读到的文本存储到str中\n1 2 3 string s; getline(cin, s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 第二种getline函数允许用户自定义结束标志，它的一般格式是：\n1 getline (istream\u0026amp; is, string\u0026amp; str, char delim); cin \u0026ndash; 表示从输入流中读取信息\nstr是存放读取到的信息的字符串\ndelim是自定义的结束标志\n从输入流中读取文本，直到遇到用户指定的结束标志字符为止（不包括标志字符）\n1 2 3 string s; getline(cin, s, \u0026#39;q\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.3 size()求字符串长度 size()函数用于获取字符串的长度\n在C++中关于字符串的操作函数都是包含在string中的，所以需要调用这些函数时，\n通常用运算符.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1; string s2 = \u0026#34;hello\u0026#34;; string s3 = \u0026#34;hello world\u0026#34;; string s4 = \u0026#34;abc123 !#\u0026#34;; cout \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s3.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s4.size() \u0026lt;\u0026lt; endl; return 0; } string是C++提供的一种更加复杂的封装类型，在string类型的变量中加入了\n操作这个字符串的各种方法（函数），比如求字符串的长度，字符串末尾\n插入一个字符等操作。\n所以要对string类型的变量进行各种操作，就可以使用.操作符来使用这些函数\nstring类型的字符串是有下标的，可以实现逐个字符的打印\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; //逐个字符打印 int sz = s.size() ; int i = 0; for(i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; s[i]; } cout \u0026lt;\u0026lt; endl; return 0; } 2.4迭代器(iterator)遍历字符串 迭代器是一种对象，他可以用来遍历容器（比如string）中的元素\n迭代器的作用类似于指针或者数组下标，通过迭代器就可以逐个去找到它的元素\n不过，访问迭代器指向的值的时候，需要解引用*\nstring可以认为是存放字符的容器\nc++中的string提供了多种迭代器，用于遍历和操作字符串中的内容\n2.4.1begin()和end() begin()：返回指向字符串第一个字符的迭代器，需要一个迭代器的变量来接收 end()：返回指向字符串最后一个字符的下一个位置的迭代器 string中begin()和end()返回的迭代器的类型是string::iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; string::iterator it1 = s.begin(); string::iterator it2 = s.end(); //可以打印迭代器指向的那个字符 cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; endl; // 解引用操作 it1++; cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; endl; //可以比较大小 if(it1 \u0026lt; it2) cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;=\u0026#34; \u0026lt;\u0026lt; endl; //计算之间有多少个元素 cout \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; endl; return 0; } 使用迭代器的方式遍历字符串并打印\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; //遍历字符串，打印 //for(auto it1 = s.begin(); it1 \u0026lt; s.end(); it1++) // 可以写auto for(string::iterator it1 = s.begin(); it1 \u0026lt; s.end(); it1++) { cout \u0026lt;\u0026lt; *it1;\t} cout \u0026lt;\u0026lt; endl; return 0; } 还可以倒着打印\n1 2 3 4 5 for(string::iterator it1 = s.end()-1; it1 \u0026gt;= s.begin(); --it1) { cout \u0026lt;\u0026lt; *it1;\t} cout \u0026lt;\u0026lt; endl; 可以通过迭代器找到元素，还可以进行修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; for(string::iterator it = s.begin(); it \u0026lt; s.end(); it++) { *it = \u0026#39;x\u0026#39;; } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.5 push_back()尾部插入 作用：在字符串尾部插入一个字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello \u0026#34;; s.push_back(\u0026#39;w\u0026#39;); s.push_back(\u0026#39;o\u0026#39;); s.push_back(\u0026#39;r\u0026#39;); s.push_back(\u0026#39;l\u0026#39;); s.push_back(\u0026#39;d\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 可以连续插入，如输入26个字母\n1 2 3 4 5 6 string s; for(char i = \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;z\u0026#39;; i++) { s.push_back(i); } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.6字符串的+=和+运算 +=会将原字符串改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello \u0026#34;; s += \u0026#34;world\u0026#34;; // 也可以只+=一个字符 cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } +不会改变原字符串\n1 2 3 string s1 = \u0026#34;hello \u0026#34;; cout \u0026lt;\u0026lt; s1 + \u0026#34;world\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; 字符串可以头部拼接\n1 2 3 string s2 = \u0026#34;hello\u0026#34;; s2 = \u0026#34;world\u0026#34; + s2; // worldhello cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; 2.7 pop_back()尾部删除 pop_back()用于删除字符串中尾部的一个字符。\n使用该函数需要先做一下配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello\u0026#34;; s.pop_back(); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; return 0; } 当一个字符串是空字符串的时候，不能再调用pop_back，这是一种标准未定义的行为\n1 2 string s; s.pop_back(); 如何一个字符一个字符地删除呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello\u0026#34;; //一个字符一个字符的删 while(s.size()) { s.pop_back(); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; // 0 return 0; } 2.8 insert任意位置插入 我们之前学过push_back即在字符串的末尾插入字符，那如果我们想在字符串的中间插入\n字符呢？我们可以使用成员函数insert\n文档\n在这里，我们先学3种：\n在pos前面插入一个string字符串 1 string\u0026amp; insert(size_t pos, const string\u0026amp; str); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; string str = \u0026#34;xxx\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 在3这个下标前面插入str中的字符串 s.insert(3, str); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } pos位置前面插入一个C风格的字符串 1 string\u0026amp; insert(size_t pos, const char* s); 1 2 3 4 5 6 7 string s = \u0026#34;abcdef\u0026#34;; string str = \u0026#34;xxx\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 在3这个下标前面插入字符串\u0026#34;xxx\u0026#34; s.insert(3, \u0026#34;xxx\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; pos位置前面插入n个字符c 1 string\u0026amp; insert(size_t pos, size_t n, char c); 1 2 3 4 5 6 7 string s = \u0026#34;abcdef\u0026#34;; string str = \u0026#34;xxx\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 在3这个下标前面插入1个字符\u0026#39;x\u0026#39; s.insert(3, 1, \u0026#39;x\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; 2.9 find()查找字符/子串 find()函数用于查找字符串中指定子串/字符，并返回子串/字符在字符串中第一次出现的位置\n查找string类型的字符串str，默认是从头开始查找，pos可以指定位置开始\n返回值：\n若找到。返回子串/字符在字符串中第一次出现的起始下标位置\n若未找到。返回一个整数值npos。\n通常判断find()函数的返回值是否等于npos就能知道是否查找到子串或字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; string str = \u0026#34;llo\u0026#34;; //默认从头开始查找 size_t n = s.find(str); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; //可以指定要查找的位置 n = s.find(str, n + 1); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 查找C风格的字符串s，默认是从头开始查找，pos可以指定位置开始\n1 2 3 string s = \u0026#34;hello world hello everyone\u0026#34;; size_t n = s.find(\u0026#34;llo\u0026#34;); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; 在字符串的pos这个位置开始查找C风格的字符串s中的前n个字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; //从字符串s下标为0处开始，找word的前3个字符 size_t n = s.find(\u0026#34;word\u0026#34;, 0, 3); // 6 cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; n = s.find(\u0026#34;everyday\u0026#34;, n + 1, 5); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 查找字符c，默认是从头开始，pos可以指定位置开始\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; //查找字符o int n = s.find(\u0026#39;o\u0026#39;); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; n = s.find(\u0026#39;o\u0026#39;, n + 1); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 如果查找不到，会返回npos的值-1，转为无符号整型就是一个非常大的数字\n2.10 substr()截取子串 截取字符串中指定位置指定长度的子串（截取一个字符串中的某个子串）\nsubstr()：不传参数，就从下标为0的位置开始截取，直到结尾，得到的\n​\t是整个字符串\nsubstr(pos)：从指定下标pos位置开始截取子串，直到结尾\nsubstr(pos,len)：从指定下标pos位置开始截取长度为len的子串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;hello world hello everyone\u0026#34;; string s1 = s.substr(); // 得到整个字符串 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; //从下标为7的位置开始截取字符串，[7, 末尾] string s2 = s.substr(7); cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; //从下标为7的位置开始截取6个字符 string s3 = s.substr(7, 6); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; return 0; } substr()和find()经常配合使用，find()负责查找到位置，substr()从这个位置开始\n向后获得字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { //substr()通常和find()配合使用 string s = \u0026#34;hello world hello everyone\u0026#34;; // 0123456 size_t n = s.find(\u0026#34;world\u0026#34;); string s1 = s.substr(n, 5); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; return 0; } 3.string的关系操作 应用场景：\n登录一个网站，输入的密码要和数据库中正确的密码比较\n介绍：\n我们之前学过C/C++中的内置类型，比如：bool、char、int、long等这些都是\n天然支持关系操作符（\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、==、！=）的。但是string是一种C++\n中封装类型，需要使用运算符重载才能支持关系运算符\nstring字符串和string字符串比较 C风格字符串和string字符串比较， string字符串和C风格字符串比较 注意：至少有一个参数是string类型的字符串。\n​\t两个C风格的字符串只能用strcpy来比较\n字符串比较的规则：比较的是对应位置上字符的ASCII值的大小。不是比较长度\n1 2 3 4 \u0026#34;abc\u0026#34; \u0026lt; \u0026#34;aq\u0026#34; \u0026#34;abcdef\u0026#34; \u0026lt; \u0026#34;ff\u0026#34; \u0026#34;100\u0026#34; \u0026lt; \u0026#34;9\u0026#34; \u0026#34;abc\u0026#34; == \u0026#34;abc\u0026#34; 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s1 = \u0026#34;hello world\u0026#34;; string s2 = \u0026#34;hello\u0026#34;; if(s1 == s2 + \u0026#34;world\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;==\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;!=\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 4.和string相关的函数 4.1 stoi/stol stoi是将字符串转换成int类型的值\nstol是将字符串转换成long int类型的值\nstr：要转换的字符串\nidx：是一个输出型参数，也就是这个通过这个参数会带回一个值。\n​\tidx是一个指针，需要在外边创建一个size_t类型的值，传递它的\n​\t地址给idx，这个参数将带回str中无法正确匹配数字的第一个字符\n​\t的位置(下标)\nbase：被解析的字符串中数字的进制值，\n2、8、10、16表示将2或8或10或16进制转换成10进制\n如果传递的是0，会根据字符串的内容的信息自动推导进制\n比如：字符串中有0x就认为是16进制，0开头会被认为是8进制\n最终会转换成10进制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;11x22\u0026#34;; // 01234 size_t pos = 0; int r = stoi(s, \u0026amp;pos); // 默认认为s中的数字是10进制的 cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pos=\u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; return 0; } 如果不想要返回的下标，可以传NULL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;11x22\u0026#34;; // 2^1 + 2^0 = 3 size_t pos = 0; int r = stoi(s, \u0026amp;pos, 2); // 认为s中的数字是2进制的 cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; // 3 cout \u0026lt;\u0026lt; \u0026#34;pos=\u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; return 0; } 4.2 stod/stof stod将字符串转换成double类型的值\nstof是将字符串转换成float类型的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;3.14abc234\u0026#34;; size_t pos; double d = stod(s, \u0026amp;pos); //double d = stod(s, 0); //double d = stod(s, NULL); cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;pos = \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; // 4 return 0; } 4.3 to_string to_string函数可以将数字转换成字符串，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { //string s = to_string(3.14); //\tstring s = to_string(110); //\tcout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; string pi = \u0026#34;pi is \u0026#34; + to_string(3.14); cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; endl; return 0; } 题目 思路1：\n读取整个字符串（可能包含空格），cin遇到空格就结束了，getline函数\n可以\n统计字符串中字符的个数，不包含空格和换行符，遍历字符串\n下标 范围for 迭代器 空格和换行符 \u0026ndash; 空白字符\nisspace \u0026ndash; 专门用来判断一个字符是否是空白字符，需要包含头文件cctype\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int main() { string s; //1.读取 getline(cin, s); //2.分析和统计 int cnt = 0; for(auto e : s) { if(isspace(e)) continue; else cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } 下标的方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { string s; //1.读取 getline(cin, s); //2.分析和统计 int sz = s.size(); int cnt = 0; for(int i = 0; i \u0026lt; sz; i++) { if(isspace(s[i])) continue; else cnt++: } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } 方法2：\n逐个单词的方式读取，计算所有单词的字符串长度 \u0026ndash; 求和\ncin \u0026raquo; s会返回一个流对象的引用，即cin本身。\n​\t在C++中，流对象（如cin）可以被用作布尔值来检查流的状态。\n​\t如果流的状态良好（即没有发生错误），流对象的布尔值为true\n​\t如果发生错误（如遇到输入结束符或类型不匹配），布尔值为false\n在while(cin \u003e\u003e s)语句中，循环的条件部分检查cin流的状态。\n如果流成功读取到一个值，cin\u0026raquo;s返回的流对象cin将被转换为true，循环将继续。\n如果读取失败（例如遇到输入结束符或无法读取到一个值），cin \u0026raquo; s返回的流\n对象cin将被转换为false，循环将停止\n题目 思路：\n1.输入字符串 - string 2.输入带空格的字符串 getline 3.循环处理字符串中的每个字符，解密 如果是b~z(B~Z)的字母，直接-1，就是解密后的字符 如果是a/A \u0026ndash;\u0026gt; z/Z 其余字符不变\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s; //输入 getline(cin, s); //遍历字符串 int i = 0; for(i = 0; i \u0026lt; s.size(); i++) { if((s[i] \u0026gt;= \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;z\u0026#39;) || (s[i]) \u0026gt;= \u0026#39;B\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;Z\u0026#39;) s[i] -= 1; else if(s[i] == \u0026#39;a\u0026#39;) s[i] = \u0026#39;z\u0026#39;; else if(s[i] == \u0026#39;A\u0026#39;) s[i] = \u0026#39;Z\u0026#39;; } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } reverse 需要包含头文件\u0026lt;algorithm\u0026gt;\nfirst：指向要反转范围的第一个元素的迭代器（也可以是地址）\nlast：指向要反转范围的最后一个元素的下一个位置的迭代器（也可以是地址）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { string s = \u0026#34;abcdef\u0026#34;; reverse(s.begin(), s.end()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 也可以逆序整型数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int sz = sizeof(arr) / sizeof(arr[0]); reverse(arr, arr + sz);//可以传地址 for(int e: arr) { cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 题目 句子只包含英文小写字母和空格\n思路：\n输入字符串 - 包含空格 getline\n遍历字符串，计算每个字符的按键次数，然后累加在一起\n26个小写英文字母，每个字母都有自己的按键次数 把26个字母的按键次数存储下来 \u0026ndash; 使用数组 当有一个字符来的时候，就将这个字符的按键次数累加上去 数组下标是从0开始的，让英文字母-\u0026lsquo;a\u0026rsquo;得到对应下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int count[26] = {1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4}; int main() { //\t1.输入字符串 - 包含空格 getline int n = 0; string s; getline(cin, s); //\t2.遍历字符串，计算每个字符的按键次数，然后累加在一起 for(char ch: s) { //查看ch这个字符的按键次数 if(ch == \u0026#39; \u0026#39;) n += 1; else n += count[ch-\u0026#39;a\u0026#39;]; } cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } 题目 输入：\n1.第一个是字符代表操作，后面两个是数字\n2.输入的两个是数字，表示进行上一次的操作 \u0026ndash; 上一次的操作需要保存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int i = 0; cin \u0026gt;\u0026gt; i; string op;//操作 string last; while(i--) { //输入数据 int n1, n2; int r;//计算结果 string ans; cin \u0026gt;\u0026gt; op; if(op \u0026lt;mark\u0026gt; \u0026#34;a\u0026#34; || op \u0026lt;/mark\u0026gt; \u0026#34;b\u0026#34; || op == \u0026#34;c\u0026#34;) { cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2; ans += to_string(n1); if(op == \u0026#34;a\u0026#34;) { //加法运算 r = n1 + n2; ans += \u0026#34;+\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r);\t} else if(op == \u0026#34;b\u0026#34;) { //减法运算\tr = n1 - n2; ans += \u0026#34;-\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); } else { //乘法运算 r = n1 * n2; ans += \u0026#34;*\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); }\tlast = op; } else // 这一行有两个数据，执行上一次的运算 { n1 = stoi(op); cin \u0026gt;\u0026gt; n2; ans += to_string(n1); if(last == \u0026#34;a\u0026#34;) { //加法运算 r = n1 + n2; ans += \u0026#34;+\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r);\t} else if(last == \u0026#34;b\u0026#34;) { //减法运算\tr = n1 - n2; ans += \u0026#34;-\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); } else { //乘法运算 r = n1 * n2; ans += \u0026#34;*\u0026#34;; ans += to_string(n2); ans += \u0026#34;=\u0026#34;; ans += to_string(r); } }\tcout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; endl; } return 0; } ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-array-and-string/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-array-and-string/","title":"【从零开始学C++】02数组+string"},{"content":"一、C/C++输入输出（下） 1.OJ题目输入情况汇总 OJ（online judge）\n![73643384864](【从零开始学C++】03输入输出（下）+ 函数.assets/1736433848645.png)\n1.1单组测试数据 程序运行1次，只处理一组数据\n要处理多组数据，需要运行多次\n1.2 多组测试数据 程序运行一次，会处理多组数据\n测试数据组数已知 测试数据组数未知 特殊值结束测试数据 ![73651820582](【从零开始学C++】03输入输出（下）+ 函数.assets/1736518205822.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n1,n2; while(cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2, n1 || n2) { cout \u0026lt;\u0026lt; n1 + n2 \u0026lt;\u0026lt; endl; } return 0; } 逗号表达式\n从左向右依次计算 整个表达式的结果是最后一个表达式的结果 2.输入中的特殊技巧 2.1含空格字符串的输入技巧 含有空格的字符串，读取有四种方式：fgets、scanf、getchar、getline四种\n1 2 char arr[20]; fgets(arr, 20, stdin); // stdin 标准输入流 -- 键盘 1 2 char arr[20]; scanf(\u0026#34;%10s\u0026#34;, arr); // 最多读10个字符 1 2 3 4 5 6 7 char ch = 0; int i = 0; while((ch = getchar()) != \u0026#39;\\n\u0026#39;) { arr[i] = ch; i++; } 1 2 string str; getline (cin, str); // getline遇到换行就结束 fgets会读取\\n，并在读取的内容后面自动加上\\0\nscanf(%[num]s)不会读取\\n，但会在读取的内容后面加上\\0\ngetchar读取一个字符，所以\\n会读取\ngetline不会读取\\n，第三个参数可以指定结束的标志字符\n有时候不一定要完整读取这个带空格的字符串，而是将字符串当做一个个单词处理\n2.2数字的特殊处理方式 当程序运行时，我们从控制台输入123的时候，其实是输入的123是3个字符\n但是编译器会根据代码中的数据类型，将读取到的字符序列解析成对应类型的数据\n1 2 3 4 5 int num = 0; cin \u0026gt;\u0026gt; num;//输入的123会被解析成整型 string s; cin \u0026gt;\u0026gt; s;//输入的123会被解析成字符串 题目 ![73659341173](【从零开始学C++】03输入输出（下）+ 函数.assets/1736593411737.png)\n方法一：权重\n读取整个整数，然后%10得到一位，/10去掉一位\n由于十进制的每一位都有权重，所以如果我们得到的一位是奇数，那么就\n1*10^位数， 如果是偶数就是0*10^位数，然后将它们相加\n![73659346311](【从零开始学C++】03输入输出（下）+ 函数.assets/1736593463116.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int ret = 0; int i = 0; while(n) { if(n % 10 % 2) ret += 1 * pow(10, i); n /= 10; i++; } cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; return 0; } 方法二：当成字符串读取\n当成字符串读取，然后遍历字符串，修改字符串中的字符，最后输出时需要转换成\n整型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { char ch; string s; while(cin \u0026gt;\u0026gt; ch) { if(ch % 2 == 0) s += \u0026#39;0\u0026#39;; else s += \u0026#39;1\u0026#39;; } cout \u0026lt;\u0026lt; stoi(s) \u0026lt;\u0026lt; endl; return 0; } 3.scanf-printf和cin-cout的区别 3.1格式控制差异 prinf和scanf需要手动指定格式字符串，而cin和cout会自动推导类型 prindf和scanf格式化输出更精确和直观 prinf在打印的时候默认打印小数点后六位，cout会自动忽略小数点后多余的0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { float a = 3.50; double d = 16.50; cout \u0026lt;\u0026lt; \u0026#34;cout:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; printf(\u0026#34;printf:%f %lf\\n\u0026#34;, a, d); return 0; } ![73659997632](【从零开始学C++】03输入输出（下）+ 函数.assets/1736599976322.png)\n3.2cin-cout性能问题 通常scanf和prinf比cin和cout快\n**原因：**cin和cout由于要考虑兼容C语言的输入和输出，封装实现的更加复杂\n这种差异在大多数应用场景中可以忽略不计，但是在竞赛中，当输入输出数据量\n较大的时候，使用cin和cout就可能出现Time Limit Exceeded\n总结性能低的原因：\nC++中为了支持混合使用cin/cout和printf/scanf，C++标准库默认会将cin/cout\n等C++流对象与stdin/stdout等C标准库的流对象同步在一起。这种同步操作意味着每次使用cin/cout时，都会自动刷新C标准库的缓冲区，以确保C++和C的I/O是一致的\n在默认情况下，cin和cout之间存在一种绑定关系。这种绑定关系意味着每当cin\n读取数据时，任何之前通过cout输出的内容都会被强制刷新到屏幕上。这种绑定\n也可能导致性能问题，特别是在需要频繁读取大量数据的情况下\n3.3 优化方案和演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;iostream\u0026gt; #include\u0026lt;ctime\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; const int num = 10000000; int main() { ios::sync_with_stdio(false); //取消给C语⾔输⼊输出缓冲区的同步 cin.tie(0); //取消了cin和cout的绑定 freopen(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); int i, x; clock_t t1, t2; t1 = clock(); for (i = 0; i \u0026lt; num; i++) { cin \u0026gt;\u0026gt; x; } t2 = clock(); cout \u0026lt;\u0026lt; \u0026#34;Runtime of cin: \u0026#34; \u0026lt;\u0026lt; t2 - t1 \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; endl; return 0; 如果追求性能，那就使用scanf/printf或优化后的cin/cout\n如果输入的数据量比较小（10^6以内）的话，用cin/cout和prinf/scanf都行\n如果输入的数据量比较大（10^9左右）的话，更推荐使用scanf/printf，避免\n因为输入输出的开销，导致代码超时\n当输入输出的规模非常大的时候，scanf/printf也不能满足的时候，使用快速读写\n![73673888732](【从零开始学C++】03输入输出（下）+ 函数.assets/1736738887320.png)\n![73673901841](【从零开始学C++】03输入输出（下）+ 函数.assets/1736739018416.png)\n二、 函数 ![73673906487](【从零开始学C++】03输入输出（下）+ 函数.assets/1736739064879.png)\n1.函数是什么 函数就是一个完成某项特定的任务的一小段代码\n函数的好处：\n模块化开发\n一个大的功能，总能拆分成各种子功能，每个子功能都可以设计成一个函数\n每个函数可以作为一个独立的模块存在，程序的逻辑更加清晰、明确\n代码可以复用\n只需要定义出一个函数，需要这个功能的地方，直接调用函数就行\n方便多个程序员之间协作开发，方便程序的多个模块之间互相交互\n代码的编写、阅读、调试、维护都更加容易\n2.函数的分类 2.1库函数 库函数是标准库中提供的现成的函数，我们只要学习函数的功能，就能直接使⽤。\n有了库函数，⼀些常⻅的功能就不需要程序员⾃⼰实现了，⼀定程度提升了效率；同时库\n函数的质量和执⾏效率上都更有保证。\n编译器的标准库中提供了⼀系列的库函数，这些库函数根据功能的划分，都在不同的头⽂\n件中进⾏了声明。\nC/C++官⽅参考⼿册：https://zh.cppreference.com/w/cpp/header\nC/C++第三⽅⽹站：https://legacy.cplusplus.com/reference/\n2.1.1库函数使用举例 sqrt 开平方 需要包含头文件cmath\n![73677951902](【从零开始学C++】03输入输出（下）+ 函数.assets/1736779519025.png)\nsqrt是函数名\nx是函数参数，表示调用sqrt函数需要传递一个double类型的值\ndouble是返回值类型，表示函数计算的结果是double类型的值\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double x = 16.0; double r = sqrt(x); cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl;//4 return 0; } pow次方 ![73678004485](【从零开始学C++】03输入输出（下）+ 函数.assets/1736780044851.png)\n它接受两个参数，第一个参数是底数，第二个参数是指数，然后返回底数的指数次幂的结果。\n例如，pow(2,3)会计算 2 的 3 次方，结果为 8。\n2.2自定义函数 ![73684004497](【从零开始学C++】03输入输出（下）+ 函数.assets/1736840044977.png)\n3.函数参数和返回值 3.1实参 实参就是真实传递给函数的参数\n3.2形参 形参只有在函数调用的时候才会向内存申请空间，\n而如果不去调用函数，那么形参只是形式上存在，不会向内存申请空间\n形参是实参的一份临时拷贝 形参有自己独立的空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; int Add(int n1, int n2) { return n1 + n2; } int main() { int a = 0; int b = 0; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int r = Add(a, b);\tcout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } 在Add函数中，返回值会先把值放到寄存器中，然后再把寄存器里的值赋值给\nmain函数中的r\n原因：返回值是局部变量，函数一旦调用结束，返回值的这块空间\n就要还给操作系统，这样就没办法把值带给r，所以会先备份到寄存器\n寄存器是CPU上的一个硬件，是一个存储空间\n数组传参\n形参如果是二维数组，那么行可以省略，但是列不能省略 形参的数组和实参的数组是同一个数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; void test(int arr[][5], int r, int c) { for(int i = 0; i \u0026lt; r; i++) { for(int j = 0; j \u0026lt; c; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } int main() { int arr[3][5] = {{1,2, 3, 4, 5}, {2, 3, 4, 5, 6}, {3, 4, 5, 6, 7}}; test(arr, 3, 5); return 0; } 字符串做函数参数\n如果将字符串做函数参数，那么形参的改变也不会影响实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; void test(string s) { s = \u0026#34;hehe\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } int main() { string s = \u0026#34;hello world\u0026#34;; test(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } ![73684437438](【从零开始学C++】03输入输出（下）+ 函数.assets/1736844374385.png)\n全局变量在整个程序中都可以使用，不用传参\n3.3 返回值 返回值可以是一个数值，也可以是一个表达式，也可以什么都没有\n如果有返回值，也可以选择不接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; void test(int n) { if(n == 2) return; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } int main() { test(1); test(2); test(5); return 0; } return 会彻底结束该函数，该函数后面的代码不会再执行\n4.函数的声明和调用 4.1函数的声明 函数声明只需要返回类型 函数名(函数参数);\n注意\n函数要满足先声明，后使用 函数的定义是一种特殊的声明 4.2函数的调用 4.2.1传值调用 4.2.2引用 引用不是新定义一个变量，而是给已经存在的变量取了一个别名\n编译器不会为引用变量开辟内存空间，它和它引用的变量是同一块空间\n语法：类型\u0026amp; 引用变量名 = 引用实体;\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; int\u0026amp; ra = a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //10 cout \u0026lt;\u0026lt; ra \u0026lt;\u0026lt; endl; //10 return 0; } 注意\n引用在定义时必须初始化\n1 int\u0026amp; a; // err 一个变量可以有多个引用\n1 2 3 4 5 6 7 int a = 10; int\u0026amp; r1 = a; int\u0026amp; r2 = a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//10 cout \u0026lt;\u0026lt; r1 \u0026lt;\u0026lt; endl;//10 cout \u0026lt;\u0026lt; r2\u0026lt;\u0026lt; endl;//10 引用一旦引用一个实体，就不能引用其它实体了\n1 2 3 4 5 6 7 8 9 int a = 10; int b = 20; int\u0026amp; r1 = a; int\u0026amp; r2 = a; r1 = b;//赋值 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; r1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; r2\u0026lt;\u0026lt; endl; ![73684876729](【从零开始学C++】03输入输出（下）+ 函数.assets/1736848767291.png)\n4.2.3传址（引用）调用 string类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void test(string\u0026amp; s1) { cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl;//hello world s1 = \u0026#34;hehe\u0026#34;; } int main() { string s = \u0026#34;hello world\u0026#34;; test(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl;//hehe return 0; } 改造Swap函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Swap(int\u0026amp; x, int\u0026amp; y) { int z = x; x = y; y = z; } int main() { int a = 0, b = 0; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;交换前：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; Swap(a, b); cout \u0026lt;\u0026lt; \u0026#34;交换后：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 库函数swap\n![73684955900](【从零开始学C++】03输入输出（下）+ 函数.assets/1736849559002.png)\n这个函数可以用来交换两个变量，也可以交换两个数组（容器的值）\n使用需要包含头文件\u0026lt;utility\u0026gt;\n1 2 3 int arr1[4] = {0}; int arr2[4] = {10, 20, 30, 40}; swap(arr1, arr2); 5.函数重载 C++中函数重载是指在同一个作用域中可以有多个同名函数，\n要求函数名相同，但是形参列表不同（形参个数、顺序、类型 至少一个不同）\n![73685249908](【从零开始学C++】03输入输出（下）+ 函数.assets/1736852499089.png)\n6.函数练习 6.1库函数max和min max用于返回两个值中的较大值，使用要包含头文件\u0026lt;algorithm\u0026gt;\nmax函数可以用于各种类型，包括内置类型（如int、double、类、结构体）\n![73691021986](【从零开始学C++】03输入输出（下）+ 函数.assets/1736910219867.png)\n![73691039359](【从零开始学C++】03输入输出（下）+ 函数.assets/1736910393591.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int a = 10; int b = 20; int m = max(a, b); cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; //提供一个返回布尔值的函数，表示第一个参数是否小于第二个参数 bool cmp_str(string str1, string str2) { return str1.size() \u0026lt; str2.size(); } int main() { string s1 = \u0026#34;abcdef\u0026#34;; string s2 = \u0026#34;bcq\u0026#34;; //默认按照对应位置的ASCII码值的大小比较 //\tstring m = max(s1, s2); //\tcout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; //指定比较方式，如按照字符串的长度来比较 string m = max(s1, s2, cmp_str); cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 题目 ![73693818082](【从零开始学C++】03输入输出（下）+ 函数.assets/1736938180826.png)\n法1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int n = 0; int _max, _min; int t = 0; cin \u0026gt;\u0026gt; n; //读取第一个数字 cin \u0026gt;\u0026gt; t; //假设第一个数就是最大值/最小值 _max = _min = t; for(int i = 1; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; t; _max = max(_max, t); _min = min(_min, t);\t} cout \u0026lt;\u0026lt; _max - _min \u0026lt;\u0026lt; endl; return 0; } 法二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int n = 0; //整数范围0~100 int _max = 0; int _min = 100; int t = 0; cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; t; _max = max(_max, t); _min = min(_min, t);\t} cout \u0026lt;\u0026lt; _max - _min \u0026lt;\u0026lt; endl; return 0; } 题目 ![73709219291](【从零开始学C++】03输入输出（下）+ 函数.assets/1737092192913.png)\n思路：\n输入M、N 产生[M，N]之间的数 for(int i = m; i \u003c= n; i++) 判断i是否是真素数 i是素数 i的反序也是素数 产生反转后的数 转成string类型，reverse()，stoi 反转思路2：\nint ret = 0;\nret = ret * 10 + i % 10;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool is_prime(int m) { //素数：只能被1和自身整数的数 if(m \u0026lt;= 1) return false; //产生2~sqrt(m)之间的数，去试除m for(int i = 2; i \u0026lt;= sqrt(m); i++) { if(m % i == 0) return false;\t} return true; } //int reverse_int(int k) //{ //\tstring s = to_string(k); //\treverse(s.begin(), s.end()); //\treturn stoi(s); //} int reverse_int(int k) { if(k \u0026lt;= 9) return k; int ret = 0; while(k) { ret = ret * 10 + k % 10; k /= 10; } return ret; } int main() { //\t思路： //\t1.输入M、N //\t2.产生[M，N]之间的数 for(int i = m; i \u0026lt;= n; i++) //\t3.判断i是否是真素数 //\t1)i是素数 //\t2)i的反序也是素数 //\t1)产生反转后的数 //\t2)转成string类型，reverse()，stoi int M, N; int flag = 0; cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N; for(int i = M; i \u0026lt;= N; i++) { //产生i的反序数字 i2 int i2 = reverse_int(i); //判断i和i2是否同时为素数 if(is_prime(i) \u0026amp;\u0026amp; is_prime(i2)) { if(flag) cout \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; i; flag = 1; } } if(flag == 0) cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 7.递归 7.1递归概念 递归具体是指函数在定义的时候直接或间接调用自身的方式（函数自己调用自己）\n每一次函数调用都要向栈区申请空间\n最简单的递归：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;hehe\u0026#34; \u0026lt;\u0026lt; endl; main();//调用main函数自己 return 0; } 7.2 递归思想 递归可以把一个大型复杂问题层层转化为一个与原问题相似，但规模较小的子问题\n来求解，直到子问题不能再被拆分，可以直接求解，递归就结束了。\n递归的思考方式就是把大事化小的过程\n递归就是递推回归的意思\n7.3递归的必要条件 递归在书写的时候，需要满足两个必要条件\n递归存在限制条件，当满足这个限制条件的时候，递归就不再继续 每次递归调用后会越来越接近这个限制条件 例子1：求n的阶乘\n![73710956984](【从零开始学C++】03输入输出（下）+ 函数.assets/1737109569841.png)\n![73712053928](【从零开始学C++】03输入输出（下）+ 函数.assets/1737120539288.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int Fact(int n) { //4！= 1 * 2 * 3 * 4 = 3! * 4 //n! = n*(n-1)! //0的阶乘=1 if(n == 0) return 1; else return n * fac(n-1);\t} int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; Fact(n) \u0026lt;\u0026lt; endl; return 0; } 例子2：求第n个斐波那契数\n![73712213097](【从零开始学C++】03输入输出（下）+ 函数.assets/1737122130971.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; //int Fib(int i) //{ //\tif(i \u0026lt;= 2) //\treturn 1; //\telse //\treturn Fib(i-1) + Fib(i-2); //} int Fib(int i) { int a = 1; int b = 1; int c = 1; while(i \u0026gt;= 3) { c = a + b; a = b; b = c; i--; } return c; } int main() { //思路： //1.第1个和第2个数是1，从第3个数开始， // 后一个数等于前两个数之和 //2. res = (n-1) + (n-2) int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; Fib(n) \u0026lt;\u0026lt; endl; return 0; } 7.4 递归和循环（迭代） ![73712202818](【从零开始学C++】03输入输出（下）+ 函数.assets/1737122028184.png)\n8.递归练习 题目 ![73728483547](【从零开始学C++】03输入输出（下）+ 函数.assets/1737284835477.png)\n![73728480219](【从零开始学C++】03输入输出（下）+ 函数.assets/1737284802191.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; int digit(int n, int k) { if(k == 1) return n % 10; else return digit(n / 10, k - 1); } int main() { //思路 //1.输入正整数n和从右边数第k个数字 //2.k=1，n%10 //\tk=2，n/10 k=1，n%10 //\tk=3，n/10 k=2，n/10 k=1，n%10 //\tk=N，n/10 k=2，n/10 ... k=1，n%10 int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; digit(n, k) \u0026lt;\u0026lt; endl; return 0; } 题目 ![73729284578](【从零开始学C++】03输入输出（下）+ 函数.assets/1737292845785.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; double f(double x, int n) { if(n == 1) return sqrt(1 + x); else if(n \u0026gt; 1) return sqrt(n + f(x, n-1)); } //f(x,n) //n==1，sqrt(1+x) //n\u0026gt;1，sqrt(x+f(x,n-1)) int main() { double x; int n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; double r = f(x, n); printf(\u0026#34;%.2lf\\n\u0026#34;, r); return 0; } 题目 ![73729658314](【从零开始学C++】03输入输出（下）+ 函数.assets/1737296583148.png)\n![73729666422](【从零开始学C++】03输入输出（下）+ 函数.assets/1737296664221.png)\n![73729669292](【从零开始学C++】03输入输出（下）+ 函数.assets/1737296692923.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; string s = \u0026#34;0123456789ABCDEF\u0026#34;; void x_to_m(int x, int m) { //1.如果x\u0026gt;=m if(x \u0026gt;= m) x_to_m(x / m, m); //2.x\u0026lt;m，直接打印该数字 cout \u0026lt;\u0026lt; s[x % m]; } int main() { int x,m; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; m; x_to_m(x, m);\treturn 0; } ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-io-and-function/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-io-and-function/","title":"【从零开始学C++】03输入输出（下）+ 函数"},{"content":"位运算操作符只适用于整型和字符型\n1.操作符的分类 2.二进制和进制转换 2进制，8进制，10进制，16进制是数值的不同表示形式\n例如：10进制下的15 对应\n​\t2进制的 1111\n​\t8进制的 17\n​\t16进制的 F\n16进制的数以0x开头\n8进制的数以0开头\n2.1 其它进制转10进制 进制的每一位都是有权重的，比如10进制的123\n3*10^0^+2*10^1^+1*10^2^ = 3+20+100=123\n2进制同理\n2.2 转2进制 （1）10转2\n将十进制数字除2的余数倒过来\n（2）八转二\n从低位开始，每一位转成3个相应的二进制数即可\n（3）十六转二\n从低位开始，每一位转成4个相应的二进制数即可\n2.3 2进制转8进制 8进制的数字范围：0~7\n从低位开始，每三位为一组，转成相应的八进制数即可\n2.4 2进制转16进制 从低位开始，每四位为一组，转成相应的十六进制数即可\n2.5原码、反码、补码 整数的2进制表示形式有3种：原码、反码、补码\n整数又分为有符号整数和无符号整数\n有符号整数的原码、反码、补码的二进制表示中均由符号位和\n数值位两部分组成\n1.二进制的最高位（最左边）是符号位：0表示正数，1表示负数\n2.正数原码，反码，补码都一样（三码合一）\n3.==负数的反码=它的原码符号位不变，其它位取反（0变1,1变0）==\n4.==负数的补码=它的反码+1==，负数的反码=负数的补码-1\n补码转原码：-1，取反（符号位不变）注意：正数三码合一\n注意\n0的反码，都是0\n在计算机运算的时候，都是以补码的方式来运算的\n(补码把正数和负数统一起来了)\n看运算结果，要看原码\n题目 法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { //1.输入x，s int x; int ret = 0; string s; cin \u0026gt;\u0026gt; x; cin \u0026gt;\u0026gt; s; //2.求出s的长度 int n = s.size(); //3.遍历字符串（从后往前遍历） int j = 0; for(int i = n - 1; i \u0026gt;= 0; i--) { //\t1)找出每一个字符-转换成整数 //\t如果是数字字符，让其减字符0； //\t如果是字母字符，让其减字符A，再加10 //\t2)再乘以这一位的权重 //\t3)最终求和 if(s[i] \u0026lt;= \u0026#39;9\u0026#39;) ret += (s[i] - \u0026#39;0\u0026#39;) * pow(x, j); else ret += (s[i] - \u0026#39;A\u0026#39; + 10) * pow(x, j); j++; } cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; return 0; } 法二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int x; string s; cin \u0026gt;\u0026gt; x; cin \u0026gt;\u0026gt; s; int ret = stoi(s, NULL, x); cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; return 0; } 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; string s = \u0026#34;0123456789ABCDEF\u0026#34;; void x_to_m(int x, int m) { if(x \u0026gt;= m) x_to_m(x / m, m); cout \u0026lt;\u0026lt; s[x % m]; } int main() { int n, m; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; m; //1.将s中的n进制数字转为10进制的整数 int x = stoi(s, NULL, n); //2.将x转换成m进制 x_to_m(x, m); return 0; } 3.位运算操作符 2进制序列中，最高位的1位是被当做符号位\n符号位都是用0表示正”，用1表示负 对于整形来说：数据存放内存中其实存放的是补码。 计算用补码，结果要看原码（即用补码计算完后要把补码转为原码） 左移右移都不能移符号位\n左移操作符（乘2的效果）\na \u0026laquo; 1 对原变量无影响\na\u0026laquo;= 1 左移后赋给自己\n乘2的效果，主要针对正数/无符号数\n右移操作符（除2的效果）\n逻辑右移，左边补0\n算数右移（通常是），左边原来是正数：补0\n​ 负数：补1\n\u0026amp;按位与（二进制位的运算）\n对应二进制位 同为1，才为1；有0为0\n按位或（二进制位的计算）\n有1为1；同时为0，才为0\n^按位异或（二进制位的运算）\n相同为0，相异为1，不存在进位，不会溢出\n0 ^ 任何数 = 任何数本身 自身^自身 = 0 支持交换律 3 ^ 5 ^ 3=5 ~按位取反（二进制位），1个对象，0变1,1变0\n4.位运算的应用 4.1判断奇数和偶数 规律1：\n所有偶数的2进制表示中，最低位一定是0, 所有奇数的2进制表示中，最低位一定是1 规律2：\n(x \u0026 1) == 0，说明x是偶数 (x \u0026 1) == 1，说明x是奇数 题目\n通过判断n % 2的结果是1还是0，无法判断n是奇数还是偶数\n因为n可能为负数\n常规写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; if(n % 2 == 1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else if(n % 2 == -1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;even\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 使用\u0026amp;：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; if((n \u0026amp; 1) == 1) cout \u0026lt;\u0026lt; \u0026#34;odd\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;even\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 4.2保留整数2进制中的指定位 场景：\n我们希望保留1个整数的2进制中某个位或者某几个位，其它位不需要就置为0。\n我们可以将一个值m的2进制位中需要取出的位 置为1，其它位为0\n然后 x\u0026amp;m 即可\n实际应用场景\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #define READ_PERMISSION 0x01 // 0001，表⽰读权限 #define WRITE_PERMISSION 0x02 // 0010，表⽰写权限 #define EXECUTE_PERMISSION 0x04 // 0100，表⽰执⾏权限 int main() { int permissions = 0x03; // ⼆进制: 0011，具有读和写权限 if (permissions \u0026amp; READ_PERMISSION) { printf(\u0026#34;阅读权限被设置\\n\u0026#34;); } else { printf(\u0026#34;阅读权限未被设置\\n\u0026#34;); } if (permissions \u0026amp; WRITE_PERMISSION) { printf(\u0026#34;写权限被设置\\n\u0026#34;); } else { printf(\u0026#34;写权限未被设置\\n\u0026#34;); } if (permissions \u0026amp; EXECUTE_PERMISSION) { printf(\u0026#34;执⾏权限被设置\\n\u0026#34;); } else { printf(\u0026#34;执⾏权限未被设置\\n\u0026#34;); } return 0; } 4.3获取二进制中的指定位 场景\n我们希望获得一个整数x二进制中的第i位（其实就是确定第i位是0还是1），\n就可以 (x \u003e\u003e i) \u0026amp; 1，结果是0，那么第i位就是0，结果是1，那么第i位就是1\nx \u0026raquo; i 使得x的第i位来到最低位，然后再按位与\u0026amp;1就能获得第i位是1还是0\n第i位是从右向左，最右边是第0位\n题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t ret = 0; uint32_t i = 0; for(i = 0; i \u0026lt; 32; i++) { //得到n的二进制位中的第i位 int b = (n \u0026gt;\u0026gt; i) \u0026amp; 1; //移动这个二进制位到合适的位置，然后 //存放在ret中 ret |= b \u0026lt;\u0026lt; (31-i); } return ret; } }; 应用场景\n例如：在嵌入式系统中，传感器通常通过寄存器返回数据。某些寄存器可能包\n含多个信息字段，例如状态标志、错误码等。这些字段往往位于寄存器的特定\n位中，需要通过获取指定位的值来读取。\n4.4将指定位设置为1 场景：有时候需要将一个整数x的二进制位中的，某几位设置为1，其余位置\n保留原值，那么可以让m的二进制对应位上是1，然后x |= m就可以将x的指\n定二进制位设置为1\n也可以将x的二进制位的第i位设置为1，只需要让m=1左移i位，然后让x|=m\n题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int findComplement(int num) { int ret = 0;//存放的是补码 //因为1 \u0026lt;= num \u0026lt; 2的31次方，所以num是正数 //当num向右移到num=0的时候，有效位就处理完了 int i = 0;//当前获取的位 while(num) { //num的第i位是1还是0 int b = num \u0026amp; 1; if(b == 0) { //将ret的第i位改为1 //因为ret本来=0 int tmp = 1; ret |= (tmp \u0026lt;\u0026lt; i); } num \u0026gt;\u0026gt;= 1; i++;//num的第i位 } return ret; } }; 4.5将指定位设置为0 例如：将x的二进制表示形式00001011中的第3位设置为0，其余位置保持不变\n那么我们需要有一个数m的二进制为11110111让它按位与上x，m如何得到呢\n我们可以1\u0026laquo;3然后取反，即x \u0026amp;= ~(1\u0026lt;\u0026lt;i);\n4.6反转指定二进制位 将一个整数x的二进制中第i位取反（0变1,1变0）\nx ^= (1\u0026lt;\u0026lt;i);\n比如：将x的二进制表示00101011的第2位反转，其余位保持原来的值不\n变，只需要将m = (1 \u003c\u003c 2) 和x异或\n4.7将2进制中最右边的1置为0 例如：将整数x的二进制位00101100中的最右边的1变成0，其余位不变\n就可以x \u0026amp;= (x-1)\n这个表达式常用于计算一个二进制序列中有几个1，因为该运算每次都\n会去掉一个1，一个整数的二进制中1的个数也就是该整数经过该运算后\n变为0之前运算了几次的个数\n题目\n方法1：\n1 2 3 4 5 6 7 8 9 int hammingWeight(int n) { int cnt = 0; while(n) { n \u0026amp;= (n-1); cnt++; } return cnt; } 方法2：\n1 2 3 4 5 6 7 8 9 10 11 int hammingWeight(int n) { int cnt = 0; //让n每次向右移1位，直到n为0（因为n是正数） while(n) { if(n \u0026amp; 1) cnt++; n \u0026gt;\u0026gt;= 1; } return cnt; } 法三：正数负数都可\n1 2 3 4 5 6 7 8 9 10 int hammingWeight(int n) { int cnt = 0; //让n每次向右移1位，直到n为0（因为n是正数） for(int i = 0; i \u0026lt; 32; i++) { if((n \u0026gt;\u0026gt; i) \u0026amp; 1) cnt++; } return cnt; } 题目\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: bool isPowerOfTwo(int n) { //1 - 01 //2 - 10 //4 - 100 //8 - 1000 //规律：2的幂次方的二进制表示中只有1个1 //所以2的幂满足：1.n\u0026gt;=1 2.n\u0026amp;(n-1)==0 return (n \u0026gt;= 1) \u0026amp;\u0026amp; ((n \u0026amp; (n-1)) == 0);//(n \u0026amp; (n-1)可以去掉1个1 } }; 4.8只保留2进制中最右边的1 4.9异或的巧用 5.操作符的优先级和结合性 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-bit-operator/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-bit-operator/","title":"【从零开始学C++】04位运算和操作符属性"},{"content":"1.结构体 结构体是一种自定义的类型，使用这种自定义类型可以描述一些复杂对象\n复杂对象比如：人、书等\n描述⼀本书，书有作者、出版社、定价等信息； 描述⼀个⼈，⼈有名字、性别、年龄、⾝⾼、体重等信息 1.1结构体类型声明和变量定义 声明结构体类型的关键字是struct\n语法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; struct Stu { string name; // 名字 int age; //年龄 int chinese; // 语文成绩 int math; // 数学成绩 int total; // 总成绩 }s4, s5, s6; // s4, s5, s6就是在结构体类型声明的同时，顺便创建的三个结构体变量 //s4, s5, s6是全局变量 struct Stu s7; // 全局变量 int main() { //局部的结构体变量 struct Stu s1; struct Stu s2; Stu s3; // C++中struct 可以省略 Stu arr[6]; // 结构体类型的数组 return 0; } 注意：\n在创建变量的时候，结构体类型中的struct可以省略\n在创建结构体变量的时候，==结构体变量的名字不能和结构体类型的名字相同==\nStu Stu; // 这种写法是错的\n声明的结构体类型是不占用内存空间，只有创建了结构体类型的变量后，才\n向内存申请空间\n变量创建的本质是：在内存申请空间\nint a = 10; // 是向内存申请了4个字节的空间，用来存放整数10\n结构体变量可以是全局变量，也可以是局部变量\n1.2 结构体变量的特点 1.2.1结构体的初始化 结构体的初始化和数组的初始化类似，使用{}\n只不过需要将初始化的内容按照顺序放在{}中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { string name; int chinese; int math; int total; } int main() { //int arr[5] = {1, 2, 3, 4, 5}; struct Stu s1 = {\u0026#34;zhangsan\u0026#34;, 85, 95, 180}; return 0; } 1.2.2结构体整体操作 结构体变量中成员可以是不同类型的。但是一个结构体变量可以看做一个整体，\n是可以进行赋值操作的\n1 2 3 struct Stu s1 = {\u0026#34;zhangsan\u0026#34;, 85, 95, 180}; Stu s2; s2 = s1;//整体赋值，这样s2的内容就会和s1一样 1.2.3结构体成员的访问 语法：结构体变量.成员名\n1 2 3 4 5 6 Stu s1; s1.name = \u0026#34;lisi\u0026#34;; s1.chinese = 100; cin \u0026gt;\u0026gt; s1.math; s1.total = s1.chinese + s1.math; cout \u0026lt;\u0026lt; s1.total \u0026lt;\u0026lt; endl;\t1.2.4结构体嵌套 结构体的成员的类型也可以是结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Score { int chinese; int math; int english; }; struct Stu { string name; Score sc; // 三门成绩 int total; // 总成绩 int avg; // 平均成绩 }; int main() { Stu s1 = {\u0026#34;zhangsan\u0026#34;, {80,90,60}, 0, 0}; s1.total = s1.sc.chinese + s1.sc.math + s1.sc.english; s1.avg = s1.total / 3; cout \u0026lt;\u0026lt; s1.total \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s1.avg \u0026lt;\u0026lt; endl; return 0; } 1.3 结构体成员函数 在C++中，结构体里不仅可以有成员变量，还可以有成员函数\n注意：\nC++的结构体会有一些默认的成员函数（比如：构造函数、析构函数等），是\n编译器默认生成的，自动调用，我们也可以自己显示定义这些函数\n除了默认成员函数，我们也可以自定义一些成员函数\n成员函数可以直接访问成员变量\n成员函数的调用也使用.操作符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; //成员函数 //初始化结构体的成员变量 void Init_stu() { name = \u0026#34;小明\u0026#34;; chinese = 100; math = 100; total = chinese + math; } //打印结构体信息 void print_stu() { cout \u0026lt;\u0026lt; \u0026#34;名字：\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;语文：\u0026#34; \u0026lt;\u0026lt; chinese \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数学：\u0026#34; \u0026lt;\u0026lt; math \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总成绩：\u0026#34; \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } }; int main() { Stu s1; s1.Init_stu(); s1.print_stu(); return 0; } 构造函数\n作用：初始化结构体变量\n构造函数是在结构体变量创建的时候，编译器自动被调用的\n函数名与结构体（类）名相同 没有返回值，也不写void 构造函数可以重载 如果没有显示定义构造函数，系统会自动生成默认的构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; //成员函数 Stu() { name = \u0026#34;翠花\u0026#34;; chinese = 99; math = 100; total = chinese + math; } //打印结构体信息 void print_stu() { cout \u0026lt;\u0026lt; \u0026#34;名字：\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;语文：\u0026#34; \u0026lt;\u0026lt; chinese \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数学：\u0026#34; \u0026lt;\u0026lt; math \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总成绩：\u0026#34; \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } }; int main() { Stu s1; s1.print_stu(); return 0; } 析构函数\n作用：完成结构体变量中资源清理工作\n在结构体变量销毁的时候，被自动调用\n析构函数名是在结构体（类）名前加上~ 无参数无返回值类型 一个类只能有一个析构函数。（析构函数不能重载） 如果没有显示定义析构函数，系统会自动生成默认的析构函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Stu { //成员变量 string name; int chinese; int math; int total; //成员函数 //构造函数 Stu() { cout \u0026lt;\u0026lt; \u0026#34;调用构造函数Stu()\u0026#34; \u0026lt;\u0026lt; endl; name = \u0026#34;翠花\u0026#34;; chinese = 99; math = 100; total = chinese + math; } ~Stu() { cout \u0026lt;\u0026lt; \u0026#34;调用析构函数~Stu()\u0026#34; \u0026lt;\u0026lt; endl; //资源释放的工作 chinese = 0; }\t}; 1.4 运算符的重载 在C++中打印数据，我们通常习惯使用cout来直接打印数据，但是如果\n我们希望打印类类型的对象，直接使用cout来打印会报错\n比如下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; } int main() { struct Stu s = {\u0026#34;张三\u0026#34;, 90, 80, 170}; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 如果我们确实希望打印类类型的对象，那么就需要对输出运算符进行运算符重载。运算符重载是为了让自定义类型能够使用运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct Stu { //成员变量 string name; int chinese; int math; int total; }; //运算符重载 //重载的是输出运算符\u0026lt;\u0026lt;，让\u0026lt;\u0026lt;支持struct Stu类型数据的打印 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const struct Stu\u0026amp; s) { cout \u0026lt;\u0026lt; \u0026#34;名字：\u0026#34; \u0026lt;\u0026lt; s.name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;语文：\u0026#34; \u0026lt;\u0026lt; s.chinese \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数学：\u0026#34; \u0026lt;\u0026lt; s.math \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总分：\u0026#34; \u0026lt;\u0026lt; s.total \u0026lt;\u0026lt; endl; return os; } int main() { struct Stu s = {\u0026#34;张三\u0026#34;, 90, 80, 170}; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 1.5 结构体排序-sort sort函数是C++的STL中的库函数，可以直接用来排序数据\n1.5.1 sort函数介绍 1.5.2排序内置类型数据 对数组进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int arr[] = {4,5,6,9,7,1,2,8,5,4,2}; //数组名就是数组首元素的地址 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素的个数 //arr + sz跳过sz个元素，就是第sz+1个元素的地址 sort(arr, arr + sz);//升序 for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; return 0; } 对字符串中的字符进行排序\n这里是对字符串中的字符顺序来进行排序，是按照字符的ASCII码值进行排序的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s = \u0026#34;defxxxabccba\u0026#34;; sort(s.begin(), s.end()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 1.5.3自定义排序 sort在默认情况下是按照升序排序，如果我们希望按照降序排序呢？\n如果是结构体类型数据进行排序呢?\n如果第一个参数应该排在第二个参数之前，则返回true，否则返回false\ncom表示可以自定义一个排序方法，有两种方法可以实现：\n创建比较函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //方法1：比较函数 bool compare(int x, int y) { return x \u0026gt; y;//降序 //return x \u0026lt; y;//升序 } int main() { int arr[] = {4,5,6,9,7,1,2,8,5,4,2}; //数组名就是数组首元素的地址 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素的个数 //arr + sz跳过sz个元素，就是第sz+1个元素的地址 sort(arr, arr + sz, compare);//降序 for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; return 0; } 结构体中重载（）运算符-仿函数\n仿函数也叫函数对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; //方法2：仿函数的方式 struct cmp { bool operator()(int x, int y) { return x \u0026gt; y;//降序 } }cmp; int main() { int arr[] = {4,5,6,9,7,1,2,8,5,4,2}; //数组名就是数组首元素的地址 int sz = sizeof(arr) / sizeof(arr[0]);//计算数组元素的个数 //arr + sz跳过sz个元素，就是第sz+1个元素的地址 sort(arr, arr + sz, cmp);//降序 for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t} cout \u0026lt;\u0026lt; endl; return 0; } 1.5.4排序结构体数据 两个结构体数据也是不能直接比较大小的，在使用sort函数排序的时候\n也是需要提供自定义的比较方法\n方法1：提供比较函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct S { string name; int age; }; //提供比较函数：按照名字升序排 bool cmp_s_by_name(struct S s1, struct S s2) { return s1.name \u0026lt; s2.name; } //提供比较函数：按照年龄降序排 bool cmp_s_by_age(struct S s1, struct S s2) { return s1.age \u0026gt; s2.age; } int main() { struct S arr[] = {{\u0026#34;zhangsan\u0026#34;, 20}, {\u0026#34;lisi\u0026#34;, 25}, {\u0026#34;wangwu\u0026#34;, 18}}; int sz = sizeof(arr) / sizeof(arr[0]); sort(arr, arr+sz, cmp_s_by_age); for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt;arr[i].name \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\t年龄：\u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; endl; } return 0; } 方法2：仿函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct S { string name; int age; }; //按照年龄升序 struct Cmp { bool operator()(struct S s1, struct S s2) { return s1.age \u0026lt; s2.age;\t}\t}cmp; int main() { struct S arr[] = {{\u0026#34;zhangsan\u0026#34;, 20}, {\u0026#34;lisi\u0026#34;, 25}, {\u0026#34;wangwu\u0026#34;, 18}}; int sz = sizeof(arr) / sizeof(arr[0]); sort(arr, arr+sz, cmp); for(int i = 0; i \u0026lt; sz; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt;arr[i].name \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\t年龄：\u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; endl; } return 0; } 2.类 C++中为了更好的实现面向对象，更喜欢使用class（类）来替换struct（结构体）\n2.1 类的定义 class是用来定义类类型的关键字\n1 2 3 4 5 6 class tag { public: 成员变量列表; 成员函数列表; };//注意后面要加分号 public 是类成员权限访问限定符，标志类中的成员可以公开访问及调用\n结构体中的成员变量和成员函数默认就是公开的\nclass中的成员变量和成员函数默认是私有的(private)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Stu { public: //成员变量 string name; int chinese; int math; int total; //成员函数 - 自定义 void init_stu() { name = \u0026#34;小明\u0026#34;; chinese = 90; math = 98; total = chinese + math; } //类也是有默认成员函数-构造函数、析构函数... }; 2.2 类的使用 2.2.1 创建对象 1 2 3 4 5 6 7 int main() { Stu s1; Stu s2; return 0; } 2.2.2 调用类对象成员 1 2 3 4 5 6 7 8 int main() { Stu s1; s1.init_stu(); s1.name = \u0026#34;明明\u0026#34;; return 0; } 2.3 访问权限控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Stu { private: //成员变量 string name; int chinese; int math; int total; public: //成员函数 - 自定义 void init_stu() { name = \u0026#34;小明\u0026#34;; chinese = 90; math = 98; total = chinese + math; } //类也是有默认成员函数-构造函数、析构函数... }; int main() { Stu s1; s1.init_stu();//ok s1.name = \u0026#34;明明\u0026#34;;//err return 0; } 2.4 结构体和类的区别 C++兼容C语言，所以C++中struct既可以当成结构体使用，还可以用来\n定义类。\nstruct和class的区别是 struct定义的类默认访问权限是public\nclass定义的类默认访问权限是private\n3.练习 题目 方法1：打擂台\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //方法1：打擂台 struct S { int score; string name; }; int main() { int N; cin \u0026gt;\u0026gt; N; //1.输入一个学生的信息，假设这个学生的成绩就是最大的 struct S max; // 假设max中存放的是成绩最高学生的信息 cin \u0026gt;\u0026gt; max.score \u0026gt;\u0026gt; max.name; N--; //2.依次输入N-1个学生的信息，依次和假设的最大数据进行比较 //\t如果比假设的这个学生大，就更新最大的信息 struct S s;//存放临时的信息 while(N--) { cin \u0026gt;\u0026gt; s.score \u0026gt;\u0026gt; s.name; if(s.score \u0026gt; max.score) max = s; } //3.找出最大值了，输出 cout \u0026lt;\u0026lt; max.name \u0026lt;\u0026lt; endl; return 0; } 方法2\n1.输入N个学生的信息，并存储 2.排序-sort-排序为降序 3.第一个数就是最大的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; //方法2： //1.输入N个学生的信息，并存储 //2.排序-sort-排序为降序 //3.第一个数就是最大的 const int N = 110; struct S { int score; string name; }arr[N]; //比较函数 bool cmp(struct S s1, struct S s2) { return s1.score \u0026gt; s2.score;//降序\t} int main() { int n; cin \u0026gt;\u0026gt; n; //输入信息并存储 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; arr[i].score \u0026gt;\u0026gt;arr[i].name;\t} //排序 - 降序 sort(arr, arr+n, cmp); cout \u0026lt;\u0026lt; arr[0].name \u0026lt;\u0026lt; endl; return 0; } 题目 注意排序函数sort的自定义排序\nbool compare(int x, int y) { return x \u0026gt; y;//降序 }\n可以这样理解：\nx是要排在前面的\nx\u0026gt;y，x大于y，x排前面，也就是大的排前面，即降序\nx\u0026lt;y，x小于y，x排前面，也就是小的排前面，即升序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 310; struct Stu { int stu_no;//学号 int chinese;//语文 int math;//数学 int english;//英语 int total;//总分\t}arr[N]; struct Cmp { //总分不同，总分高的在前 //总分相同，语文成绩不同，语文成绩高的在前 //总分相同，语文成绩相同，学号小的在前 bool operator()(const Stu\u0026amp; s1, const Stu\u0026amp; s2) { if(s1.total != s2.total) return s1.total \u0026gt; s2.total; else if(s1.chinese != s2.chinese) return s1.chinese \u0026gt; s2.chinese; else return s1.stu_no \u0026lt; s2.stu_no; } }cmp; int main() { //思路： //1.输入学生人数n并用结构体存储 //2.输入n名学生的三科成绩，并计算总分 //3.按照总分降序排序 //4.输出前五名的学号和总分 int n; cin \u0026gt;\u0026gt; n; //输入n名学生的三科成绩，并计算总分 for(int i = 1; i \u0026lt;= n; i++) { arr[i-1].stu_no = i;//存储学号 cin \u0026gt;\u0026gt; arr[i-1].chinese \u0026gt;\u0026gt; arr[i-1].math \u0026gt;\u0026gt; arr[i-1].english; //计算总成绩 arr[i-1].total = arr[i-1].chinese + arr[i-1].math + arr[i-1].english; } //排序 - 降序 sort(arr, arr+n, cmp); //输出 for(int i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; arr[i].stu_no \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; arr[i].total \u0026lt;\u0026lt; endl; } return 0; } 题目\n分析：\n描述学生的结构体\nstruct S\n{\n​\tstring name;\n​\tint y;//年\n​\tint m;//月\n​\tint d;//日\n​\tint id;//顺序\n}\n输入n\n输入n个学生的信息-数组存储\n循环n次，每次输入一个学生的信息，加上表示顺序的id\n自定义排序\na. 日期比较\n年龄从大到小 == 日期从小到大\nb.输入顺序比较，晚输入的，编号大，排到前面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 110; struct Stu { string name; int y; int m; int d; int id;//顺序，如果年月日都相同，那么id大的先输出 }arr[N]; struct Cmp { bool operator()(Stu s1, Stu s2) { if(s1.y != s2.y) { //年小就大 return s1.y \u0026lt; s2.y; } else if(s1.y == s2.y \u0026amp;\u0026amp; s1.m != s2.m) { //年相同，月小就大 return s1.m \u0026lt; s2.m; } else if(s1.y \u0026lt;mark\u0026gt; s2.y \u0026amp;\u0026amp; s1.m \u0026lt;/mark\u0026gt; s2.m \u0026amp;\u0026amp; s1.d != s2.d) { //年月相同，天小就大 return s1.d \u0026lt; s2.d; } else { //生日相同，输入靠后的同学先输出 return s1.id \u0026gt; s2.id; } } }cmp; int main() { //1.输入n //2.输入n名同学的姓名s、出生年y、月m、日d //3.按照年龄降序排序，如果有两个同学生日相同， //\t输入靠后的同学先输出 int n; cin \u0026gt;\u0026gt; n; //输入n名学生的姓名和生日 for(int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; arr[i].name \u0026gt;\u0026gt; arr[i].y \u0026gt;\u0026gt; arr[i].m \u0026gt;\u0026gt; arr[i].d; arr[i].id = i; } //按照年龄降序排序，如果有两个同学生日相同， //输入靠后的同学先输出 sort(arr, arr+n, cmp); //输出 for(int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; arr[i].name \u0026lt;\u0026lt; endl; } return 0; } ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-struct-and-class/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-struct-and-class/","title":"【从零开始学C++】05结构体和类"},{"content":"1.指针 1.1内存和地址 计算机上CPU（中央处理器）在处理数据的时候，需要的数据是在内存中读取\n的，处理后的数据也会放回到内存中，为了高效管理内存空间，我们需要把内\n存划分成一个一个的内存单元单元，每个内存单元的大小为1个字节\n一个比特位可以存储一个2进制的位1或者0\n1.2指针变量 取地址操作符\u0026amp;\n变量创建的本质就是向内存申请空间\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; //创建a变量的时候，其实是向内存申请4个字节的空间，存放10这个数值 return 0; } 申请到的每个字节都有地址\n\u0026amp;a取出的是a所占4个字节中地址较小的字节的地址\n指针变量\n我们通过取地址操作符\u0026amp;，拿到的地址是一个数值，比如：0x0117FADB，这个\n数值有时候也是需要存储起来，方便后期再使用。\n我们把这样的地址值存放在指针变量中\n1 2 3 4 5 6 7 8 int main() { int a = 10; int* pa = \u0026amp;a;//pa就是一个存放地址的变量 -- 指针变量 //编号 \u0026lt;mark\u0026gt; 地址 \u0026lt;/mark\u0026gt; 指针 return 0; } 如果创建一个指针变量的时候，还不知道存储谁的地址，这时我们可以给这个指\n针变量赋值为NULL，NULL在C++中的值是0，表示空指针，意思是没有指向任何\n有效的变量\n当然0也是作为地址编号的，这个地址是无法使用的，读写该地址会报错\n1 2 char ch = \u0026#39;w\u0026#39;; char* pc = \u0026amp;ch; 解引用操作符\n我们通过取地址操作符\u0026amp;取出了变量的地址，并用指针变量存储了变量的地址\n那么得到变量的地址后，我们如何通过指针变量来修改变量呢？\n需要使用解引用操作符\n1 2 3 4 5 6 7 8 9 int main() { int a = 10; int* pa = \u0026amp;a; *pa = 100;//* -- 解引用操作符 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;//100 return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 int main() { //int* p = NULL; //*p = 100;//err //正确写法 int* p = NULL; if (p != NULL) *p = 100; return 0; } 1.3指针类型 指针类型的意义：1.指针的解引用 2.指针+-整数\n1.3.1指针的解引用 指针的类型决定了，对指针解引用的时候有多大的权限（⼀次能操作几个字节）\n比如： char* 的指针解引用就只能访问⼀个字节，而 int* 的指针的解引用就能访问四个字节\n1.3.2指针+-整数 结论：指针的类型决定了指针向前或者向后走⼀步有多大（距离）。\n字符的地址使用cout打印会以为是字符串，所以这里使用printf打印\n1.3.3void*指针 void类型的指针是一种无具体类型的指针，或者叫泛型指针。\n这种类型的指针可以用来接受任意类型地址，但是void*类型的指针不能直接进行\n指针+-整数和解引用运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int n = 0; char ch = \u0026#39;w\u0026#39;; int* p1 = \u0026amp;n; char* pc = \u0026amp;ch; void* p2 = \u0026amp;n; void* p3 = \u0026amp;ch; return 0; } void*类型的指针一般是使用在函数参数部分，用于接受不同类型数据的地址\n这样设计可以实现泛型编程的效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void test(void* p) { //... } int main() { int a = 10; test(\u0026amp;a); double d = 3.14; test(\u0026amp;d); return 0; } 1.4指针访问数组 练习：有一个整型数组，10个元素，默认初始化为0，现在要求让数组的内容设置\n为1~10，然后打印数组的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { int arr[10] = { 0 }; int* parr = arr; //赋值1~10 for (int i = 0; i \u0026lt; 10; i++) { *(parr + i) = i + 1; } //打印 for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; *parr \u0026lt;\u0026lt; \u0026#34; \u0026#34;; parr++; } cout \u0026lt;\u0026lt; endl; return 0; } 2.动态内存管理 我们知道变量的创建会为变量申请一块内存空间，数组的创建其实也向内存申请一块连续的空间\n这两种方式，如果创建的是全局的变量和数组，是在内存的静态区\n（数据段）申请的，如果是局部变量和数组，是在内存的栈区申请的\n不管是全局变量还是局部变量，申请和回收都是系统自动完成的，\n不需要程序员自己处理\n2.1new和delete 在C++中，使用new和delete操作符来进行动态内存管理\nnew负责申请内存 new操作符返回的是申请到的内存空间的起始地址，需要指针存放 new申请一个变量的空间，new[]申请一个数组的空间 delete负责释放（回收）内存 delete负责释放一个变量的空间，delete[]释放一个数组的空间 new和delete配对使用，new[]和delete[]配对使用 申请变量空间\n1 2 3 4 5 6 7 8 9 10 11 //申请内存 //申请一块整型空间 int* ptr1 = new int; //申请一块整型空间的时候，给它初始化一个值10 int* ptr2 = new int(10); //释放 delete ptr1; ptr1 = NULL; delete ptr2; ptr2 = NULL; 申请数组空间\n1 2 3 4 int* ptr3 = new int[10]; //... //释放 delete[] ptr3; 提示\nnew 不是只能给内置类型开辟空间，也可以给自定义类型开辟空间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main() { int* ptr3 = new int[10]; //使用ptr3给数组赋值：1~10 int i = 0; for (i = 0; i \u0026lt; 10; i++) { *(ptr3 + i) = i + 1; } //打印 for (i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; *(ptr3 + i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //释放 delete[] ptr3; ptr3 = NULL; return 0; } *(ptr3 + i)也可以写成ptr3[i]\n注意：使用new和delete申请的空间需要程序员自己手动释放\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-pointer-and-dynamic-memory-management/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-pointer-and-dynamic-memory-management/","title":"【从零开始学C++】06指针和动态内存管理"},{"content":"1.数据结构介绍 1.1什么是数据结构？ 数据结构是计算机的内存中存储和组织数据的方式\n数据结构关注如何以最有效的方式组织和存储数据，以便在计算机程序\n程序中进行操作和处理\n1.2为什么需要数据结构？ 在日常生活中，餐厅里如果客人很多，他们就会将客人的订单\n排列好，比如先上1号桌的菜、再上2号桌\u0026hellip;，这样就不会出现客户\n就餐体验差、等餐时间长、餐厅营业混乱等情况\n同理，程序如果不对数据进行管理，可能会导致数据丢失、操作数据困\n难、野指针等情况。\n通过数据结构，能够有效将数据组织和管理在一起。\n按照我们的方式任意对数据进行增、删、改、查等操作。\n1.3常见数据结构分类 一般按照组织形式，分为：线性数据结构和非线性数据结构\n2.链表 2.1概念 链表是一种线性的数据结构，由一系列的结点组成。\n每个结点包含两个部分：数据和指向下一个节点的指针\n链表中的元素在内存中不一定是顺序排列的，而是通过指针相互\n连接\n2.2链表的结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; //声明一个节点的类型 struct Node { int data; Node* next; }; int main() { struct Node n1 = {1, NULL}; struct Node n2 = { 2, NULL }; struct Node n3 = { 3, NULL }; struct Node n4 = { 4, NULL }; n1.next = \u0026amp;n2; n2.next = \u0026amp;n3; n3.next = \u0026amp;n4; return 0; } 2.3链表的分类 单向：每个节点只有一个指针指向下一个节点 双向：每个节点有两个指针，分别指向前一个节点和后一个节点 循环：尾结点指向头结点 不循环 2.4单链表的实现 动态申请链表结点和链表构建 我们前面实现的链表的节点都是局部变量，局部变量是存放在栈区的，\n生命周期比较短，出作用域就系统自动回收所在空间。\n但是我们希望创建一个链表，存好数据后，在我不希望这个节点回收的时候，\n它就不能回收，它得保持一直存在。（出了作用域也得存在）\n所以，我们可以使用之前学过的动态内存管理的知识，使用new和delete\nnew是在堆区申请空间，申请后会返回对应空间的地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //声明一个节点的类型 struct Node { int data; Node* next; }; Node* CreateNode(int d) { Node* pn = new Node; pn-\u0026gt;data = d; pn-\u0026gt;next = NULL; return pn; } int main() { Node* p1 = CreateNode(1); Node* p2 = CreateNode(2); Node* p3 = CreateNode(3); Node* p4 = CreateNode(4); p1-\u0026gt;next = p2; p2-\u0026gt;next = p3; p3-\u0026gt;next = p4; return 0; } 我们把创建一个新结点封装成一个函数，这样每次创建节点就不需要写三行\n代码了\n单链表的打印 1 2 3 4 5 6 7 8 9 10 void PrintList(Node* pn) { Node* cur = pn; while (cur) { cout \u0026lt;\u0026lt; cur-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } 单链表头插元素 首先，我们需要一个指针，指向链表的第一个节点。由于最开始链表\n是空的，所以Node* phead = NULL;又由于头插元素会改变指针phead\n的指向，所以我们传phead的引用\n两种情况\n情况1，链表里没有节点\n创建新节点后，让新节点成为头节点\n情况2，链表里有节点\n创建新节点\n让新节点指向头结点\n让新结点成为新的头节点\n法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void PushFront(Node* \u0026amp;phead, int d) { if (phead == NULL)//空链表 { phead = CreateNode(d); } else { Node* newNode = CreateNode(d); newNode-\u0026gt;next = phead; phead = newNode; } } 法二\n1 2 3 4 5 6 7 void PushFront(Node*\u0026amp; phead, int d) { Node* newNode = CreateNode(d); newNode-\u0026gt;next = phead; phead = newNode; } 单链表尾插元素 实现单链表尾插元素，需要先找尾节点\n然后让链表的尾结点的next指针指向新结点\n**注意：**需要先判断是不是空链表，因为如果是空链表，就不能对phead指针解引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void PushBack(Node*\u0026amp; phead, int d) { //1.创建新节点 Node* newnode = CreateNode(d); if (phead == NULL)//空链表 { phead = newnode; } else//非空链表 { //2.找尾结点 Node* ptail = phead; while (ptail-\u0026gt;next) { ptail = ptail-\u0026gt;next; } //3.让尾结点的next指针指向新节点 ptail-\u0026gt;next = newnode; } } 单链表头删元素 两种情况，链表为空和链表不为空\n链表为空，不删除元素\n链表不为空\n保存头节点的下一个节点的指针next 然后删除头结点 再让指向头节点的指针指向next 1 2 3 4 5 6 7 8 9 10 11 12 13 void PopFront(Node*\u0026amp; phead) { if (phead) { Node* next = phead-\u0026gt;next; delete phead; phead = next; } else { cout \u0026lt;\u0026lt; \u0026#34;链表为空，无法删除\u0026#34; \u0026lt;\u0026lt; endl; } } 单链表尾删元素 两种情况\n链表为空不可删除\n链表不为空\n需要找尾节点和尾结点的前一个结点 销毁尾节点，并让尾节点的前一个节点的next指针指向空 注意链表只有一个节点的情况，前一个节点是NULL，不能解引用\n而且因为可能尾删的时候链表只有一个节点，所以需要使用引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void PopBack(Node*\u0026amp; phead) { if (phead == NULL)//链表为空 { cout \u0026lt;\u0026lt; \u0026#34;链表为空，不可删除\u0026#34; \u0026lt;\u0026lt; endl; } else//链表不为空 { if (phead-\u0026gt;next == NULL)//链表只有一个节点 { delete phead; phead = NULL; } else { Node* prev = NULL; Node* tail = phead; while (tail-\u0026gt;next) { prev = tail; tail = tail-\u0026gt;next; } //释放tail节点 delete tail; tail = NULL; //前一个节点prev的next置为空 prev-\u0026gt;next = NULL; } } } 单链表删除所有元素 链表为空，不可销毁\n链表不为空\n定义一个指针pcur指向头结点，和next指向pcur的下一个节点\n让pcur遍历链表并释放pcur所指向的节点，然后pcur = next，next = next-\u0026gt;next\n循环直到pcur等于空\n因为要删除所有节点，也就是头结点也要置为空\n所以传引用\n法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void DestroyList(Node*\u0026amp; phead) { if (phead == NULL) { cout \u0026lt;\u0026lt; \u0026#34;链表为空，不可销毁\u0026#34; \u0026lt;\u0026lt; endl; } else { Node* next = phead-\u0026gt;next; while (phead) { delete phead; phead = next; if(next) next = next-\u0026gt;next; } next = phead = NULL; } } 法2：\n1 2 3 4 5 6 7 void DestroyList(Node*\u0026amp; phead) { while (phead) { PopFront(phead); } } 2.5面向对象的方式实现链表 在C++中，struct里面不仅可以有成员变量，还可以有成员函数\n在同一个struct中，成员函数默认可以直接访问成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include \u0026lt;iostream\u0026gt; using namespace std; //声明一个节点的类型 struct Node { int data; Node* next; }; //链表 class List { private: //成员变量 Node* phead; // 指向第一个节点的指针 public: //成员函数 //构造函数 List() { cout \u0026lt;\u0026lt; \u0026#34;调用构造函数\u0026#34; \u0026lt;\u0026lt; endl; phead = NULL; } //析构函数 - 释放链表 ~List() { cout \u0026lt;\u0026lt; \u0026#34;调用析构函数\u0026#34; \u0026lt;\u0026lt; endl; while (phead) { PopFront(); } } //创建节点 Node* CreateNode(int d) { Node* pn = new Node; pn-\u0026gt;data = d; pn-\u0026gt;next = NULL; return pn; } //链表元素的打印 void PrintList() { Node* cur = phead; while (cur) { cout \u0026lt;\u0026lt; cur-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cur = cur-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; } //头插 void PushFront(int d) { Node* newNode = CreateNode(d); newNode-\u0026gt;next = phead; phead = newNode; } //尾插 void PushBack(int d) { //1.创建新节点 Node* newnode = CreateNode(d); if (phead == NULL)//空链表 { phead = newnode; } else//非空链表 { //2.找尾结点 Node* ptail = phead; while (ptail-\u0026gt;next) { ptail = ptail-\u0026gt;next; } //3.让尾结点的next指针指向新节点 ptail-\u0026gt;next = newnode; } } //头删 void PopFront() { if (phead) { Node* next = phead-\u0026gt;next; delete phead; phead = next; } else { cout \u0026lt;\u0026lt; \u0026#34;链表为空，无法删除\u0026#34; \u0026lt;\u0026lt; endl; } } //尾删 void PopBack() { if (phead == NULL)//链表为空 { cout \u0026lt;\u0026lt; \u0026#34;链表为空，不可删除\u0026#34; \u0026lt;\u0026lt; endl; } else//链表不为空 { if (phead-\u0026gt;next == NULL)//链表只有一个节点 { delete phead; phead = NULL; } else { Node* prev = NULL; Node* tail = phead; while (tail-\u0026gt;next) { prev = tail; tail = tail-\u0026gt;next; } //释放tail节点 delete tail; tail = NULL; //前一个节点prev的next置为空 prev-\u0026gt;next = NULL; } } } }; int main() { List list1;//创建了一个空链表 list1.PushBack(1); list1.PushBack(2); list1.PushBack(3); list1.PushBack(4); list1.PrintList();//1 2 3 4 return 0; } ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-implement-the-linked-list/bz03_hu_16fe6a862ea432d9.jpg","permalink":"https://Amarantos-Arrebol.github.io/p/learning-c-from-scratch-implement-the-linked-list/","title":"【从零开始学C++】07使用指针实现链表"},{"content":"【数据结构初阶】OJ题 1、栈和队列 1.1有效括号 题目链接\n题目描述： 输出true的典型情况\n示例1：\n输入：s = \u0026ldquo;()\u0026rdquo;\n输出：true\n示例2：\n输入：s = \u0026ldquo;(){}[]\u0026rdquo;\n输出：true\n示例3：\n输入：s = \u0026ldquo;({[]})\u0026rdquo;\n输出：true\n示例4：\n输入：s = \u0026ldquo;()[{}]\u0026rdquo;\n输出：true\n输出false的典型情况\n示例1：\n输入：s = \u0026ldquo;[\u0026rdquo;\n输出：false\n示例2:\n输入：s = \u0026ldquo;]\u0026rdquo;\n输出：false\n示例3：\n输入：s = \u0026ldquo;(]\u0026rdquo;\n输出：false\n示例4：\n输入：s = \u0026ldquo;()[]{}(\u0026rdquo;\n输出：false\n示例5：\n输入：s = \u0026ldquo;()[]{})\u0026rdquo;\n输出：false\n思路 我们使用栈来实现。\n遍历字符串，while(*ps != '\\0'){ }\n若ps遍历到的字符是左括号的时候，入栈。 若ps遍历到的字符是右括号 如果栈为空，直接返回false 和栈顶元素相匹配的时候，出栈，s++。 和栈顶元素不相匹配的时候，返回false 遍历完字符串后，如果最后栈为空，则返回true，否则返回false 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 typedef char STDataType; typedef struct Stack { STDataType* arr; int capacity; int top; }ST; //栈的初始化 void STInit(ST* ps) { assert(ps); ps-\u0026gt;arr = NULL; ps-\u0026gt;capacity = ps-\u0026gt;top = 0; } //栈的销毁 void STDestroy(ST* ps) { assert(ps);//保证栈是存在的 if(ps-\u0026gt;arr)//判断栈是否为空 free(ps-\u0026gt;arr); ps-\u0026gt;capacity = ps-\u0026gt;top = 0; } //入栈 void STPush(ST* ps, STDataType x) { assert(ps); //如果满了就增容 if(ps-\u0026gt;top == ps-\u0026gt;capacity) { int newCapacity = ps-\u0026gt;capacity == 0 ? 4 : 2 * ps-\u0026gt;capacity; STDataType* tmp = (STDataType*)realloc(ps-\u0026gt;arr, newCapacity * sizeof(STDataType)); if(tmp == NULL) { perror(\u0026#34;realloc fail!\u0026#34;); exit(1); } ps-\u0026gt;arr = tmp; ps-\u0026gt;capacity = newCapacity; } //空间足够 ps-\u0026gt;arr[ps-\u0026gt;top++] = x; } //判断栈是否为空 bool STEmpty(ST* ps) { assert(ps); return ps-\u0026gt;top == 0;//为空，返回true } //出栈 void STPop(ST* ps) { assert(ps); assert(!STEmpty(ps)); --ps-\u0026gt;top; } //取栈顶元素 STDataType STTop(ST* ps) { assert(ps); assert(!STEmpty(ps)); return ps-\u0026gt;arr[ps-\u0026gt;top - 1]; } bool isValid(char* s) { ST st; STInit(\u0026amp;st); //遍历字符串 char* ps = s; while(*ps != \u0026#39;\\0\u0026#39;) { //左括号，入栈 if(*ps \u0026lt;mark\u0026gt; \u0026#39;(\u0026#39; || *ps \u0026lt;/mark\u0026gt; \u0026#39;[\u0026#39; || *ps == \u0026#39;{\u0026#39;) { STPush(\u0026amp;st, *ps); } else//右括号，和栈顶元素比较是否匹配 { //栈为空，直接返回false if(STEmpty(\u0026amp;st)) { return false; } char ch = STTop(\u0026amp;st); if((*ps \u0026lt;mark\u0026gt; \u0026#39;)\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;/mark\u0026gt; \u0026#39;(\u0026#39;) || (*ps \u0026lt;mark\u0026gt; \u0026#39;]\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;/mark\u0026gt; \u0026#39;[\u0026#39;) || (*ps \u0026lt;mark\u0026gt; \u0026#39;}\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;/mark\u0026gt; \u0026#39;{\u0026#39;)) { //匹配，出栈 STPop(\u0026amp;st); }else { //销毁栈 STDestroy(\u0026amp;st); //不匹配 return false; } } ps++;//访问往后一个字符 } //先判断栈是否为空 bool ret = STEmpty(\u0026amp;st); //销毁栈 STDestroy(\u0026amp;st); return ret; } 1.2 用队列实现栈 题目链接\n题目 思路 队列特点：先进先出\n栈的特点：后进先出\n用两个队列实现 栈的普通操作\n出栈：找不为空的队列，将size-1个数据导入到另一个队列中 入栈：往不为空的队列中插入数据 取栈顶元素 代码 队列的基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 typedef int QDataType; // 队列结点结构 typedef struct QueueNode { QDataType data; struct QueueNode* next; } QueueNode; // 队列结构 typedef struct Queue { QueueNode* phead; QueueNode* ptail; int size; } Queue; // 初始化 void QueueInit(Queue* pq) { assert(pq); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } // 入队列，队尾 void QueuePush(Queue* pq, QDataType x) { assert(pq); // 申请一个新结点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror(\u0026#34;malloc fail!\u0026#34;); exit(1); } newnode-\u0026gt;data = x; newnode-\u0026gt;next = NULL; // 初始情况下，队列为空，phead和ptail都指向空 if (pq-\u0026gt;phead == NULL) { pq-\u0026gt;phead = newnode; pq-\u0026gt;ptail = newnode; } else { // 在队尾入队列 pq-\u0026gt;ptail-\u0026gt;next = newnode; pq-\u0026gt;ptail = newnode; } pq-\u0026gt;size++; } bool QueueEmpty(Queue* pq) { assert(pq); return pq-\u0026gt;phead \u0026lt;mark\u0026gt; NULL \u0026amp;\u0026amp; pq-\u0026gt;ptail \u0026lt;/mark\u0026gt; NULL; } // 出队列，队头 void QueuePop(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); // 只有一个结点的情况，避免ptail成野指针 if (pq-\u0026gt;phead == pq-\u0026gt;ptail) { free(pq-\u0026gt;phead); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; } else { // 删除头结点 QueueNode* next = pq-\u0026gt;phead-\u0026gt;next; free(pq-\u0026gt;phead); pq-\u0026gt;phead = next; } pq-\u0026gt;size--; } // 取队头数据 QDataType QueueFront(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;phead-\u0026gt;data; } // 取队尾数据 QDataType QueueBack(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;ptail-\u0026gt;data; } // 取有效元素个数 int QueueSize(Queue* pq) { assert(pq); return pq-\u0026gt;size; } // 队列的销毁 void QueueDestroy(Queue* pq) { assert(pq); // 循环遍历销毁结点 QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { QueueNode* next = pcur-\u0026gt;next; free(pcur); pcur = next; } pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } 用两个队列实现栈的基本结构 MyStack由两个队列构成，对MyStack的初始化就是对里面的两个队列进行初始化\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { Queue q1; Queue q2; } MyStack; MyStack* myStackCreate() { MyStack* pst = (MyStack*)malloc(sizeof(MyStack)); QueueInit(\u0026amp;pst-\u0026gt;q1); QueueInit(\u0026amp;pst-\u0026gt;q2); return pst; } 用两个队列实现入栈 往不为空的队列中插入数据\n1 2 3 4 5 6 7 void myStackPush(MyStack* obj, int x) { if (!QueueEmpty(\u0026amp;obj-\u0026gt;q1)) { QueuePush(\u0026amp;obj-\u0026gt;q1, x); } else { QueuePush(\u0026amp;obj-\u0026gt;q2, x); } } 用两个队列实现出栈 找不为空的队列 假定其中一个队列是空队列 判断假定是否正确 将不为空的队列的前size-1个结点导入到空队列中 最后，出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int myStackPop(MyStack* obj) { // 1.找不为空的队列 // 1）假定队列q1是空队列 Queue* empQ = \u0026amp;obj-\u0026gt;q1; Queue* noneQ = \u0026amp;obj-\u0026gt;q2; // 2）判断假定是否正确 if (!QueueEmpty(\u0026amp;obj-\u0026gt;q1)) { empQ = \u0026amp;obj-\u0026gt;q2; noneQ = \u0026amp;obj-\u0026gt;q1; } // 2.将不为空的队列的前size-1个结点导入到空队列中 while (QueueSize(noneQ) \u0026gt; 1) { int front = QueueFront(noneQ); QueuePush(empQ, front); QueuePop(noneQ); } // 非空队列中只剩下一个数据--要出栈的数据 int ret = QueueFront(noneQ); QueuePop(noneQ); return ret; } 用两个队列实现取栈顶元素 取非空队列的队尾元素\n1 2 3 4 5 6 7 8 9 10 int myStackTop(MyStack* obj) { if(!QueueEmpty(\u0026amp;obj-\u0026gt;q1)) { return QueueBack(\u0026amp;obj-\u0026gt;q1); } else { return QueueBack(\u0026amp;obj-\u0026gt;q2); } } 判空两个队列是否为空 1 2 3 4 bool myStackEmpty(MyStack* obj) { assert(obj); return QueueEmpty(\u0026amp;obj-\u0026gt;q1) \u0026amp;\u0026amp; QueueEmpty(\u0026amp;obj-\u0026gt;q2); } 用两个队列实现销毁 1 2 3 4 5 6 void myStackFree(MyStack* obj) { QueueDestroy(\u0026amp;obj-\u0026gt;q1); QueueDestroy(\u0026amp;obj-\u0026gt;q2); free(obj); obj = NULL; } 1.3 用栈来实现队列 题目 思路 代码 两个栈实现一个队列的结构\n入队列\n出队列\n取队头元素\n判断队列是否为空\n队列的销毁\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/data-structure-basic-oj/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI-AI%E7%BE%8E%E5%A5%B3_hu_a0558270c685596d.png","permalink":"https://Amarantos-Arrebol.github.io/p/data-structure-basic-oj/","title":"【数据结构初阶】OJ题"},{"content":"数据结构初阶 1、单链表 2、双向链表 3、栈 4、队列 4.1基本介绍 概念：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表 特点：先进先出 入队列：进行插入操作的一端称为队尾\n出队列：进行删除操作的一端称为队头\n4.2 实现队列的方式 底层使用数组\n入队列，如果在数组末尾插入数据，那么时间复杂度为O(1)\n出队列，如果在数组开头删除数据，那么后面的数据要整体向前挪动一位，时间复杂度为O(N)\n底层使用单链表\n入队列，如果在链表尾部插入数据，那么需要遍历链表找到尾结点，时间复杂度为O(N)\n出队列，如果在链表头部删除数据，时间复杂度为O(1)\n优化：定义一个指向尾结点的指针ptail，此时，我们再插入数据时，就直接让ptail指向\n的结点指向新结点，然后让新结点成为ptail ，时间复杂度为O(1)\n4.3 实现队列 队列的底层是一个链表，而链表是由一个个结点组成\n4.3.1 队列的定义 在队列这个数据结构中，我们有两个指针\n一个指向链表的头结点phead， 一个指向链表的尾结点ptail 当我们要插入数据时，往队尾插；当我们要删除数据时，往队头删\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef int QDataType; //定义队列结点的结构 typedef struct QueueNode { QDataType data; struct QueueNode* next; }QueueNode; //定义队列的结构 typedef struct Queue { QueueNode* phead; QueueNode* ptail; int size;//记录队列有效元素个数 }Queue; 4.3.2队列的功能实现 队列的初始化 1 2 3 4 5 6 void QueueInit(Queue* pq) { assert(pq); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } 入队列，队尾 入队列要往队尾入，所以要向操作系统申请一个结点大小的空间\n如果队列为空，新插入进来的结点既是头结点，也是尾结点\n如果队列不为空，直接让ptail指向的结点的next指针指向新结点，然后让ptail指向新结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void QueuePush(Queue* pq, QDataType x) { assert(pq); //申请新结点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror(\u0026#34;malloc fail!\u0026#34;); exit(1); } newnode-\u0026gt;data = x; newnode-\u0026gt;next = NULL; //队列为空 if (pq-\u0026gt;phead == NULL) { pq-\u0026gt;phead = pq-\u0026gt;ptail = newnode; } else//队列不为空 { pq-\u0026gt;ptail-\u0026gt;next = newnode; pq-\u0026gt;ptail = newnode; } ++pq-\u0026gt;size; } 出队列，队头 队列为空：不可以出队列\n队列不为空，可以出队列\n队列只有一个结点(phead == ptail)，释放头结点后，让phead和ptail都置为空\n队列有两个结点，出队列有两种方式\n1）先用指针next指向phead-\u0026gt;next，然后释放phead，最后phead = next\n2）先用指针del指向phead指向的结点，然后phead = phead-\u0026gt;next，最后释放del\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //队列判空 bool QueueEmpty(Queue* pq) { assert(pq); return pq-\u0026gt;phead \u0026lt;mark\u0026gt; NULL \u0026amp;\u0026amp; pq-\u0026gt;ptail \u0026lt;/mark\u0026gt; NULL; } //出队列，队头 void QueuePop(Queue* pq) { assert(pq); //队列为空，不能出队列 assert(!QueueEmpty(pq)); //只有一个结点的情况，避免ptail成野指针 if (pq-\u0026gt;phead == pq-\u0026gt;ptail) { free(pq-\u0026gt;phead); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; } else { //删除头结点 QueueNode* next = pq-\u0026gt;phead-\u0026gt;next; free(pq-\u0026gt;phead); pq-\u0026gt;phead = next; } --pq-\u0026gt;size; } 取队头数据，取队尾数据 队列为空，不能取队头或队尾数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //取队头数据 QDataType QueueFront(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;phead-\u0026gt;data; } //取队尾数据 QDataType QueueBack(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;ptail-\u0026gt;data; } 取队列有效元素个数 方法一：遍历队列，时间复杂度为O(N)\n对于可能会频繁调用取队列有效元素个数的情况，使用遍历队列中的结点，效率低\n方法二：在队列中定义一个size用来记录队列中有效元素个数\n出栈的时候，size\u0026ndash; 入栈的时候，size++\n1 2 3 4 5 6 7 8 9 10 11 12 13 int QueueSize(Queue* pq) { assert(pq); /*int size = 0; QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { size++; pcur = pcur-\u0026gt;next; } return size;*/ return pq-\u0026gt;size; } 队列的销毁 要将队列中所有结点销毁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void QueueDestroy(Queue* pq) { assert(pq); //队列为空，不可销毁 assert(!QueueEmpty(pq)); QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { QueueNode* next = pcur-\u0026gt;next; free(pcur); pcur = next; } pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = NULL; } Queue.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #pragma once #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;assert.h\u0026gt; #include\u0026lt;stdbool.h\u0026gt; typedef int QDataType; //定义队列结构 typedef struct QueueNode { QDataType data; struct QueueNode* next; }QueueNode; typedef struct Queue { QueueNode* phead; QueueNode* ptail; int size;//保存队列有效数据个数 }Queue; void QueueInit(Queue* pq); //入队列，队尾 void QueuePush(Queue* pq, QDataType x); //出队列，队头 void QueuePop(Queue* pq); //队列判空 bool QueueEmpty(Queue* pq); //取队头数据 QDataType QueueFront(Queue* pq); //取队尾数据 QDataType QueueBack(Queue* pq); //取队列有效元素个数 int QueueSize(Queue* pq); //队列的销毁 void QueueDestroy(Queue* pq); Queue.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #include\u0026#34;Queue.h\u0026#34; void QueueInit(Queue* pq) { assert(pq); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } //入队列，队尾 void QueuePush(Queue* pq, QDataType x) { assert(pq); //申请新结点 QueueNode* newnode = (QueueNode*)malloc(sizeof(QueueNode)); if (newnode == NULL) { perror(\u0026#34;malloc fail!\u0026#34;); exit(1); } newnode-\u0026gt;data = x; newnode-\u0026gt;next = NULL; //如果队列为空，新插入进来的结点既是头结点，也是尾结点 if (pq-\u0026gt;phead == NULL) { pq-\u0026gt;phead = pq-\u0026gt;ptail = newnode; } else//队列不为空 { pq-\u0026gt;ptail-\u0026gt;next = newnode; pq-\u0026gt;ptail = newnode; } ++pq-\u0026gt;size; } //队列判空 bool QueueEmpty(Queue* pq) { assert(pq); return pq-\u0026gt;phead \u0026lt;mark\u0026gt; NULL \u0026amp;\u0026amp; pq-\u0026gt;ptail \u0026lt;/mark\u0026gt; NULL; } //出队列，队头 void QueuePop(Queue* pq) { assert(pq); //队列为空，不能出队列 assert(!QueueEmpty(pq)); //只有一个结点的情况，避免ptail成野指针 if (pq-\u0026gt;phead == pq-\u0026gt;ptail) { free(pq-\u0026gt;phead); pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; } else { //删除头结点 QueueNode* next = pq-\u0026gt;phead-\u0026gt;next; free(pq-\u0026gt;phead); pq-\u0026gt;phead = next; } --pq-\u0026gt;size; } //取队头数据 QDataType QueueFront(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;phead-\u0026gt;data; } //取队尾数据 QDataType QueueBack(Queue* pq) { assert(pq); assert(!QueueEmpty(pq)); return pq-\u0026gt;ptail-\u0026gt;data; } //取队列有效元素个数 int QueueSize(Queue* pq) { assert(pq); /*int size = 0; QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { size++; pcur = pcur-\u0026gt;next; } return size;*/ return pq-\u0026gt;size; } void QueueDestroy(Queue* pq) { assert(pq); //队列为空，不可销毁 assert(!QueueEmpty(pq)); QueueNode* pcur = pq-\u0026gt;phead; while (pcur) { QueueNode* next = pcur-\u0026gt;next; free(pcur); pcur = next; } pq-\u0026gt;phead = pq-\u0026gt;ptail = NULL; pq-\u0026gt;size = 0; } 5、二叉树 5.1 二叉树 5.2 堆 5.3 二叉树链式结构 6、排序 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/data-structure-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI-AI%E7%BE%8E%E5%A5%B3_hu_a0558270c685596d.png","permalink":"https://Amarantos-Arrebol.github.io/p/data-structure-basic/","title":"【数据结构初阶】数据结构入门"},{"content":"🥳1. 创建项目全流程 🍋‍1.1 创建自己的工程 打开对应版本的虚幻引擎\n注意：高版本的可以打开低版本的项目，但低版本无法打开低版本的项目\n在虚幻项目浏览器中选择是打开已有项目还是新建项目\n只能打开对应版本的项目\n比如：如果启动的是4.22版本的虚幻引擎，那么就只能打开版本是4.22的项目 我们可以按需要选择新项目的类型（以游戏为例）\n选择模版\n项目设置\nC++项目还是蓝图项目？\n蓝图项目：使用蓝图脚本实现功能（不碰任何一行代码，底层还是C++） C++项目：使用C++代码实现功能（需要电脑上装有VS） 目标硬件（PC或移动设备）\n选择PC 目标平台图像画质\n选择最高质量 是否包含初学者内容包\n选择包含 选择项目创建路径以及项目名称\n项目名称开头只支持字母和中文 项目名称支持的特殊符号：_ 点击创建项目\n🍇1.2 虚幻4的工程文件夹结构 Config 包含了项目设置，键盘输入之类的配置文件 Content 存放引擎或游戏的内容，包括地图、贴图、模版、材质、蓝图等 Saved 包含自动保存内容，配置(*.ini)文件以及日志文件 .uproject 项目启动程序，开启我们的项目 🫐1.3 运行我们的游戏 在内容浏览器找到文件夹名字带有BP的文件夹 打开Map文件夹中的关卡 点击工具栏中的播放图标开始游戏 补充：播放游戏时切换到/取消全屏，F11 🍉1.4 初学者内容包 打开 内容浏览器中的StartContent 文件\n里面是官方提供给初学者使用的素材包\n大致包括建筑模型，音频，蓝图，HDRI，关卡，材质，粒子，道具，贴图等\n🍍1.5 快速添加功能或内容包 如果在创建项目的时候，没有选择包含初学者内容包，那么可以通过以下步骤快速添加初学者内容包\n在内容浏览器中的添加/导入中选择添加功能或者内容包\n选择内容包，可以将初学者内容包添加到项目\n除了添加初学者内容包，我们还可以添加蓝图功能，C++功能等\n🍅1.6 对虚幻4每个模版进行展示 第一人称游戏 飞行类游戏 拼图类游戏 滚球类游戏 第三人称游戏 俯视角游戏 通过鼠标来移动人物 双摇杆射击类游戏 手持式AR应用 模版过关游戏 2D模版过关游戏 虚拟现实应用 载具类游戏 高级载具类游戏 🤗2.视口导航 在视口中流畅地移动视角的方法\n方法一：只用鼠标\n按住鼠标左键\n前后移动鼠标：实现视口的前进/后退 左右移动鼠标：实现视口的旋转 按住鼠标右键\n前后移动鼠标：实现视口的俯/仰 左右移动鼠标：实现视口的旋转 按住鼠标中间\n前后移动鼠标：实现上下移动视口\n左右移动鼠标：实现视口的左右移动\n方法二：使用键盘的WASD（前提：按住鼠标的右键）\nW：前进 S：后退 A：左移 D：右移\nQ：镜头的下降 E：镜头的上升\nZ：镜头拉远（会自动复原） C：镜头拉近（会自动复原）\n其它视口导航操作\n快速聚焦到物体身上 先选中要聚焦的物体，再按住F 双击世界大纲上的模型 视口的旋转：alt+鼠标左键 视口的缩放：alt+鼠标右键 视口的平移：alt+鼠标中键 😋3. 编辑界面介绍 🌈3.1 菜单栏 文件 加载和保存项目及关卡 打包项目 编辑 标准的复制和粘贴操作 编辑器首选项和项目设置 插件 窗口 开发者工具 布局的保存和重置 打开内容浏览器 启用全屏：shift+F11 帮助 在线文档和教程等外部资源的链接 ❄️3.2 关卡编辑器(Level Editor)工具栏 保存当前关卡\n一般不使用这个，一般使用下方的保存所有 源码管理\n如果有很多个人同时开发这个项目，那么就需要版本的管理 内容\n如果不小心关掉了内容浏览器的窗口，就可以点击内容重新打开内容管理器 虚幻商场\n可以链接到虚幻商城 设置\n项目设置 插件 一些物体的选择（比如按T，就可以选择半透明物体） 扩展性的设置（比如改画质） 预览之后要打包平台的效果 Magascans\nBridge的插件 蓝图\n打开蓝图类，打开关卡蓝图等 过场动画\n可以添加一些镜头，给我们的场景进行介绍 构建\n当前物体被移动后，阴影就不正确了，会出现提示例如：光照需要构建\n这时我们需要点击构造或仅构建光照让提示消失 在构建的时候我们还可以选择下方的光照质量 还可以构建反射、几何体、路径等\n启动\n可以在不同的平台来启动我们的程序 运行（测试关卡） 选中的视口\n默认在当前视口进行播放 移动设备预览\n会跳出一个移动端的窗口，来预览移动设备上的效果 新建编辑器窗口\n新建一个视口来运行 独立进程游戏\n会单独跳出一个新窗口来运行 模拟\n跳出玩家控制，以上帝视角来查看整个关卡 点击播放后，旁边有一个拥有的选项，点击可以切回玩家控制 高级设置\n可以调整播放时游戏视口的分辨率\n🌊3.3 模式(Modes)面板 显示各种编辑模式，通过该面板可以使用特定的编辑界面来编辑不同类型的Actor\n选择\n可以将下面图标里的物体通过鼠标左键拖动到我们的场景中\n基本：一些基本的几何体和触发器\n光源\n过场动画\n可以选择一些专业的摄像机 视觉效果\n一些大气、雾、云、反射、捕捉、后期处理体积等 这些效果拉到场景中可以实时看到效果 几何体\n建模的工具 体积\n一些不同的容器，比如触发体积（空气墙），可以阻挡角色，不让角色过去 所有类\n地形\n可以搭建我们的开发世界 绘制/雕刻地形 在地形上弄一些河流，道路 通过导入一些高度图，快速生成地形 植物\n可以在我们已经搭建好的地形上，刷一些树、草、灌木、石头等模型，来美化我们的模型\n笔刷编辑\n编辑几何体，例如改变几何体形状\n网格体绘制\n在一个面片/模型上刷上我们想要的材质\n☄️3.4 内容浏览器面板 内容浏览器是在虚幻编辑器中创建、导入、组织、查看和修改内容资源的主要区域\n它可以管理内容文件夹，在资源上执行其它实用操作（如重命名、移动、复制和查看引用）\n内容浏览器可以搜索游戏中的所有资源并与之交互\n注：资源被放置到关卡中后，就会被称之为Actor\n添加/导入\n可以快速添加一些新的类、功能、内容包等\n右击空白区域也可出现\n这里的导入与文件中的导入到关卡是不同的，一般使用这里的导入\n保存所有\n快捷键：ctrl+shift+s 文件夹的显示/隐藏，搜索\n过滤器\n当我们的项目越来越庞大，里面的东西越来越多时，可以通过过滤器来筛选 移动或复制文件\n可以通过拖动某个文件夹到另一个文件夹中，选择移动/复制/拷贝\n还可以将文件夹拖到左边的文件目录中的某个文件夹下\n视图选项卡\n例如：选择显示引擎内容，就可以查看虚幻引擎自带的一些素材 缩略图：可以控制文件夹的缩放，同样，我们也可以使用ctrl+鼠标滚轮来进行缩放 🌟3.5 视口面板 视口就是查看你在虚幻引擎中创建的世界场景的窗口\n你可以像在游戏中导航那样来导航视口，或者可以像使用建筑蓝图进行方案设计那样来应用视口\n虚幻编辑器视口包含各种工具和查看器，可以帮助你精确地看到所需数据\n透视视口：使用消失点呈现出三维世界场景 \u0026mdash; 正常视角模式\n正交视口：将世界场景呈现为二维示意图\n我们可以在窗口处打开多个视口，提高工作效率\n视口选项\n点击下拉的小箭头\n显示数据，显示FPS帧率\n游戏视图：会隐藏我们在游戏中看不到的东西\n沉浸模式F11：让我们的视口全屏 shift+F11：全屏虚幻引擎\n书签，保存某个视角，快捷键ctrl+0到9，即可以保存9个书签\n输入对应的数字即可回到保存书签的那个视角\n注意：书签可以被覆盖\n在此处创建相机\n高分辨率截图\n截图尺寸系数，与电脑的性能有关，一般2~3 布局：可以选择视口的不同模式\n视口类型\n透视视口，顶视口，底视口，左视口，右视口，前视口，后视口\n视口模式\nalt+0，alt+2到8可以切换不同的通道来显示\n在缓冲显示下的总览中，我们可以看到不同通道下的效果\n显示\n里面是一些标签，如果不勾选，那么编辑的时候就会被隐藏起来\n播放的时候还是会显示\n🌌3.6 世界大纲视图面板 世界大纲面板以层次化的树状图形式显示了当前关卡中的所有Actor\n字需要在世界大纲视图面板中单击Actor的名字即可将其选中\n选中的Actor属性将显示在细节面板中\n⚡3.7 细节面板 当我们点击场景中的一个模型/物体后，细节面板就会显示当前物体的一些具体的参数\n我们可以在细节面板中对当前模型进行一些调整，比如改变它的位置，改变它的模型\n替换它的材质，更改它的碰撞，更改它的光照模型，调整它的渲染距离等\n😁4.物体编辑（坐标系，变换单位） 坐标系\nZ轴：上下方向 ，Y轴：左右方向 ，X轴：前后方向 处理变换\n移动：W\n缩放：R\n旋转：E\n还可以在右边的细节面板中手动地输入精确的数值，让该模型移动到对应的位置等\n世界坐标轴和局部坐标轴\n当我们对物体进行旋转后，它自己的坐标轴就会发生改变\n世界坐标轴永远保持水平\n可以点击视口右上角的地球图标，使物体的坐标轴变为世界坐标轴\n单位和度量\n虚幻引擎的单位是uu，相当于厘米 默认情况下玩家通常在游戏场景中高约6英尺，相当于180cm或180uu 对齐到网格\n可以设置每次移动多少厘米，比如每次移动10厘米\n选择视口右上方的设置位置网格对齐值\n还可以设置每次旋转的度数\n选择视口右上方的设置旋转网格对齐值\n注意：每一个都要先打开它们的开关\n调整摄像机的速度\n枢轴点\n我们的模型导入到虚幻引擎中都会有一个坐标轴，有时候这个坐标轴会跑地很远\n将坐标轴重新放到物体上的步骤\n点击坐标轴中间的白色圆点，可以对坐标轴进行移动，将其移动到模型上\n右击白色的点，找到锚点中的设置为锚点偏移量\n这种方式只适用于当前关卡\n在场景中快速选取很多个模型\n在视口中框选模型，框选的快捷键：ctrl+alt+鼠标左键 复制的快捷键：选中物体，按住alt，再拖动\n物体在内容浏览器中显示：ctrl+b\n😚5.导入资源，项目迁移和管理 5.1 导入资源 文件类型\nUE4支持导入各种类型文件的内容\n例如：将模型的贴图、模型、音频等导入UE4中\n一些常用的文件类型和资源类型以及相关的应用程序\n许多资源不是导入的，而是直接在编辑器中创建的\n​ 例如：蓝图类、粒子系统，材质和材质实例等\n在将内容导入到引擎前，我们需要对外部文件进行合理地组织，并遵循命名规范\n内容浏览器\n导入外部应用程序中所创建的外部内容的两种常用方法\n方式一：使用内容浏览器，单击导入按钮或单击资源视图并选择导入到\n转到操作系统的文件管理器，选择要导入的文件，然后将其拖放到内容浏览器中\n资源图标\n资源图标左下角的小星号表示资源尚未保存\n按ctrl+s保存所有资源\n引用查看器\n大多数的资源都依赖一个或多个其它资源\n例如，如果在静态网格体编辑器中将一个材质分配给静态网格体资源，那么静态网格体就会引用该材质 这意味着，当加载静态网格体资源时，还需加载引用的材质 相应地，材质也将加载材质编辑器中引用的纹理 右键我们要查看的资源，右击选择引用查看器\n5.2 项目迁移 项目迁移的两种情况\n情况一：\n我们电脑上通常有两个项目，一个是新建的项目，一个是过去以往的项目\n当我们新建一个项目的时候，可能会用到以前做过的项目的一些素材\n这个时候我们就需要迁移，把旧的工程里的素材迁移到新的项目中\n情况二：\n分享给同事一些自己的东西，就需要迁移项目，把同事可能需要或你想要分享的\n迁移到新的项目中去。或者老板验收，需要弄到一个干净的项目里再打包给你的老板\n迁移文件的步骤\n右键要迁移的文件，选择迁移\n选择要迁移的内容，选择完后点击确定\n选择要迁移到的路径，一定要迁移到目标项目的Content文件夹下面\n如果同时选择多个蓝图/模型/粒子特效来进行迁移，迁移选项就在资产操作中\n网上下载的如何迁移\n从网上下载的资源中找到Content目录下的资源，复制到目标项目的Content文件夹下 最好新建一个文件夹存放网上下载的资源中Content目录下的资源，再进行复制 打包项目回家的步骤**\n找到创建项目的根目录 将缓存文件（Intermediate）和自动保存文件（Saved）删除 右键最外面的项目，添加到压缩文件 5.3 项目管理 😎6.三维模型软件导入虚幻4 maya的插件：虚幻商场的maya livelink，能动画同步\n3dmax和C4d的插件：DataSmith\n文件格式的用途\n.fbx 和 .obj的格式都是三维通用模型格式，都可以用在目前几乎所有主流的三维软件中\n.fbx 中包含动画、材质特性、贴图、骨骼动画、灯光、摄像机等信息\n.obj 中不包含\n.abc 格式，支持动画、粒子等，烘焙三维场景的模型、流体、动画、特效等数据\n总结\n静态或人物骨骼模型，我们通常会使用 .fbx 模型导入到虚幻引擎中有两个类别 静态网格体：静态的摆件，例如家居，道具，鼠标，椅子，房子等 骨骼网格体：有动画的，例如人物模型（要跑步、走路），机械臂 导入流程\n用这几个三维模型软件统一导出一个通用的模型的格式（.fbx、.obj、.abc）\n导出时带贴图：maya在导出时要勾选嵌入式媒体\n导入到虚幻引擎，两种方式\n方式一：选择导入到/Game/_Orion/Meshes\n方式二：直接拖拽到虚幻引擎中\n导入后的设置\nMesh中，如果是静态的模型，他就会自动帮你生成骨骼\nLOD就是能为这个静态网格体自动生成多细节层次\n合并网格体，如果勾选，我们的模型就不是一个一个的，而是一个整体\n法线导入的方法，如果导入的模型出现了问题，例如出现了黑边，就可以\n更改法线导入的方法\n法线生成的方法，如果选择Mikk TSpace就可能出现一些黄色的警告，\n如果你的模型出现了问题，可以把法线生成方法改成内置\nMiscellaneous轴的设置\n转换场景：就是将场景从fbx坐标系转换到虚幻引擎的坐标系\n强制前x轴：强制将这个模型的坐标系为前X轴而不是负Y轴\n一般是让模型的坐标系和UE4里的坐标相匹配，UE4中的坐标系是Z轴朝上\n而maya中是Y轴朝上\n转换场景单元：虚幻引擎的单位默认是厘米，如果别的软件里默认单位不是\n厘米，那么导入进来模型的大小就会发生变化\n如果勾选骨骼网格体，那么导入的模型就会是一个骨骼模型就会有动画\n使用TO作为参考姿势：就是使用动画的第0帧作为参考姿势\n如果不勾选，那么导入进来的模型可能会变形和一些拉伸\n导入变形目标，常用于面部表情\n勾选后，我们导入一些顶点变形动画就能导入进来，然后播放对应的动画\nAnimation，我们导入骨架网格体的时候，是否要导入动画\n因为你导入的这个骨架网格体模型文件里可能携带有动画，这时就需要去勾选动画\n虚幻引擎里默认的动画帧率就是30帧\n🤔7.DataSmith插件使用全流程 虚幻引擎游戏制作教程 一. 入门篇 1. 入门 Eipic Games内容推荐 虚幻学习工具包\n01 常用快捷键 ctrl+B 快速定位物体在内容浏览器中的位置 ctrl+空格 弹出内容浏览器 选中蓝图后，按ctrl+E进入到蓝图中 G键显示图标 02 命名规范 03 材质基础 t键 +鼠标点一下 \u0026ndash; 纹理采样\n在左边纹理的部分选择纹理：\n如何使贴图有凹凸感\u0026ndash;法线贴图：\n贴花材质\n常量：按住1键+鼠标左键 二维向量：按住2键+鼠标左键 三维向量：按住3键+鼠标左键 基础颜色常使用三维向量调节\nMetallic（金属度）和粗糙度常使用常量来调节\n常量值右键选中，转换为参数\n按住m键+点击画面 \u0026mdash;- 乘法\nC键\u0026ndash;描述框\n按住alt键，可以将连接的线断开\n控制当前贴图密度：按住U键+点击空白处\n04 灯光基础 关闭自动曝光：\n先创建一个后期盒\n然后将它的maxEV值和minEV值，设为0\n05 蓝图 创建第一个蓝图Actor\n放到新建Blueprints文件夹中\n右击内容浏览器的空白位置处，新建一个蓝图类\n会弹出选取父类，我们选择Actor\n命名，前面加一个BP_\n点击创建好的蓝图就可以进入蓝图编辑\n点击左上角的添加\n我们添加一个盒子触发器【用于检测什么东西进入到这个框了】\n可以在右边更改盒体的范围\n还可以再添加一个文本渲染组件\n可以在右边更改文本的内容\n编写第一段蓝图代码\n当组件开始重叠时（人物和盒体触发器相碰时），就将文本从xxx设置为value(yyyy)\n先选中盒体触发器，然后在右侧找到组件开始重叠时\n或者在左边右击盒体触发器，添加事件，添加组件开始重叠时\n然后将TextRander拖入进去\n设置文本\n选择value，更改变量名\n最后编译一下（左上角）\n还可以添加组件结束重叠时\n触发火焰蓝图\n实现：当人物靠近球的时候，火焰就升起，当人离开时，火焰就熄灭\n新建一个蓝图Actor，改名BP_\n双击进入，添加一个球体\n可以改材质（选中球后，右侧）\n添加火焰，火焰是粒子系统 （这里我们选cascade particle system）\n默认情况下，我们不希望火焰是燃烧的，可以在右侧细节面板中将火焰的可视关掉\n添加一个盒体触发器，更改盒体范围（当人物进入该范围，火焰就燃烧）\n选择盒体触发器\u0026ndash;添加事件\u0026ndash;组件开始重叠时\n将火焰拖入，然后设置粒子可视性\n勾选new visiblity\n选择盒体触发器\u0026ndash;添加事件\u0026ndash;组件结束重叠时\n最后，编译+保存\n1.1 初涉玩家角色 修改游戏模式\n世界场景设置中将游戏模式改为Third Person\n我们也可以将这个模式找到后，复制一份到我们自己的角色文件夹下\n改名后选择我们重命名的游戏模式\n我们还可以将人物复制一份后，将默认pawn类更改为我们自己的角色\n修改玩家视角\n先将玩家出生点删掉，用我们的主角代替 然后在细节中选择自动控制中的玩家0 玩家出生点的设置\n默认出生点\n创建一个玩家出生点：创建-基础-玩家出生点\n缺点：不知道自己的人物长什么样\n从第三人称游戏中复制一个角色到我们自己的文件中\n然后再将人物拖到我们的场景中\n此时，摄像机可能会挡住视口。我们在编辑-编辑器偏好设置中搜cam\n有一个摄像机的预览大小，我们可以调整这个数值，比如2.0\n最后修改自动控制玩家\n1.2 导入后的模型设置 导入后设置合并网格体\n如何统一导入进来的模型的比例\n从形状中拖一个空的球体，用来作为参照，选择模型和球体，在大纲视图右键\n选择将Actor转换为静态网格体，然后选择Mashes文件夹，名字用SM_开头\n命名，贴图用M_开头；纹理用T_开头；模型用SM_开头\n给导入的模型设置碰撞\n模型刚导入进来时，人物可以穿过模型，所以需要给模型设置碰撞.\n步骤：\n选择模型，按ctrl+E，进入模型的静态网格体编辑\n（1）显示碰撞：显示\u0026ndash;简单碰撞\n（2）添加碰撞：碰撞\u0026ndash;自动凸包碰撞\n（3）点应用\n（4）通过调整凸包数量，最大外壳定点数等数值以获得精确的碰撞\n1.3 初涉地形 创建地形 创建地形：快捷键shift+2\n可以选择地形的分段大小，材质\n创建好后，可以选择雕刻\n通过更改笔刷尺寸、衰减程度、工具强度等雕刻我们的地形\n创建一片大海 在放置Actor下找到几何体，选择盒体\n在右侧的细节面板中更改画刷设置\n并在画刷设置高级下，选择创建静态网格体\n存放到我们的Meshes文件夹下，文件名以SM_开头\n在材质中选择Ocean材质\n创建植物 植物编辑模式shift+3\n初学者内容包的静态网格体的位置如下：\n添加植物：直接将静态网格体中的植物拖入到植物编辑模式-绘制下的方框内\n在打勾的情况下，我们就可以绘制相应的植物（按住shift可以把种植的植物去掉）\n调整草和花的密度\n选择要调整密度的植物\n然后将这个地方点亮\n在下方将密度修改\n调整草或花的大小\n先勾选要调整大小的植物，然后调整缩放\n1.4 初涉视觉效果 指数级高度雾 视觉效果中的指数级高度雾\n在细节面板中调整雾的强度、衰减、颜色\n还可以将体积雾打开，用来产生光的散射\n光 定向光源\n同样也可以调整光的颜色，强度\n勾选光束遮挡后，光就变成一束一束的了\n天光\n作用：将整个天空照亮后，变成一个泛光源来照向整个大地\n可以设置它的强度范围\n后期处理体积\n可以用来调色，光的强度等调整\n后期处理体积可以只在方框内处理，勾选无限范围后也可以整个世界\n调光的强度：bloom下\n调整曝光值\n镜头特效\n镜头上像有脏东西\n镜头光晕\n可以将镜头边角变暗\n后期处理体积的调色功能\n可以调白平衡\n全局的可以调饱和度，对比度，增益等\n1.5 初涉粒子 简单地设置粒子系统\n​\t1. 属于特效，命名为FX\n​\t2. 在内容浏览器空白处右键- FX - Niagara系统\n​\t​\t然后下一步，选择Hanging Particulates，添加，完成\n​\t​\t再改名，以 FX_开头，例如：\n​\t双击进入\n首先将发射器的属性改为GPU，以便产生更多的粒子\n右侧：\n调整粒子的数量\n调整范围的大小\n让粒子发光\n只需要将rgb的数值超过1，想显示出偏蓝的粒子就将b的值调高一些\n按键盘上的G键，取消选中\n1.6 初涉声音 导入音频文件（背景音乐+环境音）\n新建一个文件夹，取名Audio\n只能导入wav或者aif文件\n可以先选择你要导入的文件，再ctrl+c，点击添加，导入到\u0026hellip;\n让音频不断循环播放\n双击进去，点击窗口-细节\n可以将正在循环勾上\n有些声音是只有靠近才能听到，离远了听不到的\nStarterContent里面提供了一些声音还有特效\n我们可以直接使用，以火为例\n将火的特效和声音放到一起，然后在声音的细节面板更改设置\n打开允许空间化，打开重载衰减。内部半径内声音不会衰减\n按G切换可视\n1.7 初涉材质 新建文件夹，文件名为materials\n右击内容浏览器的空白处，创建材质，重命名以M_开头\n双击进入\n让球有颜色，在基础颜色中右击提升为参数\n双击基础颜色这个框，来选取颜色\n选颜色，饱和度和和亮度都要调整\n可以调整混合模式和双面\n混合模式可以调 半透明和已遮罩\n双面打开后，可以看到模型的内部结构\n金属度、粗糙度、高光度\n高光的值越高，亮的地方越亮\n自发光颜色\n任何一个数值超过1，就可以发光\n纹理贴图\n做一个木头材质\n按键盘的t键+鼠标左键 \u0026mdash;-\u0026gt; 纹理采样\n做出凹凸感 \u0026mdash;\u0026gt; 法线\n如何制作法线贴图 \u0026mdash;- \u0026gt;在substance painter里面导出的时候就会法线==发现生成好的法线贴图\n如何用我们自己的纹理来做贴图？\n1）先新建一个文件夹 Texture，然后右键导入到\u0026hellip; 把自己的贴图导入，命名以T_开头\n材质以M_开头。\n2）导入纹理后，拖入到模型中就会自动创建材质，把材质放到Material文件夹中\n如果不想要有些模型被该材质影响，可以在细节面板中将接收贴花的勾取消\n如果是人物，就 ctrl+e 点击网格体，在右边的细节中搜 decal 把接收贴花取消勾选\n3）制作法线贴图，让材质有凹凸感\n把纹理丢进photoshop中，选择上方工具栏的 滤镜 \u0026ndash;\u0026gt; 3D \u0026ndash;\u0026gt; 生成法线图（还可以调整模糊，细节缩放）\n然后导出格式 png\n3）将法线图片导入，名字T_开头， _N结尾，然后在材质中添加法线的步骤和之前的一样\n1.8 初涉过场动画 添加关卡序列\n放到Cinematics文件夹下，文件以SEQ_开头\n新建相机\n可以调整焦距\n还可以调光圈：数字越小，光圈越大\n选好角度后，按 s 打关键帧\n往然后换场景，并将光标后拖一段后，再按s\n可以再多添加几个镜头\n2.角色入门 3.场景入门 4.构造脚本 二、角色篇 其它 最后做成视频 项目1\u0026ndash;场景 ","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/ue-basic/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E7%A9%BF%E8%B6%8A%E6%97%B6%E7%A9%BA-%E9%A3%8E%E9%93%83%E5%A5%B3%E5%AD%A9_hu_dd89634deebccccd.png","permalink":"https://Amarantos-Arrebol.github.io/p/ue-basic/","title":"【虚幻引擎】-ue基础入门"},{"content":"00-前言 0.1-UE4学习途径 虚幻引擎官网\n官方学习网站\nUE4.27 官方文档\n相关书籍\n虚幻引擎的中国官方微信公众号\n技术博客网站\n虚幻4官方论坛\nreddit论坛网\nyoutube\n虚幻引擎的QQ交流群\n百度贴吧\n0.2修改UE4缓存路径 D:\\UE5\\software\\UE_4.27\\Engine\\Config 路径下找到 BaseEngine.ini 这个文件并打开\n打开后，按ctrl+f 搜索 InstalledDerivedDataBackendGraph\n将path里的路径改成 %GAMEDIR%DerivedDataCache\n01入门 快捷键 调出内容浏览器：ctrl+空格\n旋转视口：按住鼠标右键，然后移动鼠标\n左右前后移动视口：按住鼠标右键的同时按W、A、S、D\n上下移动视口：按住鼠标右键的同时按Q、E\n镜头焦段的切换：按住鼠标右键的同时按Z、C\n对物体的变换和对齐：选择\\平移\\旋转\\缩放 QWER\n控制视口的简单方法：按住鼠标左键、中间、右键，分别可以实现前进、上下、旋转\n快速定位目标：在视口中选择一个物体，再按F\n或者在右边的大纲中双击该物体的名称\n选择一个物体之后，快速在内容浏览器中定位：ctrl+b\n1.1新建项目 1.2相机的移动速度 1.3修改编辑器的语言 1.4修改默认打开的地图 1.5文件夹结构说明 _项目名 Blueprints 蓝图 Maps 地图 Materials 材质 Meshes 网格体 Textures纹理 FXs粒子与特效 Audio音频 Cinematics过场动画 Characters角色 角色名 Animations动画 Meshes Textures Materials Props资产 资产名 Materials Textures 例子\n1.6放置各种光源 或者点击放置Actor面板\n1.7玩家出生点的几种不同方式 方式一：\n使用玩家出生点\n方式二：\n将第三人称游戏的角色蓝图复制到我们自己的文件夹中\n还需要在细节面板中修改自动控制玩家\n修改摄像机预览大小\n","date":"2025-11-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/ue-basic-new/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E7%A9%BF%E8%B6%8A%E6%97%B6%E7%A9%BA-%E9%A3%8E%E9%93%83%E5%A5%B3%E5%AD%A9_hu_dd89634deebccccd.png","permalink":"https://Amarantos-Arrebol.github.io/p/ue-basic-new/","title":"【虚幻引擎】-ue入门-新"},{"content":"1、Max入门 1.1 新建patch 1.1.1新建pacth 打开max后，我们可以ctrl+n新建patch\n或者也可以：file\u0026ndash;\u0026gt;New Patcher\n1.1.2调整界面的大小 打开patch后，在patch上面一栏是对象\n我们可以先将其中的numbers拖出来看看\n我们发现画面里的东西非常小，我们可以使用ctrl+鼠标滚轮，放大或缩小画面\n或者点击左上角的100%符号的下拉箭头来调整画面大小\n1.1.3编辑模式和工作模式 Max中有两种模式一种是编辑模式，一种是工作模式\n编辑模式下，我们可以新建对象，对patch里的对象做各种操作 工作模式下，不能编辑物体，但是可以运行 pacth界面的左下角的有一个锁的图标，我们可以通过鼠标点击左下角的小锁，\n切换patch的模式。锁打开就是编辑模式，锁关闭就是工作模式\n当然也可以使用快捷键ctrl+e 来开锁或关锁\n1.1.4comment注释 comment就是一个文本框，我们可以用来做注释，快捷键是c\n我们可以通过调整滑块来调整comment的大小\n也可以使用ctrl+j自动调整大小（该快捷键适用于所有对象）\n1.1.5toggle开关 我们可以拖出来一个toggle\n在建几个number对象\n复制可以使用 alt+拖动对象，是新建对象\n将他们连接，在锁定状态下点击toggle，我们发现是点亮的，并且所有数字框中\n的数字都变为了0\n当我们再次点击toggle，数字框里的数字都变回了0\n1.1.6输入与输出 在Max中信号总是从outlets到inlets，一直到对象末尾\ninlets就是object inputs对象输入 outlets就是object outputs对象输出 快捷键总结 1.2 在Max中求和两个数字 点击图标或者按键盘上的n来新建对象\n我们在对象框中输入加号并按回车\n新建3个数字框，并连接\n在锁定状态下，我们可以通过右击数字框按住左右拖动来调整数字框里的数字\n或者单击数字框，输入你想要的数字\n在锁定状态下，我们发现更改连接在蓝色输入口上的数字框时，结果不会变\n而当我们更改连接在红色输入口上的数字框时，结果立马就变化了\n1.3热输入口和冷输入口 快捷键 1.4Max中的数据流从右向左 在上面这个程序中，我们发现更改连接冷输入口的数字框里的数字是时，计算的结果\n是先前存储在冷输入口的数字和存储在热输入口的数字相加\n分析：上一次冷输入口里的数字是5，因为数据流是从右往左，\n所以本次会先执行两数相加，也就是11+5=16 然后执行将2存储到冷输入口中 因为数据流是从右往左，\n所以本次会先执行将2存储到冷输入口中 然后执行两数相加11+2=13 1.5 对象参数 参数是用来设置对象的选项的，必须按特定顺序写入\n当冷输入口的数字变化时，会覆盖初始值\n查看帮助文档：alt+单击对象\n1.6小数 如果+后面没有写数字或数字是整数的话，那么计算出来的结果也是整数\n+后面跟一个浮点数的话，计算结果就是浮点数\n2.Jitter 1.1 矩阵 什么是Jitter Jitter是Max/MSP中拥有的对象库\n我们可以用它来处理视频和图像以及3D图形\n如何使用Jitter播放电影 使用jit.movie\n通过将视频直接拖入到该对象中或者通过点击read信息框来选择影片\nvol 0 可以设置音量为0\n在对象后边使用@可以设置属性 jit.movie需要bang来驱动，我们可以使用\tmetro\n如何确定metro后面跟的数值？\n如何知道影片的帧速率？\n添加一个route后可以去掉我们不想要的内容\n如果我们希望能自动根据电影的美秒帧数自动调整metro对象的间隔\n我们可以使用感叹号!/ 1000 表示用1000除以1个数\njit.fpsgui对象，显示每秒传入的帧速率\n什么是Jitter Matrix 数字图像通常是一个二维网格，其中每个网格的单元都包含一个像素\njitter matrix实际上就是一个包含一些数据的网格\n而包含图像的jitter matrix是一个二维网格\nA 透明度\nR\nG\nB\n默认情况下：\n像素或矩阵单元格的值范围将从0到255\n如何看到可视化的红绿蓝通道呢？\n我们可以发送消息plane加上0到3的数字，而0到3的数字可以由radiogroup产生\n1.2 Matrices和Texture 什么是CPU和GPU\ntextures使用GPU工作，matrices使用CPU工作\nCPU是核心处理，GPU是图形处理单元\nCPU主要用于处理复杂的计算，但不是高度并行的\nGPU是高度并行的，但不执行真正复杂的操作\n并行：\n比如CPU可能只有8个core，那么CPU处理器在每个计算机周期只能同时\n发生8个并行操作。\n但是GPU是由很多core组成的，这些cores都是并行执行大量操作的\n例如：在屏幕上绘制像素，因为我们有很多像素，屏幕的每次刷新率都\n必须将这些像素调整为新值，这意味着计算机要处理大量信息，因而需要\n许多核心同时处理\n在Max中使用GPU的强大功能来实现视觉效果\njitter Matrix停留在我们计算机的随机存取存储器RAM中\njit.movie发送的matrix信息是jit_matrix加上矩阵的名称\n然后每个接收到这个信息的对象就会去计算机的RAM中去找\nTextures 工作需要OpenGL Context\n当我们想向GPU发送指令时，我们需要使用类似opengl的东西\nOpenGL是一组与GPU通信的命令，也被称为应用程序编程接口即API\n因此Max使用OpenGL库或者说API\n创建这个context我们只需要创建一个jit world对象\n有了这个对象之后，我们可以用max中的所有GPU对象\n激活这个对象需要使用toggle，此后，我们不再需要使用bang就可以连续播放影片\ntexture不在RAM中，而是在显存vRAM（video random axis memory中，速度更快\n如果用矩阵的方式播放，视频数据需要从主内存（RAM）传输到显存（VRAM）才能被 GPU 处理。 如果用纹理的方式播放，数据已经在显存中，省去了传输过程，大幅提升了性能。 1.3 Vizzie模块 笔记2 1.1 初识Max/MSP/jitter 如何创建对象：n 或 双击空白处\n1、jit.pwindow对象 ：屏幕，可以将视频显示到屏幕上进行预览\n2、jit.movie对象\n3、画框对象：lcd\n4、合成list的工具的对象：pak 后面可以加 s 或 0 或 0.等\n5、拆解类工具：unpack\n如何创建信息框：m\n信息框里输入的数据，常用于给不同对象下达指令\n1、信息框中输入read指令，表示读取。可以是读取字符，数字，也可以读取音视频等\n​ 当连在jit.movie对象上时，点击red信息框可以读取电脑上的视频/音频等\n2、设置画笔颜色的信息：frgb 255 0 0 代表红色\n3、画椭圆：paintoval 50 50 100 100\n4、画矩形：paintrect 50 50 100 100\n如何创建数字框\n创建整数框：i\n创建小数框：f\n触发指令：b\n会生成一个bang指令，让对象执行一次\n1.2程序的运行方向 横向排列运行规则：max遵循从右向左运行的原则\n纵向排列运行规则：max遵循从下往上运行的原则\n斜向排列运行规则：max优先遵循从右向左运行的原则\n快捷键梳理 1、ctrl + 点击空白处：锁定/解锁\n2、复制对象：alt+鼠标拖动\n","date":"2024-09-02T00:00:00Z","image":"https://Amarantos-Arrebol.github.io/p/max-msp-jitter-basic/07_hu_f45abe1b46c1dae9.png","permalink":"https://Amarantos-Arrebol.github.io/p/max-msp-jitter-basic/","title":"【MaxMSPJitter】基础入门"}]