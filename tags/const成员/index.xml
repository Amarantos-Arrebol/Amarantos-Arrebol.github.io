<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Const成员 on PursUnre的博客</title>
        <link>https://Amarantos-Arrebol.github.io/tags/const%E6%88%90%E5%91%98/</link>
        <description>Recent content in Const成员 on PursUnre的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>PursUnre</copyright>
        <lastBuildDate>Sun, 02 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://Amarantos-Arrebol.github.io/tags/const%E6%88%90%E5%91%98/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>【C&#43;&#43;初阶】04类和对象（下）</title>
        <link>https://Amarantos-Arrebol.github.io/p/class-with-object-03/</link>
        <pubDate>Sun, 02 Nov 2025 00:00:00 +0000</pubDate>
        
        <guid>https://Amarantos-Arrebol.github.io/p/class-with-object-03/</guid>
        <description>&lt;img src="https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91AI-AI%E9%A3%8E%E6%99%AF.png" alt="Featured image of post 【C&#43;&#43;初阶】04类和对象（下）" /&gt;&lt;h1 id=&#34;1再谈构造函数&#34;&gt;1、再谈构造函数
&lt;/h1&gt;&lt;h2 id=&#34;11初始化列表&#34;&gt;1.1初始化列表
&lt;/h2&gt;&lt;p&gt;在讲构造函数的时候，我们提到过编译器默认自动生成的构造，对于自定义类型的成员变量，会调用&lt;/p&gt;
&lt;p&gt;它的默认构造，如果没有默认构造，编译器就会报错，&lt;/p&gt;
&lt;p&gt;所以我们必须初始化这个成员变量，需要用初始化列表才能解决&lt;/p&gt;
&lt;p&gt;语法上可以理解为初始化列表是每个成员变量定义初始化的地方&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始化列表的使用是以一个冒号开始，接着是一个以逗号分隔的数据成员列表，&lt;/p&gt;
&lt;p&gt;每个”成员变量“后面跟一个放在括号中的初始值或表达式（可以malloc）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911191939901.png&#34;
	width=&#34;696&#34;
	height=&#34;396&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911191939901&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;175&#34;
		data-flex-basis=&#34;421px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）注意/细节：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个成员变量在初始化列表中只能出现一次&lt;/p&gt;
&lt;p&gt;（语法上可以理解为初始化列表是每个成员变量定义初始化的地方）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span style=&#34;color: #8080FF;&#34;&gt;引用成员变量&lt;/span&gt;，&lt;span style=&#34;color: #8080FF;&#34;&gt;const成员变量&lt;/span&gt;，&lt;span style=&#34;color: #8080FF;&#34;&gt;没有默认构造的类类型成员变量&lt;/span&gt;，（const变量也只能在定义的时候初始化）&lt;strong&gt;必须放在初始化列表位置进行初始化&lt;/strong&gt;，否则会编译报错&lt;/p&gt;
&lt;p&gt;引用只能在定义的时候初始化，const修饰的是不能被修改的，也只能在初始化的时候修改&lt;/p&gt;
&lt;p&gt;没有默认构造，意味着要调用它的构造就只能传参，那么我们就必须初始化&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192020384.png&#34;
	width=&#34;1185&#34;
	height=&#34;839&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192020384&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;338px&#34;
	
&gt; &lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192027652.png&#34;
	width=&#34;338&#34;
	height=&#34;317&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192027652&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;106&#34;
		data-flex-basis=&#34;255px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C11支持在成员变量声明的位置给缺省值，这个缺省值主要是给&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有显示在初始化列表初始化的成员使用的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;尽量使用初始化列表初始化，因为那些你不在初始化列表初始化的成员也会走初始化列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于自定义类型的成员变量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++并没有规定。对于没有显示在初始化列表初始化的自定义类型成员会调用这个成员类型的默认构造函数，如果没有默认构造会编译错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于内置类型的成员：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果这个成员在初始化列表没有显示地给值，但是在声明位置给了缺省值，那么，初始化列表会用这个缺省值初始化。【缺省就是备用的意思】&lt;/p&gt;
&lt;p&gt;如果在声明的时候没有给缺省值，那么初始化列表初始化的内置类型成员是否初始化取决于编译器&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192139495.png&#34;
	width=&#34;760&#34;
	height=&#34;197&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192139495&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;385&#34;
		data-flex-basis=&#34;925px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192202082.png&#34;
	width=&#34;534&#34;
	height=&#34;216&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192202082&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;247&#34;
		data-flex-basis=&#34;593px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-初始化列表总结&#34;&gt;1.2 初始化列表总结
&lt;/h2&gt;&lt;p&gt;&lt;span style=&#34;color: #8080FF;&#34;&gt;每个成员变量都要走初始化列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果在初始化列表中，已经显示地初始化了，那么就用显示初始化的值&lt;/p&gt;
&lt;p&gt;如果在初始化列表中没有显示初始化，那么就用缺省值&lt;/p&gt;
&lt;p&gt;如果没有缺省值，那么内置类型初始化为随机值，自定义类型就调默认构造（如果没有，就编译报错）&lt;/p&gt;
&lt;p&gt;构造函数初始化成员，尽量使用初始化列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192217136.png&#34;
	width=&#34;1261&#34;
	height=&#34;561&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192217136&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;224&#34;
		data-flex-basis=&#34;539px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化列表中按照成员变量在&lt;strong&gt;类中声明的顺序&lt;/strong&gt;进行初始化，不是按照成员在初始化列表出现的先后顺序来初始化的。【建&lt;span style=&#34;color: #8080FF;&#34;&gt;议声明顺序和初始化列表顺序保持一致&lt;/span&gt;】&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192232576.png&#34;
	width=&#34;698&#34;
	height=&#34;929&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192232576&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;75&#34;
		data-flex-basis=&#34;180px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2隐式类型转换&#34;&gt;2、隐式类型转换
&lt;/h1&gt;&lt;p&gt;两个类型之间有一定的关联才能互相转换。算术类型之间能互相转，因为它们都表数据大小&lt;/p&gt;
&lt;p&gt;指针和整型之间，指针本质是一个地址的编号，也是表数据的大小&lt;/p&gt;
&lt;p&gt;一个类型，如果支持单参数的构造函数，那这个参数的类型支持隐式类型转换&lt;/p&gt;
&lt;p&gt;单参数的构造函数支持隐式类型转换&lt;/p&gt;
&lt;h2 id=&#34;21内置类型和自定义类型之间的转换&#34;&gt;2.1内置类型和自定义类型之间的转换
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C++支持内置类型隐式转换为类类型对象，需要有相关内置类型为参数的构造函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192314313.png&#34;
	width=&#34;652&#34;
	height=&#34;1020&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192314313&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;63&#34;
		data-flex-basis=&#34;153px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192321049.png&#34;
	width=&#34;751&#34;
	height=&#34;280&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192321049&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;268&#34;
		data-flex-basis=&#34;643px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）类型转换之间会产生临时对象，临时对象具有常性（要加const）&lt;/p&gt;
&lt;p&gt;类型不同的两个变量之间的赋值，是把类型转换之间产生的临时对象拷贝给目标变量&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;2）编译器遇到连续构造+拷贝构造-&amp;gt;优化为直接构造&lt;/p&gt;
&lt;p&gt;3）不能通过使用( , )的方式调用多参数的构造&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192339056.png&#34;
	width=&#34;328&#34;
	height=&#34;170&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192339056&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;463px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192347809.png&#34;
	width=&#34;560&#34;
	height=&#34;65&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192347809&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;861&#34;
		data-flex-basis=&#34;2067px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;实际调用的还是单参数的构造&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192404638.png&#34;
	width=&#34;283&#34;
	height=&#34;116&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192404638&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;243&#34;
		data-flex-basis=&#34;585px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果我们希望调用&lt;span style=&#34;color: #FF0000;&#34;&gt;多参数&lt;/span&gt;的构造，C++11支持的写法是使用&lt;span style=&#34;color: #FF0000;&#34;&gt;{ }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192429959.png&#34;
	width=&#34;801&#34;
	height=&#34;87&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192429959&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;920&#34;
		data-flex-basis=&#34;2209px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在构造函数前面加 explicit 就不再支持隐式类型转换&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192449736.png&#34;
	width=&#34;629&#34;
	height=&#34;471&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192449736&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22类型转换的应用场景&#34;&gt;2.2类型转换的应用场景
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192509814.png&#34;
	width=&#34;766&#34;
	height=&#34;428&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192509814&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;429px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;23自定义类型和自定义类型之间的转换&#34;&gt;2.3自定义类型和自定义类型之间的转换
&lt;/h2&gt;&lt;p&gt;类类型的对象之间也可以隐式转换，需要相应的构造函数支持&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192532664.png&#34;
	width=&#34;276&#34;
	height=&#34;384&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192532664&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;71&#34;
		data-flex-basis=&#34;172px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192541272.png&#34;
	width=&#34;654&#34;
	height=&#34;98&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192541272&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;667&#34;
		data-flex-basis=&#34;1601px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;aa3会构造生成一个临时对象，临时对象再拷贝构造给b，实际上编译器做了优化&lt;/p&gt;
&lt;p&gt;直接构造&lt;/p&gt;
&lt;h1 id=&#34;3static成员&#34;&gt;3、static成员
&lt;/h1&gt;&lt;h2 id=&#34;31静态成员变量&#34;&gt;3.1静态成员变量
&lt;/h2&gt;&lt;p&gt;变量静态成员变量就是被static修饰的成员变量&lt;/p&gt;
&lt;p&gt;静态成员变量遵循 类里声明，类外初始化&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192637385.png&#34;
	width=&#34;432&#34;
	height=&#34;324&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192637385&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态成员变量为类的所有对象所共享，不属于某个具体的对象，不存放在对象中，存放在静态区&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32静态成员函数&#34;&gt;3.2静态成员函数
&lt;/h2&gt;&lt;p&gt;普通成员函数有this指针，必须用对象调用&lt;/p&gt;
&lt;p&gt;静态成员函数被static修饰，静态成员函数没有this指针，可以不用对象调用（对象调用也可以）&lt;/p&gt;
&lt;p&gt;它指定类域就可以调用（如果是公有的情况下）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态成员函数中可以访问其它静态成员，但是不能访问非静态的，因为没有this指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192726513.png&#34;
	width=&#34;399&#34;
	height=&#34;417&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192726513&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;229px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非静态的成员函数，可以访问任意的静态成员变量和静态成员函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不用成员函数的类，就可以考虑做成静态成员函数，这样对象可以调，通过类域也可以调&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33静态成员的访问和细节&#34;&gt;3.3静态成员的访问和细节
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以通过类名::静态成员 或者对象.静态成员 来访问静态成员变量和静态成员函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192805039.png&#34;
	width=&#34;551&#34;
	height=&#34;295&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192805039&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;186&#34;
		data-flex-basis=&#34;448px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态成员也是类的成员，受pubic、protected、private 访问限定符的限制&lt;/p&gt;
&lt;p&gt;访问限定符限制的是类外面去直接访问，在类里面不受限制&lt;/p&gt;
&lt;p&gt;如果想在类外面访问静态成员，可以在类里面提供Get函数，返回静态成员的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911192913583.png&#34;
	width=&#34;299&#34;
	height=&#34;174&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911192913583&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;412px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;静态成员变量不能在声明位置给缺省值初始化，因为缺省值是给构造函数初始化列表的，静态成员变量不属于某个对象，不走构造函数初始化列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4友元&#34;&gt;4、友元
&lt;/h1&gt;&lt;p&gt;友元提供了⼀种突破类访问限定符封装的方式&lt;/p&gt;
&lt;p&gt;（想在类外面访问类私有的的成员）&lt;/p&gt;
&lt;p&gt;友元分为：友元函数和友元类，在函数声明或者类声明的前面加friend，&lt;/p&gt;
&lt;p&gt;并且把友元声明放到⼀个类的里面。&lt;/p&gt;
&lt;p&gt;• 外部友元函数可访问类的私有和保护成员，友元函数仅仅是⼀种声明，他不是类的成员函数。&lt;/p&gt;
&lt;p&gt;• 友元函数可以在类定义的任何地方声明，不受类访问限定符限制。&lt;/p&gt;
&lt;p&gt;• ⼀个函数可以是多个类的友元函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193013253.png&#34;
	width=&#34;801&#34;
	height=&#34;1028&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193013253&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;77&#34;
		data-flex-basis=&#34;187px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友元类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;友元类中的成员函数都可以是另⼀个类的友元函数，都可以访问另⼀个类中的私有和保护成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250914204803985.png&#34;
	width=&#34;787&#34;
	height=&#34;1171&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250914204803985&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;67&#34;
		data-flex-basis=&#34;161px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;友元类的关系是单向的，不具有交换性，比如A类是B类的友元，但是B类不是A类的友元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;友元类关系不能传递，如果A是B的友元， B是C的友元，但是A不是C的友元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。&lt;/p&gt;
&lt;p&gt;耦合度指两个函数的关系，关系越紧密，耦合度就越高&lt;/p&gt;
&lt;p&gt;一般要求：低耦合，高内聚&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5内部类&#34;&gt;5、内部类
&lt;/h1&gt;&lt;p&gt;如果⼀个类定义在另⼀个类的内部，这个定义在另一个类内部的类就叫做内部类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193144087.png&#34;
	width=&#34;584&#34;
	height=&#34;696&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193144087&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;83&#34;
		data-flex-basis=&#34;201px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内部类是一个独立的类，不会变为外面类的一部分，sizeof（外部类）不会计算内部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部类会受到外面的类的类域的限制。也就是访问时要带上外面的类域&lt;/p&gt;
&lt;p&gt;还会受到外面类的访问限定符的限制，如果外部类给内部类的访问限定符为private，则在类外访问内部类会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193244128.png&#34;
	width=&#34;175&#34;
	height=&#34;52&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193244128&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;336&#34;
		data-flex-basis=&#34;807px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部类本质是一种封装，当A类跟B类紧密关联，A类实现出来主要就是给B类使用，那么可以考虑把A类设计为B的内部类，如果放到private/protected位置，那么A类就是B类的专属类，其它地方都用不了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部类默认是外部类的友元&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6匿名对象&#34;&gt;6、匿名对象
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用类型(实参)定义出来的对象叫匿名对象&lt;/p&gt;
&lt;p&gt;匿名对象调用无参构造时要带上括号，有名对象不用带&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193323548.png&#34;
	width=&#34;425&#34;
	height=&#34;281&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193323548&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;151&#34;
		data-flex-basis=&#34;362px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;匿名对象的生命周期只在当前行&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193340002.png&#34;
	width=&#34;371&#34;
	height=&#34;279&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193340002&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;319px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193346843.png&#34;
	width=&#34;674&#34;
	height=&#34;264&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193346843&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;255&#34;
		data-flex-basis=&#34;612px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匿名对象还可以给函数的自定义类型参数做缺省值&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193408624.png&#34;
	width=&#34;500&#34;
	height=&#34;639&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193408624&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;78&#34;
		data-flex-basis=&#34;187px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193416766.png&#34;
	width=&#34;361&#34;
	height=&#34;105&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193416766&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;343&#34;
		data-flex-basis=&#34;825px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匿名对象可以被引用，但是匿名对象和临时对象一样，具有常性，需要加const&lt;/p&gt;
&lt;p&gt;const会延长匿名对象的生命周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193454041.png&#34;
	width=&#34;297&#34;
	height=&#34;67&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193454041&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;443&#34;
		data-flex-basis=&#34;1063px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;7对象拷贝时的编译器优化&#34;&gt;7、对象拷贝时的编译器优化
&lt;/h1&gt;&lt;p&gt;现代编译器会为了尽可能提高程序的效率，在不影响正确性的情况下会尽可能减少&lt;/p&gt;
&lt;p&gt;⼀些传参和传返&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;赋值时隐式类型转换的优化&lt;/p&gt;
&lt;p&gt;从语法上1先构造一个临时对象，临时对象再拷贝构造给aa0&lt;/p&gt;
&lt;p&gt;编译器优化为直接构造&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193528704.png&#34;
	width=&#34;369&#34;
	height=&#34;124&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193528704&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;297&#34;
		data-flex-basis=&#34;714px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传值传参&lt;/p&gt;
&lt;p&gt;不会优化，先aa1构造一个对象，然后aa1拷贝构造一个临时对象作为函数f1的参数&lt;/p&gt;
&lt;p&gt;该临时对象在函数中，属于局部变量，出函数对象就销毁&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193555678.png&#34;
	width=&#34;418&#34;
	height=&#34;162&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193555678&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;258&#34;
		data-flex-basis=&#34;619px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传参时，隐式类型，连续构造+拷贝构造-&amp;gt;直接优化为构造&lt;/p&gt;
&lt;p&gt;先用1构造一个A的临时对象，然后用它再去拷贝构造aa&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193624016.png&#34;
	width=&#34;308&#34;
	height=&#34;104&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193624016&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;296&#34;
		data-flex-basis=&#34;710px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193630050.png&#34;
	width=&#34;390&#34;
	height=&#34;46&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193630050&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;847&#34;
		data-flex-basis=&#34;2034px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个表达式中，连续构造+拷贝构造-&amp;gt;优化为一个构造&lt;/p&gt;
&lt;p&gt;本应该A(2)构造一个匿名对象，再用匿名对象拷贝构造给f1的参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193705120.png&#34;
	width=&#34;329&#34;
	height=&#34;65&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193705120&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;506&#34;
		data-flex-basis=&#34;1214px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传值返回也会优化&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193721726.png&#34;
	width=&#34;433&#34;
	height=&#34;454&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193721726&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193727357.png&#34;
	width=&#34;246&#34;
	height=&#34;114&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193727357&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;517px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193756057.png&#34;
	width=&#34;891&#34;
	height=&#34;619&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193756057&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;345px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193808203.png&#34;
	width=&#34;1380&#34;
	height=&#34;571&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193808203&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;580px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/class-with-object-03/%E3%80%90C&amp;#43;&amp;#43;%E5%88%9D%E9%98%B6%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20250911193821915.png&#34;
	width=&#34;916&#34;
	height=&#34;616&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250911193821915&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;356px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
