<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>进程间通信 on PursUnre的博客</title>
        <link>https://Amarantos-Arrebol.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link>
        <description>Recent content in 进程间通信 on PursUnre的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>PursUnre</copyright>
        <lastBuildDate>Wed, 19 Nov 2025 08:55:11 +0000</lastBuildDate><atom:link href="https://Amarantos-Arrebol.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>【Linux】08进程间通信</title>
        <link>https://Amarantos-Arrebol.github.io/p/linux-interprocess-communication/</link>
        <pubDate>Wed, 19 Nov 2025 00:00:00 +0000</pubDate>
        
        <guid>https://Amarantos-Arrebol.github.io/p/linux-interprocess-communication/</guid>
        <description>&lt;img src="https://Amarantos-Arrebol.github.io/p/linux-interprocess-communication/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%A4%95%E9%98%B3-%E6%8F%92%E7%94%BB-%E6%A2%A6%E5%B9%BB%E5%B0%8F%E5%B1%8B.png" alt="Featured image of post 【Linux】08进程间通信" /&gt;&lt;h1 id=&#34;1基本介绍&#34;&gt;1.基本介绍
&lt;/h1&gt;&lt;h2 id=&#34;11理解&#34;&gt;1.1理解
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ls -l | wc -l&lt;/p&gt;
&lt;p&gt;ls -l是一个进程，wc -l也是一个进程，ls -l进程通过管道将结果交给wc -l&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么要进程间通信？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据传输：一个进程需要将它的数据发送给另一个进程&lt;/li&gt;
&lt;li&gt;资源共享：多个进程之间共享同样的资源。&lt;/li&gt;
&lt;li&gt;通知事件：一个进程需要&lt;strong&gt;向另一个或一组进程发送消息&lt;/strong&gt;，&lt;strong&gt;通知它&lt;/strong&gt;（它们）发生了某种事件（如进程终止时要通知父进程）。&lt;/li&gt;
&lt;li&gt;进程控制：有些进程希望&lt;strong&gt;完全控制另一个进程的执行&lt;/strong&gt;（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;怎么通信？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程间通信的本质：是先让不同的进程，先看到同一份资源[&amp;ldquo;内存&amp;rdquo;]（然后才有通信的条件）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同一份资源[&amp;ldquo;内存&amp;rdquo;] 得由操作系统提供—&amp;gt;系统调用—&amp;gt;操作系统的接口—&amp;gt;设计&lt;strong&gt;统一&lt;/strong&gt;的通信接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是通信？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程间通信（IPC，Inter-ProcessCommunication）是指运行在同一台计算机或不同计算机上的多个进程之间&lt;strong&gt;进行数据交换和通信的技术&lt;/strong&gt;。由于每个进程都有自己的地址空间，它们无法直接访问彼此的数据，因此需要通过特定的机制来实现通信。IPC是操作系统和多进程编程中的一个重要概念，广泛应用于分布式系统、多任务操作系统以及各种应用程序之间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;进程间通信的发展&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;SystemV进程间通信&lt;/li&gt;
&lt;li&gt;POSIX进程间通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;12环境&#34;&gt;1.2环境
&lt;/h2&gt;&lt;p&gt;环境：ubuntu20.04 c++  vscode(编辑器)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重装系统：云服务器后台，云服务器实例，重装系统/更多-&amp;gt;重新安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vscode上写代码同步到云服务器/虚拟机上&lt;/p&gt;
&lt;p&gt;1.安装remote-ssh&lt;/p&gt;
&lt;p&gt;2.添加云服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/linux-interprocess-communication/index.assets/image-20251119130734177.png&#34;
	width=&#34;468&#34;
	height=&#34;98&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119130734177&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;477&#34;
		data-flex-basis=&#34;1146px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;ssh 用户名@云服务器的IP地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/linux-interprocess-communication/index.assets/image-20251119130717258.png&#34;
	width=&#34;711&#34;
	height=&#34;134&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119130717258&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;530&#34;
		data-flex-basis=&#34;1273px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在vscode上编译代码：Makefile，ctrl+~调出vscode的xshell，make&lt;/p&gt;
&lt;p&gt;vscode插件：GDB Debug，C/C++ Extension Pack ，Fitten Code: Faster and Better AI Assis&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机连vscode：ifconfig，inet后面的ip地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;13具体通信方式&#34;&gt;1.3具体通信方式
&lt;/h2&gt;&lt;p&gt;1.基于文件的，管道同喜&lt;/p&gt;
&lt;p&gt;2.System V -本机通信&lt;/p&gt;
&lt;h1 id=&#34;2管道&#34;&gt;2.管道
&lt;/h1&gt;&lt;h2 id=&#34;21背景&#34;&gt;2.1背景
&lt;/h2&gt;&lt;p&gt;基于已有的技术，直接进行通信——&amp;gt;文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是管道&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;管道是Unix中最古老的进程间通信的形式&lt;/p&gt;
&lt;p&gt;我们把从&lt;strong&gt;一个进程连接到另一个进程的一个数据流&lt;/strong&gt;称为一个“管道”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://Amarantos-Arrebol.github.io/p/linux-interprocess-communication/index.assets/image-20251119154114596.png&#34;
	width=&#34;907&#34;
	height=&#34;501&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20251119154114596&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;434px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;who 查看当前Linux中在线用户个数&lt;/p&gt;
&lt;p&gt;wc -l 当前系统有多少人在使用&lt;/p&gt;
&lt;h2 id=&#34;22管道的原理&#34;&gt;2.2管道的原理
&lt;/h2&gt;&lt;p&gt;用 fork 来共享管道原理
站在文件描述符角度-深度理解管道站在内核角度-管道本质&lt;/p&gt;
&lt;h2 id=&#34;23管道样例&#34;&gt;2.3管道样例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;测试管道读写&lt;/li&gt;
&lt;li&gt;创建进程池处理任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;24基于匿名管道进程池&#34;&gt;2.4基于匿名管道&amp;ndash;进程池
&lt;/h2&gt;&lt;p&gt;管道读写规则
管道特点
验证管道通信的4种情况&lt;/p&gt;
&lt;h1 id=&#34;3匿名管道&#34;&gt;3.匿名管道
&lt;/h1&gt;&lt;h1 id=&#34;4命名管道&#34;&gt;4.命名管道
&lt;/h1&gt;&lt;p&gt;创建一个命名管道&lt;/p&gt;
&lt;p&gt;匿名管道与命名管道的区别&lt;/p&gt;
&lt;p&gt;命名管道的打开规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例1.用命名管道实现文件拷贝&lt;/li&gt;
&lt;li&gt;实例2.用命名管道实现server&amp;amp;client通信&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5system-v共享内存&#34;&gt;5.system V共享内存
&lt;/h1&gt;&lt;p&gt;共享内存示意图&lt;/p&gt;
&lt;p&gt;共享内存数据结构&lt;/p&gt;
&lt;p&gt;共享内存函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例1.共享内存实现通信&lt;/li&gt;
&lt;li&gt;实例2.借助管道实现访问控制版的共享内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6system-v消息队列和信号量&#34;&gt;6.system V消息队列和信号量
&lt;/h1&gt;&lt;p&gt;并发编程，概念铺垫&lt;/p&gt;
&lt;h1 id=&#34;7内核是如何组织管理ipc资源的&#34;&gt;7.内核是如何组织管理IPC资源的
&lt;/h1&gt;</description>
        </item>
        
    </channel>
</rss>
